
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    function assign$1(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }

    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
    // at the end of hydration without touching the remaining nodes.
    let is_hydrating = false;
    function start_hydrating() {
        is_hydrating = true;
    }
    function end_hydrating() {
        is_hydrating = false;
    }
    function upper_bound(low, high, key, value) {
        // Return first index of value larger than input value in the range [low, high)
        while (low < high) {
            const mid = low + ((high - low) >> 1);
            if (key(mid) <= value) {
                low = mid + 1;
            }
            else {
                high = mid;
            }
        }
        return low;
    }
    function init_hydrate(target) {
        if (target.hydrate_init)
            return;
        target.hydrate_init = true;
        // We know that all children have claim_order values since the unclaimed have been detached
        const children = target.childNodes;
        /*
        * Reorder claimed children optimally.
        * We can reorder claimed children optimally by finding the longest subsequence of
        * nodes that are already claimed in order and only moving the rest. The longest
        * subsequence subsequence of nodes that are claimed in order can be found by
        * computing the longest increasing subsequence of .claim_order values.
        *
        * This algorithm is optimal in generating the least amount of reorder operations
        * possible.
        *
        * Proof:
        * We know that, given a set of reordering operations, the nodes that do not move
        * always form an increasing subsequence, since they do not move among each other
        * meaning that they must be already ordered among each other. Thus, the maximal
        * set of nodes that do not move form a longest increasing subsequence.
        */
        // Compute longest increasing subsequence
        // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j
        const m = new Int32Array(children.length + 1);
        // Predecessor indices + 1
        const p = new Int32Array(children.length);
        m[0] = -1;
        let longest = 0;
        for (let i = 0; i < children.length; i++) {
            const current = children[i].claim_order;
            // Find the largest subsequence length such that it ends in a value less than our current value
            // upper_bound returns first greater value, so we subtract one
            const seqLen = upper_bound(1, longest + 1, idx => children[m[idx]].claim_order, current) - 1;
            p[i] = m[seqLen] + 1;
            const newLen = seqLen + 1;
            // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.
            m[newLen] = i;
            longest = Math.max(newLen, longest);
        }
        // The longest increasing subsequence of nodes (initially reversed)
        const lis = [];
        // The rest of the nodes, nodes that will be moved
        const toMove = [];
        let last = children.length - 1;
        for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
            lis.push(children[cur - 1]);
            for (; last >= cur; last--) {
                toMove.push(children[last]);
            }
            last--;
        }
        for (; last >= 0; last--) {
            toMove.push(children[last]);
        }
        lis.reverse();
        // We sort the nodes being moved to guarantee that their insertion order matches the claim order
        toMove.sort((a, b) => a.claim_order - b.claim_order);
        // Finally, we move the nodes
        for (let i = 0, j = 0; i < toMove.length; i++) {
            while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
                j++;
            }
            const anchor = j < lis.length ? lis[j] : null;
            target.insertBefore(toMove[i], anchor);
        }
    }
    function append(target, node) {
        if (is_hydrating) {
            init_hydrate(target);
            if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {
                target.actual_end_child = target.firstChild;
            }
            if (node !== target.actual_end_child) {
                target.insertBefore(node, target.actual_end_child);
            }
            else {
                target.actual_end_child = node.nextSibling;
            }
        }
        else if (node.parentNode !== target) {
            target.appendChild(node);
        }
    }
    function insert(target, node, anchor) {
        if (is_hydrating && !anchor) {
            append(target, node);
        }
        else if (node.parentNode !== target || (anchor && node.nextSibling !== anchor)) {
            target.insertBefore(node, anchor || null);
        }
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function empty() {
        return text('');
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                start_hydrating();
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            end_hydrating();
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.38.3' }, detail)));
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /**
     * @typedef {Object} WrappedComponent Object returned by the `wrap` method
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback AsyncSvelteComponent
     * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions Options object for the call to `wrap`
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap$1(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function parse(str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules/svelte-spa-router/Router.svelte generated by Svelte v3.38.3 */

    const { Error: Error_1, Object: Object_1, console: console_1 } = globals;

    // (251:0) {:else}
    function create_else_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign$1(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(251:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (244:0) {#if componentParams}
    function create_if_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign$1(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(244:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap(component, userData, ...conditions) {
    	// Use the new wrap method and show a deprecation warning
    	// eslint-disable-next-line no-console
    	console.warn("Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading");

    	return wrap$1({ component, userData, conditions });
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf("#/");

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: "/";

    	// Check if there's a querystring
    	const qsPosition = location.indexOf("?");

    	let querystring = "";

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener("hashchange", update, false);

    	return function stop() {
    		window.removeEventListener("hashchange", update, false);
    	};
    });

    const location = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);
    const params = writable(undefined);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == "#" ? "" : "#") + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == "#" ? "" : "#") + location;

    	try {
    		const newState = { ...history.state };
    		delete newState["__svelte_spa_router_scrollX"];
    		delete newState["__svelte_spa_router_scrollY"];
    		window.history.replaceState(newState, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn("Caught exception while replacing the current page. If you're running this in the Svelte REPL, please note that the `replace` method might not work in this environment.");
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event("hashchange"));
    }

    function link(node, opts) {
    	opts = linkOpts(opts);

    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != "a") {
    		throw Error("Action \"link\" can only be used with <a> tags");
    	}

    	updateLink(node, opts);

    	return {
    		update(updated) {
    			updated = linkOpts(updated);
    			updateLink(node, updated);
    		}
    	};
    }

    // Internal function used by the link function
    function updateLink(node, opts) {
    	let href = opts.href || node.getAttribute("href");

    	// Destination must start with '/' or '#/'
    	if (href && href.charAt(0) == "/") {
    		// Add # to the href attribute
    		href = "#" + href;
    	} else if (!href || href.length < 2 || href.slice(0, 2) != "#/") {
    		throw Error("Invalid value for \"href\" attribute: " + href);
    	}

    	node.setAttribute("href", href);

    	node.addEventListener("click", event => {
    		// Prevent default anchor onclick behaviour
    		event.preventDefault();

    		if (!opts.disabled) {
    			scrollstateHistoryHandler(event.currentTarget.getAttribute("href"));
    		}
    	});
    }

    // Internal function that ensures the argument of the link action is always an object
    function linkOpts(val) {
    	if (val && typeof val == "string") {
    		return { href: val };
    	} else {
    		return val || {};
    	}
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {string} href - Destination
     */
    function scrollstateHistoryHandler(href) {
    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Router", slots, []);
    	let { routes = {} } = $$props;
    	let { prefix = "" } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != "function" && (typeof component != "object" || component._sveltesparouter !== true)) {
    				throw Error("Invalid component object");
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == "string" && (path.length < 1 || path.charAt(0) != "/" && path.charAt(0) != "*") || typeof path == "object" && !(path instanceof RegExp)) {
    				throw Error("Invalid value for \"path\" argument - strings must start with / or *");
    			}

    			const { pattern, keys } = parse(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == "object" && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, check if it matches the start of the path.
    			// If not, bail early, else remove it before we run the matching.
    			if (prefix) {
    				if (typeof prefix == "string") {
    					if (path.startsWith(prefix)) {
    						path = path.substr(prefix.length) || "/";
    					} else {
    						return null;
    					}
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || "/";
    					} else {
    						return null;
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || "") || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {boolean} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	let popStateChanged = null;

    	if (restoreScrollState) {
    		popStateChanged = event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && event.state.__svelte_spa_router_scrollY) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		};

    		// This is removed in the destroy() invocation below
    		window.addEventListener("popstate", popStateChanged);

    		afterUpdate(() => {
    			// If this exists, then this is a back navigation: restore the scroll position
    			if (previousScrollState) {
    				window.scrollTo(previousScrollState.__svelte_spa_router_scrollX, previousScrollState.__svelte_spa_router_scrollY);
    			} else {
    				// Otherwise this is a forward navigation: scroll to top
    				window.scrollTo(0, 0);
    			}
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	const unsubscribeLoc = loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData,
    				params: match && typeof match == "object" && Object.keys(match).length
    				? match
    				: null
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick("conditionsFailed", detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoading", Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick("routeLoaded", Object.assign({}, detail, {
    						component,
    						name: component.name,
    						params: componentParams
    					}));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == "object" && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoaded", Object.assign({}, detail, {
    				component,
    				name: component.name,
    				params: componentParams
    			})).then(() => {
    				params.set(componentParams);
    			});

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    		params.set(undefined);
    	});

    	onDestroy(() => {
    		unsubscribeLoc();
    		popStateChanged && window.removeEventListener("popstate", popStateChanged);
    	});

    	const writable_props = ["routes", "prefix", "restoreScrollState"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	function routeEvent_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		writable,
    		derived,
    		tick,
    		_wrap: wrap$1,
    		wrap,
    		getLocation,
    		loc,
    		location,
    		querystring,
    		params,
    		push,
    		pop,
    		replace,
    		link,
    		updateLink,
    		linkOpts,
    		scrollstateHistoryHandler,
    		onDestroy,
    		createEventDispatcher,
    		afterUpdate,
    		parse,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		popStateChanged,
    		lastLoc,
    		componentObj,
    		unsubscribeLoc
    	});

    	$$self.$inject_state = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    		if ("componentParams" in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ("props" in $$props) $$invalidate(2, props = $$props.props);
    		if ("previousScrollState" in $$props) previousScrollState = $$props.previousScrollState;
    		if ("popStateChanged" in $$props) popStateChanged = $$props.popStateChanged;
    		if ("lastLoc" in $$props) lastLoc = $$props.lastLoc;
    		if ("componentObj" in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			history.scrollRestoration = restoreScrollState ? "manual" : "auto";
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @module ol/events/Event
     */
    /**
     * @classdesc
     * Stripped down implementation of the W3C DOM Level 2 Event interface.
     * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
     *
     * This implementation only provides `type` and `target` properties, and
     * `stopPropagation` and `preventDefault` methods. It is meant as base class
     * for higher level events defined in the library, and works with
     * {@link module:ol/events/Target~Target}.
     */
    var BaseEvent = /** @class */ (function () {
        /**
         * @param {string} type Type.
         */
        function BaseEvent(type) {
            /**
             * @type {boolean}
             */
            this.propagationStopped;
            /**
             * The event type.
             * @type {string}
             * @api
             */
            this.type = type;
            /**
             * The event target.
             * @type {Object}
             * @api
             */
            this.target = null;
        }
        /**
         * Stop event propagation.
         * @api
         */
        BaseEvent.prototype.preventDefault = function () {
            this.propagationStopped = true;
        };
        /**
         * Stop event propagation.
         * @api
         */
        BaseEvent.prototype.stopPropagation = function () {
            this.propagationStopped = true;
        };
        return BaseEvent;
    }());

    /**
     * @module ol/events/EventType
     */
    /**
     * @enum {string}
     * @const
     */
    var EventType = {
        /**
         * Generic change event. Triggered when the revision counter is increased.
         * @event module:ol/events/Event~BaseEvent#change
         * @api
         */
        CHANGE: 'change',
        /**
         * Generic error event. Triggered when an error occurs.
         * @event module:ol/events/Event~BaseEvent#error
         * @api
         */
        ERROR: 'error',
        BLUR: 'blur',
        CLEAR: 'clear',
        CONTEXTMENU: 'contextmenu',
        CLICK: 'click',
        DBLCLICK: 'dblclick',
        DRAGENTER: 'dragenter',
        DRAGOVER: 'dragover',
        DROP: 'drop',
        FOCUS: 'focus',
        KEYDOWN: 'keydown',
        KEYPRESS: 'keypress',
        LOAD: 'load',
        RESIZE: 'resize',
        TOUCHMOVE: 'touchmove',
        WHEEL: 'wheel',
    };

    /**
     * @module ol/format/FormatType
     */
    /**
     * @enum {string}
     */
    var FormatType = {
        ARRAY_BUFFER: 'arraybuffer',
        JSON: 'json',
        TEXT: 'text',
        XML: 'xml',
    };

    /**
     * @module ol/ObjectEventType
     */
    /**
     * @enum {string}
     */
    var ObjectEventType = {
        /**
         * Triggered when a property is changed.
         * @event module:ol/Object.ObjectEvent#propertychange
         * @api
         */
        PROPERTYCHANGE: 'propertychange',
    };

    /**
     * @module ol/Disposable
     */
    /**
     * @classdesc
     * Objects that need to clean up after themselves.
     */
    var Disposable = /** @class */ (function () {
        function Disposable() {
            /**
             * The object has already been disposed.
             * @type {boolean}
             * @protected
             */
            this.disposed = false;
        }
        /**
         * Clean up.
         */
        Disposable.prototype.dispose = function () {
            if (!this.disposed) {
                this.disposed = true;
                this.disposeInternal();
            }
        };
        /**
         * Extension point for disposable objects.
         * @protected
         */
        Disposable.prototype.disposeInternal = function () { };
        return Disposable;
    }());

    /**
     * @module ol/array
     */
    /**
     * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
     * https://github.com/darkskyapp/binary-search
     *
     * @param {Array<*>} haystack Items to search through.
     * @param {*} needle The item to look for.
     * @param {Function=} opt_comparator Comparator function.
     * @return {number} The index of the item if found, -1 if not.
     */
    function binarySearch(haystack, needle, opt_comparator) {
        var mid, cmp;
        var comparator = opt_comparator || numberSafeCompareFunction;
        var low = 0;
        var high = haystack.length;
        var found = false;
        while (low < high) {
            /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
             * to double (which gives the wrong results). */
            mid = low + ((high - low) >> 1);
            cmp = +comparator(haystack[mid], needle);
            if (cmp < 0.0) {
                /* Too low. */
                low = mid + 1;
            }
            else {
                /* Key found or too high */
                high = mid;
                found = !cmp;
            }
        }
        /* Key not found. */
        return found ? low : ~low;
    }
    /**
     * Compare function for array sort that is safe for numbers.
     * @param {*} a The first object to be compared.
     * @param {*} b The second object to be compared.
     * @return {number} A negative number, zero, or a positive number as the first
     *     argument is less than, equal to, or greater than the second.
     */
    function numberSafeCompareFunction(a, b) {
        return a > b ? 1 : a < b ? -1 : 0;
    }
    /**
     * @param {Array<number>} arr Array.
     * @param {number} target Target.
     * @param {number} direction 0 means return the nearest, > 0
     *    means return the largest nearest, < 0 means return the
     *    smallest nearest.
     * @return {number} Index.
     */
    function linearFindNearest(arr, target, direction) {
        var n = arr.length;
        if (arr[0] <= target) {
            return 0;
        }
        else if (target <= arr[n - 1]) {
            return n - 1;
        }
        else {
            var i = void 0;
            if (direction > 0) {
                for (i = 1; i < n; ++i) {
                    if (arr[i] < target) {
                        return i - 1;
                    }
                }
            }
            else if (direction < 0) {
                for (i = 1; i < n; ++i) {
                    if (arr[i] <= target) {
                        return i;
                    }
                }
            }
            else {
                for (i = 1; i < n; ++i) {
                    if (arr[i] == target) {
                        return i;
                    }
                    else if (arr[i] < target) {
                        if (arr[i - 1] - target < target - arr[i]) {
                            return i - 1;
                        }
                        else {
                            return i;
                        }
                    }
                }
            }
            return n - 1;
        }
    }
    /**
     * @param {Array<*>} arr Array.
     * @param {number} begin Begin index.
     * @param {number} end End index.
     */
    function reverseSubArray(arr, begin, end) {
        while (begin < end) {
            var tmp = arr[begin];
            arr[begin] = arr[end];
            arr[end] = tmp;
            ++begin;
            --end;
        }
    }
    /**
     * @param {Array<VALUE>} arr The array to modify.
     * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
     * @template VALUE
     */
    function extend$2(arr, data) {
        var extension = Array.isArray(data) ? data : [data];
        var length = extension.length;
        for (var i = 0; i < length; i++) {
            arr[arr.length] = extension[i];
        }
    }
    /**
     * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
     * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
     * @return {boolean} Whether the two arrays are equal.
     */
    function equals$2(arr1, arr2) {
        var len1 = arr1.length;
        if (len1 !== arr2.length) {
            return false;
        }
        for (var i = 0; i < len1; i++) {
            if (arr1[i] !== arr2[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * @param {Array<*>} arr The array to test.
     * @param {Function=} opt_func Comparison function.
     * @param {boolean=} opt_strict Strictly sorted (default false).
     * @return {boolean} Return index.
     */
    function isSorted(arr, opt_func, opt_strict) {
        var compare = opt_func || numberSafeCompareFunction;
        return arr.every(function (currentVal, index) {
            if (index === 0) {
                return true;
            }
            var res = compare(arr[index - 1], currentVal);
            return !(res > 0 || (opt_strict && res === 0));
        });
    }

    /**
     * @module ol/functions
     */
    /**
     * Always returns true.
     * @returns {boolean} true.
     */
    function TRUE() {
        return true;
    }
    /**
     * Always returns false.
     * @returns {boolean} false.
     */
    function FALSE() {
        return false;
    }
    /**
     * A reusable function, used e.g. as a default for callbacks.
     *
     * @return {void} Nothing.
     */
    function VOID() { }
    /**
     * Wrap a function in another function that remembers the last return.  If the
     * returned function is called twice in a row with the same arguments and the same
     * this object, it will return the value from the first call in the second call.
     *
     * @param {function(...any): ReturnType} fn The function to memoize.
     * @return {function(...any): ReturnType} The memoized function.
     * @template ReturnType
     */
    function memoizeOne(fn) {
        var called = false;
        /** @type {ReturnType} */
        var lastResult;
        /** @type {Array<any>} */
        var lastArgs;
        var lastThis;
        return function () {
            var nextArgs = Array.prototype.slice.call(arguments);
            if (!called || this !== lastThis || !equals$2(nextArgs, lastArgs)) {
                called = true;
                lastThis = this;
                lastArgs = nextArgs;
                lastResult = fn.apply(this, arguments);
            }
            return lastResult;
        };
    }

    /**
     * @module ol/obj
     */
    /**
     * Polyfill for Object.assign().  Assigns enumerable and own properties from
     * one or more source objects to a target object.
     * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
     *
     * @param {!Object} target The target object.
     * @param {...Object} var_sources The source object(s).
     * @return {!Object} The modified target object.
     */
    var assign = typeof Object.assign === 'function'
        ? Object.assign
        : function (target, var_sources) {
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }
            var output = Object(target);
            for (var i = 1, ii = arguments.length; i < ii; ++i) {
                var source = arguments[i];
                if (source !== undefined && source !== null) {
                    for (var key in source) {
                        if (source.hasOwnProperty(key)) {
                            output[key] = source[key];
                        }
                    }
                }
            }
            return output;
        };
    /**
     * Removes all properties from an object.
     * @param {Object} object The object to clear.
     */
    function clear(object) {
        for (var property in object) {
            delete object[property];
        }
    }
    /**
     * Polyfill for Object.values().  Get an array of property values from an object.
     * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values
     *
     * @param {!Object<K,V>} object The object from which to get the values.
     * @return {!Array<V>} The property values.
     * @template K,V
     */
    var getValues = typeof Object.values === 'function'
        ? Object.values
        : function (object) {
            var values = [];
            for (var property in object) {
                values.push(object[property]);
            }
            return values;
        };
    /**
     * Determine if an object has any properties.
     * @param {Object} object The object to check.
     * @return {boolean} The object is empty.
     */
    function isEmpty$1(object) {
        var property;
        for (property in object) {
            return false;
        }
        return !property;
    }

    var __extends$1l = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {EventTarget|Target} EventTargetLike
     */
    /**
     * @classdesc
     * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
     * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
     *
     * There are two important simplifications compared to the specification:
     *
     * 1. The handling of `useCapture` in `addEventListener` and
     *    `removeEventListener`. There is no real capture model.
     * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
     *    There is no event target hierarchy. When a listener calls
     *    `stopPropagation` or `preventDefault` on an event object, it means that no
     *    more listeners after this one will be called. Same as when the listener
     *    returns false.
     */
    var Target = /** @class */ (function (_super) {
        __extends$1l(Target, _super);
        /**
         * @param {*=} opt_target Default event target for dispatched events.
         */
        function Target(opt_target) {
            var _this = _super.call(this) || this;
            /**
             * @private
             * @type {*}
             */
            _this.eventTarget_ = opt_target;
            /**
             * @private
             * @type {Object<string, number>}
             */
            _this.pendingRemovals_ = null;
            /**
             * @private
             * @type {Object<string, number>}
             */
            _this.dispatching_ = null;
            /**
             * @private
             * @type {Object<string, Array<import("../events.js").Listener>>}
             */
            _this.listeners_ = null;
            return _this;
        }
        /**
         * @param {string} type Type.
         * @param {import("../events.js").Listener} listener Listener.
         */
        Target.prototype.addEventListener = function (type, listener) {
            if (!type || !listener) {
                return;
            }
            var listeners = this.listeners_ || (this.listeners_ = {});
            var listenersForType = listeners[type] || (listeners[type] = []);
            if (listenersForType.indexOf(listener) === -1) {
                listenersForType.push(listener);
            }
        };
        /**
         * Dispatches an event and calls all listeners listening for events
         * of this type. The event parameter can either be a string or an
         * Object with a `type` property.
         *
         * @param {import("./Event.js").default|string} event Event object.
         * @return {boolean|undefined} `false` if anyone called preventDefault on the
         *     event object or if any of the listeners returned false.
         * @api
         */
        Target.prototype.dispatchEvent = function (event) {
            /** @type {import("./Event.js").default|Event} */
            var evt = typeof event === 'string' ? new BaseEvent(event) : event;
            var type = evt.type;
            if (!evt.target) {
                evt.target = this.eventTarget_ || this;
            }
            var listeners = this.listeners_ && this.listeners_[type];
            var propagate;
            if (listeners) {
                var dispatching = this.dispatching_ || (this.dispatching_ = {});
                var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
                if (!(type in dispatching)) {
                    dispatching[type] = 0;
                    pendingRemovals[type] = 0;
                }
                ++dispatching[type];
                for (var i = 0, ii = listeners.length; i < ii; ++i) {
                    if ('handleEvent' in listeners[i]) {
                        propagate = /** @type {import("../events.js").ListenerObject} */ (listeners[i]).handleEvent(evt);
                    }
                    else {
                        propagate = /** @type {import("../events.js").ListenerFunction} */ (listeners[i]).call(this, evt);
                    }
                    if (propagate === false || evt.propagationStopped) {
                        propagate = false;
                        break;
                    }
                }
                --dispatching[type];
                if (dispatching[type] === 0) {
                    var pr = pendingRemovals[type];
                    delete pendingRemovals[type];
                    while (pr--) {
                        this.removeEventListener(type, VOID);
                    }
                    delete dispatching[type];
                }
                return propagate;
            }
        };
        /**
         * Clean up.
         */
        Target.prototype.disposeInternal = function () {
            this.listeners_ && clear(this.listeners_);
        };
        /**
         * Get the listeners for a specified event type. Listeners are returned in the
         * order that they will be called in.
         *
         * @param {string} type Type.
         * @return {Array<import("../events.js").Listener>|undefined} Listeners.
         */
        Target.prototype.getListeners = function (type) {
            return (this.listeners_ && this.listeners_[type]) || undefined;
        };
        /**
         * @param {string=} opt_type Type. If not provided,
         *     `true` will be returned if this event target has any listeners.
         * @return {boolean} Has listeners.
         */
        Target.prototype.hasListener = function (opt_type) {
            if (!this.listeners_) {
                return false;
            }
            return opt_type
                ? opt_type in this.listeners_
                : Object.keys(this.listeners_).length > 0;
        };
        /**
         * @param {string} type Type.
         * @param {import("../events.js").Listener} listener Listener.
         */
        Target.prototype.removeEventListener = function (type, listener) {
            var listeners = this.listeners_ && this.listeners_[type];
            if (listeners) {
                var index = listeners.indexOf(listener);
                if (index !== -1) {
                    if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                        // make listener a no-op, and remove later in #dispatchEvent()
                        listeners[index] = VOID;
                        ++this.pendingRemovals_[type];
                    }
                    else {
                        listeners.splice(index, 1);
                        if (listeners.length === 0) {
                            delete this.listeners_[type];
                        }
                    }
                }
            }
        };
        return Target;
    }(Disposable));

    /**
     * @module ol/events
     */
    /**
     * Key to use with {@link module:ol/Observable~Observable#unByKey}.
     * @typedef {Object} EventsKey
     * @property {ListenerFunction} listener
     * @property {import("./events/Target.js").EventTargetLike} target
     * @property {string} type
     * @api
     */
    /**
     * Listener function. This function is called with an event object as argument.
     * When the function returns `false`, event propagation will stop.
     *
     * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
     * @api
     */
    /**
     * @typedef {Object} ListenerObject
     * @property {ListenerFunction} handleEvent
     */
    /**
     * @typedef {ListenerFunction|ListenerObject} Listener
     */
    /**
     * Registers an event listener on an event target. Inspired by
     * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
     *
     * This function efficiently binds a `listener` to a `this` object, and returns
     * a key for use with {@link module:ol/events~unlistenByKey}.
     *
     * @param {import("./events/Target.js").EventTargetLike} target Event target.
     * @param {string} type Event type.
     * @param {ListenerFunction} listener Listener.
     * @param {Object=} opt_this Object referenced by the `this` keyword in the
     *     listener. Default is the `target`.
     * @param {boolean=} opt_once If true, add the listener as one-off listener.
     * @return {EventsKey} Unique key for the listener.
     */
    function listen(target, type, listener, opt_this, opt_once) {
        if (opt_this && opt_this !== target) {
            listener = listener.bind(opt_this);
        }
        if (opt_once) {
            var originalListener_1 = listener;
            listener = function () {
                target.removeEventListener(type, listener);
                originalListener_1.apply(this, arguments);
            };
        }
        var eventsKey = {
            target: target,
            type: type,
            listener: listener,
        };
        target.addEventListener(type, listener);
        return eventsKey;
    }
    /**
     * Registers a one-off event listener on an event target. Inspired by
     * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
     *
     * This function efficiently binds a `listener` as self-unregistering listener
     * to a `this` object, and returns a key for use with
     * {@link module:ol/events~unlistenByKey} in case the listener needs to be
     * unregistered before it is called.
     *
     * When {@link module:ol/events~listen} is called with the same arguments after this
     * function, the self-unregistering listener will be turned into a permanent
     * listener.
     *
     * @param {import("./events/Target.js").EventTargetLike} target Event target.
     * @param {string} type Event type.
     * @param {ListenerFunction} listener Listener.
     * @param {Object=} opt_this Object referenced by the `this` keyword in the
     *     listener. Default is the `target`.
     * @return {EventsKey} Key for unlistenByKey.
     */
    function listenOnce(target, type, listener, opt_this) {
        return listen(target, type, listener, opt_this, true);
    }
    /**
     * Unregisters event listeners on an event target. Inspired by
     * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
     *
     * The argument passed to this function is the key returned from
     * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
     *
     * @param {EventsKey} key The key.
     */
    function unlistenByKey(key) {
        if (key && key.target) {
            key.target.removeEventListener(key.type, key.listener);
            clear(key);
        }
    }

    var __extends$1k = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * An event target providing convenient methods for listener registration
     * and unregistration. A generic `change` event is always available through
     * {@link module:ol/Observable~Observable#changed}.
     *
     * @fires import("./events/Event.js").default
     * @api
     */
    var Observable = /** @class */ (function (_super) {
        __extends$1k(Observable, _super);
        function Observable() {
            var _this = _super.call(this) || this;
            /**
             * @private
             * @type {number}
             */
            _this.revision_ = 0;
            return _this;
        }
        /**
         * Increases the revision counter and dispatches a 'change' event.
         * @api
         */
        Observable.prototype.changed = function () {
            ++this.revision_;
            this.dispatchEvent(EventType.CHANGE);
        };
        /**
         * Get the version number for this object.  Each time the object is modified,
         * its version number will be incremented.
         * @return {number} Revision.
         * @api
         */
        Observable.prototype.getRevision = function () {
            return this.revision_;
        };
        /**
         * Listen for a certain type of event.
         * @param {string|Array<string>} type The event type or array of event types.
         * @param {function(?): ?} listener The listener function.
         * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
         *     called with an array of event types as the first argument, the return
         *     will be an array of keys.
         * @api
         */
        Observable.prototype.on = function (type, listener) {
            if (Array.isArray(type)) {
                var len = type.length;
                var keys = new Array(len);
                for (var i = 0; i < len; ++i) {
                    keys[i] = listen(this, type[i], listener);
                }
                return keys;
            }
            else {
                return listen(this, /** @type {string} */ (type), listener);
            }
        };
        /**
         * Listen once for a certain type of event.
         * @param {string|Array<string>} type The event type or array of event types.
         * @param {function(?): ?} listener The listener function.
         * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
         *     called with an array of event types as the first argument, the return
         *     will be an array of keys.
         * @api
         */
        Observable.prototype.once = function (type, listener) {
            var key;
            if (Array.isArray(type)) {
                var len = type.length;
                key = new Array(len);
                for (var i = 0; i < len; ++i) {
                    key[i] = listenOnce(this, type[i], listener);
                }
            }
            else {
                key = listenOnce(this, /** @type {string} */ (type), listener);
            }
            /** @type {Object} */ (listener).ol_key = key;
            return key;
        };
        /**
         * Unlisten for a certain type of event.
         * @param {string|Array<string>} type The event type or array of event types.
         * @param {function(?): ?} listener The listener function.
         * @api
         */
        Observable.prototype.un = function (type, listener) {
            var key = /** @type {Object} */ (listener).ol_key;
            if (key) {
                unByKey(key);
            }
            else if (Array.isArray(type)) {
                for (var i = 0, ii = type.length; i < ii; ++i) {
                    this.removeEventListener(type[i], listener);
                }
            }
            else {
                this.removeEventListener(type, listener);
            }
        };
        return Observable;
    }(Target));
    /**
     * Removes an event listener using the key returned by `on()` or `once()`.
     * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
     *     or `once()` (or an array of keys).
     * @api
     */
    function unByKey(key) {
        if (Array.isArray(key)) {
            for (var i = 0, ii = key.length; i < ii; ++i) {
                unlistenByKey(key[i]);
            }
        }
        else {
            unlistenByKey(/** @type {import("./events.js").EventsKey} */ (key));
        }
    }

    /**
     * @module ol/util
     */
    /**
     * @return {?} Any return.
     */
    function abstract() {
        return /** @type {?} */ ((function () {
            throw new Error('Unimplemented abstract method.');
        })());
    }
    /**
     * Counter for getUid.
     * @type {number}
     * @private
     */
    var uidCounter_ = 0;
    /**
     * Gets a unique ID for an object. This mutates the object so that further calls
     * with the same object as a parameter returns the same value. Unique IDs are generated
     * as a strictly increasing sequence. Adapted from goog.getUid.
     *
     * @param {Object} obj The object to get the unique ID for.
     * @return {string} The unique ID for the object.
     * @api
     */
    function getUid(obj) {
        return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
    }
    /**
     * OpenLayers version.
     * @type {string}
     */
    var VERSION = '6.5.0';

    var __extends$1j = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
     */
    var ObjectEvent = /** @class */ (function (_super) {
        __extends$1j(ObjectEvent, _super);
        /**
         * @param {string} type The event type.
         * @param {string} key The property name.
         * @param {*} oldValue The old value for `key`.
         */
        function ObjectEvent(type, key, oldValue) {
            var _this = _super.call(this, type) || this;
            /**
             * The name of the property whose value is changing.
             * @type {string}
             * @api
             */
            _this.key = key;
            /**
             * The old value. To get the new value use `e.target.get(e.key)` where
             * `e` is the event object.
             * @type {*}
             * @api
             */
            _this.oldValue = oldValue;
            return _this;
        }
        return ObjectEvent;
    }(BaseEvent));
    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Most non-trivial classes inherit from this.
     *
     * This extends {@link module:ol/Observable} with observable
     * properties, where each property is observable as well as the object as a
     * whole.
     *
     * Classes that inherit from this have pre-defined properties, to which you can
     * add your owns. The pre-defined properties are listed in this documentation as
     * 'Observable Properties', and have their own accessors; for example,
     * {@link module:ol/Map~Map} has a `target` property, accessed with
     * `getTarget()` and changed with `setTarget()`. Not all properties are however
     * settable. There are also general-purpose accessors `get()` and `set()`. For
     * example, `get('target')` is equivalent to `getTarget()`.
     *
     * The `set` accessors trigger a change event, and you can monitor this by
     * registering a listener. For example, {@link module:ol/View~View} has a
     * `center` property, so `view.on('change:center', function(evt) {...});` would
     * call the function whenever the value of the center property changes. Within
     * the function, `evt.target` would be the view, so `evt.target.getCenter()`
     * would return the new center.
     *
     * You can add your own observable properties with
     * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
     * You can listen for changes on that property value with
     * `object.on('change:prop', listener)`. You can get a list of all
     * properties with {@link module:ol/Object~BaseObject#getProperties}.
     *
     * Note that the observable properties are separate from standard JS properties.
     * You can, for example, give your map object a title with
     * `map.title='New title'` and with `map.set('title', 'Another title')`. The
     * first will be a `hasOwnProperty`; the second will appear in
     * `getProperties()`. Only the second is observable.
     *
     * Properties can be deleted by using the unset method. E.g.
     * object.unset('foo').
     *
     * @fires ObjectEvent
     * @api
     */
    var BaseObject = /** @class */ (function (_super) {
        __extends$1j(BaseObject, _super);
        /**
         * @param {Object<string, *>=} opt_values An object with key-value pairs.
         */
        function BaseObject(opt_values) {
            var _this = _super.call(this) || this;
            // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is
            // the same as the order in which they were created.  This also helps to
            // ensure that object properties are always added in the same order, which
            // helps many JavaScript engines generate faster code.
            getUid(_this);
            /**
             * @private
             * @type {Object<string, *>}
             */
            _this.values_ = null;
            if (opt_values !== undefined) {
                _this.setProperties(opt_values);
            }
            return _this;
        }
        /**
         * Gets a value.
         * @param {string} key Key name.
         * @return {*} Value.
         * @api
         */
        BaseObject.prototype.get = function (key) {
            var value;
            if (this.values_ && this.values_.hasOwnProperty(key)) {
                value = this.values_[key];
            }
            return value;
        };
        /**
         * Get a list of object property names.
         * @return {Array<string>} List of property names.
         * @api
         */
        BaseObject.prototype.getKeys = function () {
            return (this.values_ && Object.keys(this.values_)) || [];
        };
        /**
         * Get an object of all property names and values.
         * @return {Object<string, *>} Object.
         * @api
         */
        BaseObject.prototype.getProperties = function () {
            return (this.values_ && assign({}, this.values_)) || {};
        };
        /**
         * @return {boolean} The object has properties.
         */
        BaseObject.prototype.hasProperties = function () {
            return !!this.values_;
        };
        /**
         * @param {string} key Key name.
         * @param {*} oldValue Old value.
         */
        BaseObject.prototype.notify = function (key, oldValue) {
            var eventType;
            eventType = getChangeEventType(key);
            this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
            eventType = ObjectEventType.PROPERTYCHANGE;
            this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        };
        /**
         * Sets a value.
         * @param {string} key Key name.
         * @param {*} value Value.
         * @param {boolean=} opt_silent Update without triggering an event.
         * @api
         */
        BaseObject.prototype.set = function (key, value, opt_silent) {
            var values = this.values_ || (this.values_ = {});
            if (opt_silent) {
                values[key] = value;
            }
            else {
                var oldValue = values[key];
                values[key] = value;
                if (oldValue !== value) {
                    this.notify(key, oldValue);
                }
            }
        };
        /**
         * Sets a collection of key-value pairs.  Note that this changes any existing
         * properties and adds new ones (it does not remove any existing properties).
         * @param {Object<string, *>} values Values.
         * @param {boolean=} opt_silent Update without triggering an event.
         * @api
         */
        BaseObject.prototype.setProperties = function (values, opt_silent) {
            for (var key in values) {
                this.set(key, values[key], opt_silent);
            }
        };
        /**
         * Apply any properties from another object without triggering events.
         * @param {BaseObject} source The source object.
         * @protected
         */
        BaseObject.prototype.applyProperties = function (source) {
            if (!source.values_) {
                return;
            }
            assign(this.values_ || (this.values_ = {}), source.values_);
        };
        /**
         * Unsets a property.
         * @param {string} key Key name.
         * @param {boolean=} opt_silent Unset without triggering an event.
         * @api
         */
        BaseObject.prototype.unset = function (key, opt_silent) {
            if (this.values_ && key in this.values_) {
                var oldValue = this.values_[key];
                delete this.values_[key];
                if (isEmpty$1(this.values_)) {
                    this.values_ = null;
                }
                if (!opt_silent) {
                    this.notify(key, oldValue);
                }
            }
        };
        return BaseObject;
    }(Observable));
    /**
     * @type {Object<string, string>}
     */
    var changeEventTypeCache = {};
    /**
     * @param {string} key Key name.
     * @return {string} Change name.
     */
    function getChangeEventType(key) {
        return changeEventTypeCache.hasOwnProperty(key)
            ? changeEventTypeCache[key]
            : (changeEventTypeCache[key] = 'change:' + key);
    }

    /**
     * @module ol/interaction/Property
     */
    /**
     * @enum {string}
     */
    var InteractionProperty = {
        ACTIVE: 'active',
    };

    /**
     * @module ol/easing
     */
    /**
     * Start slow and speed up.
     * @param {number} t Input between 0 and 1.
     * @return {number} Output between 0 and 1.
     * @api
     */
    function easeIn(t) {
        return Math.pow(t, 3);
    }
    /**
     * Start fast and slow down.
     * @param {number} t Input between 0 and 1.
     * @return {number} Output between 0 and 1.
     * @api
     */
    function easeOut(t) {
        return 1 - easeIn(1 - t);
    }
    /**
     * Start slow, speed up, and then slow down again.
     * @param {number} t Input between 0 and 1.
     * @return {number} Output between 0 and 1.
     * @api
     */
    function inAndOut(t) {
        return 3 * t * t - 2 * t * t * t;
    }
    /**
     * Maintain a constant speed over time.
     * @param {number} t Input between 0 and 1.
     * @return {number} Output between 0 and 1.
     * @api
     */
    function linear(t) {
        return t;
    }

    var __extends$1i = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * Object literal with config options for interactions.
     * @typedef {Object} InteractionOptions
     * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
     * Method called by the map to notify the interaction that a browser event was
     * dispatched to the map. If the function returns a falsy value, propagation of
     * the event to other interactions in the map's interactions chain will be
     * prevented (this includes functions with no explicit return). The interactions
     * are traversed in reverse order of the interactions collection of the map.
     */
    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * User actions that change the state of the map. Some are similar to controls,
     * but are not associated with a DOM element.
     * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
     * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
     * by a keyboard event not a button element event.
     * Although interactions do not have a DOM element, some of them do render
     * vectors and so are visible on the screen.
     * @api
     */
    var Interaction = /** @class */ (function (_super) {
        __extends$1i(Interaction, _super);
        /**
         * @param {InteractionOptions=} opt_options Options.
         */
        function Interaction(opt_options) {
            var _this = _super.call(this) || this;
            if (opt_options && opt_options.handleEvent) {
                _this.handleEvent = opt_options.handleEvent;
            }
            /**
             * @private
             * @type {import("../PluggableMap.js").default}
             */
            _this.map_ = null;
            _this.setActive(true);
            return _this;
        }
        /**
         * Return whether the interaction is currently active.
         * @return {boolean} `true` if the interaction is active, `false` otherwise.
         * @observable
         * @api
         */
        Interaction.prototype.getActive = function () {
            return /** @type {boolean} */ (this.get(InteractionProperty.ACTIVE));
        };
        /**
         * Get the map associated with this interaction.
         * @return {import("../PluggableMap.js").default} Map.
         * @api
         */
        Interaction.prototype.getMap = function () {
            return this.map_;
        };
        /**
         * Handles the {@link module:ol/MapBrowserEvent map browser event}.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
         * @return {boolean} `false` to stop event propagation.
         * @api
         */
        Interaction.prototype.handleEvent = function (mapBrowserEvent) {
            return true;
        };
        /**
         * Activate or deactivate the interaction.
         * @param {boolean} active Active.
         * @observable
         * @api
         */
        Interaction.prototype.setActive = function (active) {
            this.set(InteractionProperty.ACTIVE, active);
        };
        /**
         * Remove the interaction from its current map and attach it to the new map.
         * Subclasses may set up event handlers to get notified about changes to
         * the map here.
         * @param {import("../PluggableMap.js").default} map Map.
         */
        Interaction.prototype.setMap = function (map) {
            this.map_ = map;
        };
        return Interaction;
    }(BaseObject));
    /**
     * @param {import("../View.js").default} view View.
     * @param {import("../coordinate.js").Coordinate} delta Delta.
     * @param {number=} opt_duration Duration.
     */
    function pan(view, delta, opt_duration) {
        var currentCenter = view.getCenterInternal();
        if (currentCenter) {
            var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
            view.animateInternal({
                duration: opt_duration !== undefined ? opt_duration : 250,
                easing: linear,
                center: view.getConstrainedCenter(center),
            });
        }
    }
    /**
     * @param {import("../View.js").default} view View.
     * @param {number} delta Delta from previous zoom level.
     * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate in the user projection.
     * @param {number=} opt_duration Duration.
     */
    function zoomByDelta(view, delta, opt_anchor, opt_duration) {
        var currentZoom = view.getZoom();
        if (currentZoom === undefined) {
            return;
        }
        var newZoom = view.getConstrainedZoom(currentZoom + delta);
        var newResolution = view.getResolutionForZoom(newZoom);
        if (view.getAnimating()) {
            view.cancelAnimations();
        }
        view.animate({
            resolution: newResolution,
            anchor: opt_anchor,
            duration: opt_duration !== undefined ? opt_duration : 250,
            easing: easeOut,
        });
    }

    /**
     * @module ol/proj/Units
     */
    /**
     * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
     * `'us-ft'`.
     * @enum {string}
     */
    var Units = {
        /**
         * Degrees
         * @api
         */
        DEGREES: 'degrees',
        /**
         * Feet
         * @api
         */
        FEET: 'ft',
        /**
         * Meters
         * @api
         */
        METERS: 'm',
        /**
         * Pixels
         * @api
         */
        PIXELS: 'pixels',
        /**
         * Tile Pixels
         * @api
         */
        TILE_PIXELS: 'tile-pixels',
        /**
         * US Feet
         * @api
         */
        USFEET: 'us-ft',
    };
    /**
     * Meters per unit lookup table.
     * @const
     * @type {Object<Units, number>}
     * @api
     */
    var METERS_PER_UNIT$1 = {};
    // use the radius of the Normal sphere
    METERS_PER_UNIT$1[Units.DEGREES] = (2 * Math.PI * 6370997) / 360;
    METERS_PER_UNIT$1[Units.FEET] = 0.3048;
    METERS_PER_UNIT$1[Units.METERS] = 1;
    METERS_PER_UNIT$1[Units.USFEET] = 1200 / 3937;

    /**
     * @module ol/proj/Projection
     */
    /**
     * @typedef {Object} Options
     * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
     * @property {import("./Units.js").default|string} [units] Units. Required unless a
     * proj4 projection is defined for `code`.
     * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
     * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
     * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
     * @property {number} [metersPerUnit] The meters per unit for the SRS.
     * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
     * lookup table.
     * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
     * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
     * Function to determine resolution at a point. The function is called with a
     * `{number}` view resolution and an `{import("../coordinate.js").Coordinate}` as arguments, and returns
     * the `{number}` resolution in projection units at the passed coordinate. If this is `undefined`,
     * the default {@link module:ol/proj#getPointResolution} function will be used.
     */
    /**
     * @classdesc
     * Projection definition class. One of these is created for each projection
     * supported in the application and stored in the {@link module:ol/proj} namespace.
     * You can use these in applications, but this is not required, as API params
     * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
     * code will suffice.
     *
     * You can use {@link module:ol/proj~get} to retrieve the object for a particular
     * projection.
     *
     * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
     * with the following aliases:
     * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
     *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
     *     http://www.opengis.net/gml/srs/epsg.xml#4326,
     *     urn:x-ogc:def:crs:EPSG:4326
     * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
     *     urn:ogc:def:crs:EPSG:6.18:3:3857,
     *     http://www.opengis.net/gml/srs/epsg.xml#3857
     *
     * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
     * be added using `proj4.defs()`. After all required projection definitions are
     * added, call the {@link module:ol/proj/proj4~register} function.
     *
     * @api
     */
    var Projection = /** @class */ (function () {
        /**
         * @param {Options} options Projection options.
         */
        function Projection(options) {
            /**
             * @private
             * @type {string}
             */
            this.code_ = options.code;
            /**
             * Units of projected coordinates. When set to `TILE_PIXELS`, a
             * `this.extent_` and `this.worldExtent_` must be configured properly for each
             * tile.
             * @private
             * @type {import("./Units.js").default}
             */
            this.units_ = /** @type {import("./Units.js").default} */ (options.units);
            /**
             * Validity extent of the projection in projected coordinates. For projections
             * with `TILE_PIXELS` units, this is the extent of the tile in
             * tile pixel space.
             * @private
             * @type {import("../extent.js").Extent}
             */
            this.extent_ = options.extent !== undefined ? options.extent : null;
            /**
             * Extent of the world in EPSG:4326. For projections with
             * `TILE_PIXELS` units, this is the extent of the tile in
             * projected coordinate space.
             * @private
             * @type {import("../extent.js").Extent}
             */
            this.worldExtent_ =
                options.worldExtent !== undefined ? options.worldExtent : null;
            /**
             * @private
             * @type {string}
             */
            this.axisOrientation_ =
                options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
            /**
             * @private
             * @type {boolean}
             */
            this.global_ = options.global !== undefined ? options.global : false;
            /**
             * @private
             * @type {boolean}
             */
            this.canWrapX_ = !!(this.global_ && this.extent_);
            /**
             * @private
             * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
             */
            this.getPointResolutionFunc_ = options.getPointResolution;
            /**
             * @private
             * @type {import("../tilegrid/TileGrid.js").default}
             */
            this.defaultTileGrid_ = null;
            /**
             * @private
             * @type {number|undefined}
             */
            this.metersPerUnit_ = options.metersPerUnit;
        }
        /**
         * @return {boolean} The projection is suitable for wrapping the x-axis
         */
        Projection.prototype.canWrapX = function () {
            return this.canWrapX_;
        };
        /**
         * Get the code for this projection, e.g. 'EPSG:4326'.
         * @return {string} Code.
         * @api
         */
        Projection.prototype.getCode = function () {
            return this.code_;
        };
        /**
         * Get the validity extent for this projection.
         * @return {import("../extent.js").Extent} Extent.
         * @api
         */
        Projection.prototype.getExtent = function () {
            return this.extent_;
        };
        /**
         * Get the units of this projection.
         * @return {import("./Units.js").default} Units.
         * @api
         */
        Projection.prototype.getUnits = function () {
            return this.units_;
        };
        /**
         * Get the amount of meters per unit of this projection.  If the projection is
         * not configured with `metersPerUnit` or a units identifier, the return is
         * `undefined`.
         * @return {number|undefined} Meters.
         * @api
         */
        Projection.prototype.getMetersPerUnit = function () {
            return this.metersPerUnit_ || METERS_PER_UNIT$1[this.units_];
        };
        /**
         * Get the world extent for this projection.
         * @return {import("../extent.js").Extent} Extent.
         * @api
         */
        Projection.prototype.getWorldExtent = function () {
            return this.worldExtent_;
        };
        /**
         * Get the axis orientation of this projection.
         * Example values are:
         * enu - the default easting, northing, elevation.
         * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
         *     or south orientated transverse mercator.
         * wnu - westing, northing, up - some planetary coordinate systems have
         *     "west positive" coordinate systems
         * @return {string} Axis orientation.
         * @api
         */
        Projection.prototype.getAxisOrientation = function () {
            return this.axisOrientation_;
        };
        /**
         * Is this projection a global projection which spans the whole world?
         * @return {boolean} Whether the projection is global.
         * @api
         */
        Projection.prototype.isGlobal = function () {
            return this.global_;
        };
        /**
         * Set if the projection is a global projection which spans the whole world
         * @param {boolean} global Whether the projection is global.
         * @api
         */
        Projection.prototype.setGlobal = function (global) {
            this.global_ = global;
            this.canWrapX_ = !!(global && this.extent_);
        };
        /**
         * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
         */
        Projection.prototype.getDefaultTileGrid = function () {
            return this.defaultTileGrid_;
        };
        /**
         * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
         */
        Projection.prototype.setDefaultTileGrid = function (tileGrid) {
            this.defaultTileGrid_ = tileGrid;
        };
        /**
         * Set the validity extent for this projection.
         * @param {import("../extent.js").Extent} extent Extent.
         * @api
         */
        Projection.prototype.setExtent = function (extent) {
            this.extent_ = extent;
            this.canWrapX_ = !!(this.global_ && extent);
        };
        /**
         * Set the world extent for this projection.
         * @param {import("../extent.js").Extent} worldExtent World extent
         *     [minlon, minlat, maxlon, maxlat].
         * @api
         */
        Projection.prototype.setWorldExtent = function (worldExtent) {
            this.worldExtent_ = worldExtent;
        };
        /**
         * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
         * for this projection.
         * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
         * @api
         */
        Projection.prototype.setGetPointResolution = function (func) {
            this.getPointResolutionFunc_ = func;
        };
        /**
         * Get the custom point resolution function for this projection (if set).
         * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
         * resolution function (if set).
         */
        Projection.prototype.getPointResolutionFunc = function () {
            return this.getPointResolutionFunc_;
        };
        return Projection;
    }());

    /**
     * @module ol/math
     */
    /**
     * Takes a number and clamps it to within the provided bounds.
     * @param {number} value The input number.
     * @param {number} min The minimum value to return.
     * @param {number} max The maximum value to return.
     * @return {number} The input number if it is within bounds, or the nearest
     *     number within the bounds.
     */
    function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }
    /**
     * Return the hyperbolic cosine of a given number. The method will use the
     * native `Math.cosh` function if it is available, otherwise the hyperbolic
     * cosine will be calculated via the reference implementation of the Mozilla
     * developer network.
     *
     * @param {number} x X.
     * @return {number} Hyperbolic cosine of x.
     */
    var cosh = (function () {
        // Wrapped in a iife, to save the overhead of checking for the native
        // implementation on every invocation.
        var cosh;
        if ('cosh' in Math) {
            // The environment supports the native Math.cosh function, use it…
            cosh = Math.cosh;
        }
        else {
            // … else, use the reference implementation of MDN:
            cosh = function (x) {
                var y = /** @type {Math} */ (Math).exp(x);
                return (y + 1 / y) / 2;
            };
        }
        return cosh;
    })();
    /**
     * Return the base 2 logarithm of a given number. The method will use the
     * native `Math.log2` function if it is available, otherwise the base 2
     * logarithm will be calculated via the reference implementation of the
     * Mozilla developer network.
     *
     * @param {number} x X.
     * @return {number} Base 2 logarithm of x.
     */
    var log2 = (function () {
        // Wrapped in a iife, to save the overhead of checking for the native
        // implementation on every invocation.
        var log2;
        if ('log2' in Math) {
            // The environment supports the native Math.log2 function, use it…
            log2 = Math.log2;
        }
        else {
            // … else, use the reference implementation of MDN:
            log2 = function (x) {
                return Math.log(x) * Math.LOG2E;
            };
        }
        return log2;
    })();
    /**
     * Returns the square of the closest distance between the point (x, y) and the
     * line segment (x1, y1) to (x2, y2).
     * @param {number} x X.
     * @param {number} y Y.
     * @param {number} x1 X1.
     * @param {number} y1 Y1.
     * @param {number} x2 X2.
     * @param {number} y2 Y2.
     * @return {number} Squared distance.
     */
    function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
        var dx = x2 - x1;
        var dy = y2 - y1;
        if (dx !== 0 || dy !== 0) {
            var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
            if (t > 1) {
                x1 = x2;
                y1 = y2;
            }
            else if (t > 0) {
                x1 += dx * t;
                y1 += dy * t;
            }
        }
        return squaredDistance(x, y, x1, y1);
    }
    /**
     * Returns the square of the distance between the points (x1, y1) and (x2, y2).
     * @param {number} x1 X1.
     * @param {number} y1 Y1.
     * @param {number} x2 X2.
     * @param {number} y2 Y2.
     * @return {number} Squared distance.
     */
    function squaredDistance(x1, y1, x2, y2) {
        var dx = x2 - x1;
        var dy = y2 - y1;
        return dx * dx + dy * dy;
    }
    /**
     * Solves system of linear equations using Gaussian elimination method.
     *
     * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
     *                                     in row-major order.
     * @return {Array<number>} The resulting vector.
     */
    function solveLinearSystem(mat) {
        var n = mat.length;
        for (var i = 0; i < n; i++) {
            // Find max in the i-th column (ignoring i - 1 first rows)
            var maxRow = i;
            var maxEl = Math.abs(mat[i][i]);
            for (var r = i + 1; r < n; r++) {
                var absValue = Math.abs(mat[r][i]);
                if (absValue > maxEl) {
                    maxEl = absValue;
                    maxRow = r;
                }
            }
            if (maxEl === 0) {
                return null; // matrix is singular
            }
            // Swap max row with i-th (current) row
            var tmp = mat[maxRow];
            mat[maxRow] = mat[i];
            mat[i] = tmp;
            // Subtract the i-th row to make all the remaining rows 0 in the i-th column
            for (var j = i + 1; j < n; j++) {
                var coef = -mat[j][i] / mat[i][i];
                for (var k = i; k < n + 1; k++) {
                    if (i == k) {
                        mat[j][k] = 0;
                    }
                    else {
                        mat[j][k] += coef * mat[i][k];
                    }
                }
            }
        }
        // Solve Ax=b for upper triangular matrix A (mat)
        var x = new Array(n);
        for (var l = n - 1; l >= 0; l--) {
            x[l] = mat[l][n] / mat[l][l];
            for (var m = l - 1; m >= 0; m--) {
                mat[m][n] -= mat[m][l] * x[l];
            }
        }
        return x;
    }
    /**
     * Converts degrees to radians.
     *
     * @param {number} angleInDegrees Angle in degrees.
     * @return {number} Angle in radians.
     */
    function toRadians(angleInDegrees) {
        return (angleInDegrees * Math.PI) / 180;
    }
    /**
     * Returns the modulo of a / b, depending on the sign of b.
     *
     * @param {number} a Dividend.
     * @param {number} b Divisor.
     * @return {number} Modulo.
     */
    function modulo(a, b) {
        var r = a % b;
        return r * b < 0 ? r + b : r;
    }
    /**
     * Calculates the linearly interpolated value of x between a and b.
     *
     * @param {number} a Number
     * @param {number} b Number
     * @param {number} x Value to be interpolated.
     * @return {number} Interpolated value.
     */
    function lerp(a, b, x) {
        return a + x * (b - a);
    }

    var __extends$1h = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * Radius of WGS84 sphere
     *
     * @const
     * @type {number}
     */
    var RADIUS$1 = 6378137;
    /**
     * @const
     * @type {number}
     */
    var HALF_SIZE = Math.PI * RADIUS$1;
    /**
     * @const
     * @type {import("../extent.js").Extent}
     */
    var EXTENT$1 = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
    /**
     * @const
     * @type {import("../extent.js").Extent}
     */
    var WORLD_EXTENT = [-180, -85, 180, 85];
    /**
     * Maximum safe value in y direction
     * @const
     * @type {number}
     */
    var MAX_SAFE_Y = RADIUS$1 * Math.log(Math.tan(Math.PI / 2));
    /**
     * @classdesc
     * Projection object for web/spherical Mercator (EPSG:3857).
     */
    var EPSG3857Projection = /** @class */ (function (_super) {
        __extends$1h(EPSG3857Projection, _super);
        /**
         * @param {string} code Code.
         */
        function EPSG3857Projection(code) {
            return _super.call(this, {
                code: code,
                units: Units.METERS,
                extent: EXTENT$1,
                global: true,
                worldExtent: WORLD_EXTENT,
                getPointResolution: function (resolution, point) {
                    return resolution / cosh(point[1] / RADIUS$1);
                },
            }) || this;
        }
        return EPSG3857Projection;
    }(Projection));
    /**
     * Projections equal to EPSG:3857.
     *
     * @const
     * @type {Array<import("./Projection.js").default>}
     */
    var PROJECTIONS$1 = [
        new EPSG3857Projection('EPSG:3857'),
        new EPSG3857Projection('EPSG:102100'),
        new EPSG3857Projection('EPSG:102113'),
        new EPSG3857Projection('EPSG:900913'),
        new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),
    ];
    /**
     * Transformation from EPSG:4326 to EPSG:3857.
     *
     * @param {Array<number>} input Input array of coordinate values.
     * @param {Array<number>=} opt_output Output array of coordinate values.
     * @param {number=} opt_dimension Dimension (default is `2`).
     * @return {Array<number>} Output array of coordinate values.
     */
    function fromEPSG4326(input, opt_output, opt_dimension) {
        var length = input.length;
        var dimension = opt_dimension > 1 ? opt_dimension : 2;
        var output = opt_output;
        if (output === undefined) {
            if (dimension > 2) {
                // preserve values beyond second dimension
                output = input.slice();
            }
            else {
                output = new Array(length);
            }
        }
        for (var i = 0; i < length; i += dimension) {
            output[i] = (HALF_SIZE * input[i]) / 180;
            var y = RADIUS$1 * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));
            if (y > MAX_SAFE_Y) {
                y = MAX_SAFE_Y;
            }
            else if (y < -MAX_SAFE_Y) {
                y = -MAX_SAFE_Y;
            }
            output[i + 1] = y;
        }
        return output;
    }
    /**
     * Transformation from EPSG:3857 to EPSG:4326.
     *
     * @param {Array<number>} input Input array of coordinate values.
     * @param {Array<number>=} opt_output Output array of coordinate values.
     * @param {number=} opt_dimension Dimension (default is `2`).
     * @return {Array<number>} Output array of coordinate values.
     */
    function toEPSG4326(input, opt_output, opt_dimension) {
        var length = input.length;
        var dimension = opt_dimension > 1 ? opt_dimension : 2;
        var output = opt_output;
        if (output === undefined) {
            if (dimension > 2) {
                // preserve values beyond second dimension
                output = input.slice();
            }
            else {
                output = new Array(length);
            }
        }
        for (var i = 0; i < length; i += dimension) {
            output[i] = (180 * input[i]) / HALF_SIZE;
            output[i + 1] =
                (360 * Math.atan(Math.exp(input[i + 1] / RADIUS$1))) / Math.PI - 90;
        }
        return output;
    }

    var __extends$1g = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * Semi-major radius of the WGS84 ellipsoid.
     *
     * @const
     * @type {number}
     */
    var RADIUS = 6378137;
    /**
     * Extent of the EPSG:4326 projection which is the whole world.
     *
     * @const
     * @type {import("../extent.js").Extent}
     */
    var EXTENT = [-180, -90, 180, 90];
    /**
     * @const
     * @type {number}
     */
    var METERS_PER_UNIT = (Math.PI * RADIUS) / 180;
    /**
     * @classdesc
     * Projection object for WGS84 geographic coordinates (EPSG:4326).
     *
     * Note that OpenLayers does not strictly comply with the EPSG definition.
     * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
     * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
     */
    var EPSG4326Projection = /** @class */ (function (_super) {
        __extends$1g(EPSG4326Projection, _super);
        /**
         * @param {string} code Code.
         * @param {string=} opt_axisOrientation Axis orientation.
         */
        function EPSG4326Projection(code, opt_axisOrientation) {
            return _super.call(this, {
                code: code,
                units: Units.DEGREES,
                extent: EXTENT,
                axisOrientation: opt_axisOrientation,
                global: true,
                metersPerUnit: METERS_PER_UNIT,
                worldExtent: EXTENT,
            }) || this;
        }
        return EPSG4326Projection;
    }(Projection));
    /**
     * Projections equal to EPSG:4326.
     *
     * @const
     * @type {Array<import("./Projection.js").default>}
     */
    var PROJECTIONS = [
        new EPSG4326Projection('CRS:84'),
        new EPSG4326Projection('EPSG:4326', 'neu'),
        new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
        new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
        new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
    ];

    /**
     * @module ol/proj/projections
     */
    /**
     * @type {Object<string, import("./Projection.js").default>}
     */
    var cache = {};
    /**
     * Get a cached projection by code.
     * @param {string} code The code for the projection.
     * @return {import("./Projection.js").default} The projection (if cached).
     */
    function get$3(code) {
        return (cache[code] ||
            cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] ||
            null);
    }
    /**
     * Add a projection to the cache.
     * @param {string} code The projection code.
     * @param {import("./Projection.js").default} projection The projection to cache.
     */
    function add$2(code, projection) {
        cache[code] = projection;
    }

    /**
     * @module ol/proj/transforms
     */
    /**
     * @private
     * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
     */
    var transforms = {};
    /**
     * Registers a conversion function to convert coordinates from the source
     * projection to the destination projection.
     *
     * @param {import("./Projection.js").default} source Source.
     * @param {import("./Projection.js").default} destination Destination.
     * @param {import("../proj.js").TransformFunction} transformFn Transform.
     */
    function add$1(source, destination, transformFn) {
        var sourceCode = source.getCode();
        var destinationCode = destination.getCode();
        if (!(sourceCode in transforms)) {
            transforms[sourceCode] = {};
        }
        transforms[sourceCode][destinationCode] = transformFn;
    }
    /**
     * Get a transform given a source code and a destination code.
     * @param {string} sourceCode The code for the source projection.
     * @param {string} destinationCode The code for the destination projection.
     * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
     */
    function get$2(sourceCode, destinationCode) {
        var transform;
        if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
            transform = transforms[sourceCode][destinationCode];
        }
        return transform;
    }

    /**
     * @module ol/extent/Corner
     */
    /**
     * Extent corner.
     * @enum {string}
     */
    var Corner = {
        BOTTOM_LEFT: 'bottom-left',
        BOTTOM_RIGHT: 'bottom-right',
        TOP_LEFT: 'top-left',
        TOP_RIGHT: 'top-right',
    };

    /**
     * @module ol/extent/Relationship
     */
    /**
     * Relationship to an extent.
     * @enum {number}
     */
    var Relationship = {
        UNKNOWN: 0,
        INTERSECTING: 1,
        ABOVE: 2,
        RIGHT: 4,
        BELOW: 8,
        LEFT: 16,
    };

    var __extends$1f = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * Error object thrown when an assertion failed. This is an ECMA-262 Error,
     * extended with a `code` property.
     * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
     */
    var AssertionError = /** @class */ (function (_super) {
        __extends$1f(AssertionError, _super);
        /**
         * @param {number} code Error code.
         */
        function AssertionError(code) {
            var _this = this;
            var path = 'v' + VERSION.split('-')[0];
            var message = 'Assertion failed. See https://openlayers.org/en/' +
                path +
                '/doc/errors/#' +
                code +
                ' for details.';
            _this = _super.call(this, message) || this;
            /**
             * Error code. The meaning of the code can be found on
             * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
             * the version found in the OpenLayers script's header comment if a version
             * other than the latest is used).
             * @type {number}
             * @api
             */
            _this.code = code;
            /**
             * @type {string}
             */
            _this.name = 'AssertionError';
            // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
            _this.message = message;
            return _this;
        }
        return AssertionError;
    }(Error));

    /**
     * @module ol/asserts
     */
    /**
     * @param {*} assertion Assertion we expected to be truthy.
     * @param {number} errorCode Error code.
     */
    function assert(assertion, errorCode) {
        if (!assertion) {
            throw new AssertionError(errorCode);
        }
    }

    /**
     * @module ol/extent
     */
    /**
     * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
     * @typedef {Array<number>} Extent
     * @api
     */
    /**
     * Build an extent that includes all given coordinates.
     *
     * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
     * @return {Extent} Bounding extent.
     * @api
     */
    function boundingExtent(coordinates) {
        var extent = createEmpty();
        for (var i = 0, ii = coordinates.length; i < ii; ++i) {
            extendCoordinate(extent, coordinates[i]);
        }
        return extent;
    }
    /**
     * @param {Array<number>} xs Xs.
     * @param {Array<number>} ys Ys.
     * @param {Extent=} opt_extent Destination extent.
     * @private
     * @return {Extent} Extent.
     */
    function _boundingExtentXYs(xs, ys, opt_extent) {
        var minX = Math.min.apply(null, xs);
        var minY = Math.min.apply(null, ys);
        var maxX = Math.max.apply(null, xs);
        var maxY = Math.max.apply(null, ys);
        return createOrUpdate$2(minX, minY, maxX, maxY, opt_extent);
    }
    /**
     * Return extent increased by the provided value.
     * @param {Extent} extent Extent.
     * @param {number} value The amount by which the extent should be buffered.
     * @param {Extent=} opt_extent Extent.
     * @return {Extent} Extent.
     * @api
     */
    function buffer(extent, value, opt_extent) {
        if (opt_extent) {
            opt_extent[0] = extent[0] - value;
            opt_extent[1] = extent[1] - value;
            opt_extent[2] = extent[2] + value;
            opt_extent[3] = extent[3] + value;
            return opt_extent;
        }
        else {
            return [
                extent[0] - value,
                extent[1] - value,
                extent[2] + value,
                extent[3] + value,
            ];
        }
    }
    /**
     * Creates a clone of an extent.
     *
     * @param {Extent} extent Extent to clone.
     * @param {Extent=} opt_extent Extent.
     * @return {Extent} The clone.
     */
    function clone(extent, opt_extent) {
        if (opt_extent) {
            opt_extent[0] = extent[0];
            opt_extent[1] = extent[1];
            opt_extent[2] = extent[2];
            opt_extent[3] = extent[3];
            return opt_extent;
        }
        else {
            return extent.slice();
        }
    }
    /**
     * @param {Extent} extent Extent.
     * @param {number} x X.
     * @param {number} y Y.
     * @return {number} Closest squared distance.
     */
    function closestSquaredDistanceXY(extent, x, y) {
        var dx, dy;
        if (x < extent[0]) {
            dx = extent[0] - x;
        }
        else if (extent[2] < x) {
            dx = x - extent[2];
        }
        else {
            dx = 0;
        }
        if (y < extent[1]) {
            dy = extent[1] - y;
        }
        else if (extent[3] < y) {
            dy = y - extent[3];
        }
        else {
            dy = 0;
        }
        return dx * dx + dy * dy;
    }
    /**
     * Check if the passed coordinate is contained or on the edge of the extent.
     *
     * @param {Extent} extent Extent.
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} The coordinate is contained in the extent.
     * @api
     */
    function containsCoordinate(extent, coordinate) {
        return containsXY(extent, coordinate[0], coordinate[1]);
    }
    /**
     * Check if one extent contains another.
     *
     * An extent is deemed contained if it lies completely within the other extent,
     * including if they share one or more edges.
     *
     * @param {Extent} extent1 Extent 1.
     * @param {Extent} extent2 Extent 2.
     * @return {boolean} The second extent is contained by or on the edge of the
     *     first.
     * @api
     */
    function containsExtent(extent1, extent2) {
        return (extent1[0] <= extent2[0] &&
            extent2[2] <= extent1[2] &&
            extent1[1] <= extent2[1] &&
            extent2[3] <= extent1[3]);
    }
    /**
     * Check if the passed coordinate is contained or on the edge of the extent.
     *
     * @param {Extent} extent Extent.
     * @param {number} x X coordinate.
     * @param {number} y Y coordinate.
     * @return {boolean} The x, y values are contained in the extent.
     * @api
     */
    function containsXY(extent, x, y) {
        return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
    }
    /**
     * Get the relationship between a coordinate and extent.
     * @param {Extent} extent The extent.
     * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
     * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
     *     import("./extent/Relationship.js").Relationship).
     */
    function coordinateRelationship(extent, coordinate) {
        var minX = extent[0];
        var minY = extent[1];
        var maxX = extent[2];
        var maxY = extent[3];
        var x = coordinate[0];
        var y = coordinate[1];
        var relationship = Relationship.UNKNOWN;
        if (x < minX) {
            relationship = relationship | Relationship.LEFT;
        }
        else if (x > maxX) {
            relationship = relationship | Relationship.RIGHT;
        }
        if (y < minY) {
            relationship = relationship | Relationship.BELOW;
        }
        else if (y > maxY) {
            relationship = relationship | Relationship.ABOVE;
        }
        if (relationship === Relationship.UNKNOWN) {
            relationship = Relationship.INTERSECTING;
        }
        return relationship;
    }
    /**
     * Create an empty extent.
     * @return {Extent} Empty extent.
     * @api
     */
    function createEmpty() {
        return [Infinity, Infinity, -Infinity, -Infinity];
    }
    /**
     * Create a new extent or update the provided extent.
     * @param {number} minX Minimum X.
     * @param {number} minY Minimum Y.
     * @param {number} maxX Maximum X.
     * @param {number} maxY Maximum Y.
     * @param {Extent=} opt_extent Destination extent.
     * @return {Extent} Extent.
     */
    function createOrUpdate$2(minX, minY, maxX, maxY, opt_extent) {
        if (opt_extent) {
            opt_extent[0] = minX;
            opt_extent[1] = minY;
            opt_extent[2] = maxX;
            opt_extent[3] = maxY;
            return opt_extent;
        }
        else {
            return [minX, minY, maxX, maxY];
        }
    }
    /**
     * Create a new empty extent or make the provided one empty.
     * @param {Extent=} opt_extent Extent.
     * @return {Extent} Extent.
     */
    function createOrUpdateEmpty(opt_extent) {
        return createOrUpdate$2(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
    }
    /**
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {Extent=} opt_extent Extent.
     * @return {Extent} Extent.
     */
    function createOrUpdateFromCoordinate(coordinate, opt_extent) {
        var x = coordinate[0];
        var y = coordinate[1];
        return createOrUpdate$2(x, y, x, y, opt_extent);
    }
    /**
     * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {Extent=} opt_extent Extent.
     * @return {Extent} Extent.
     */
    function createOrUpdateFromCoordinates(coordinates, opt_extent) {
        var extent = createOrUpdateEmpty(opt_extent);
        return extendCoordinates(extent, coordinates);
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {Extent=} opt_extent Extent.
     * @return {Extent} Extent.
     */
    function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
        var extent = createOrUpdateEmpty(opt_extent);
        return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
    }
    /**
     * Determine if two extents are equivalent.
     * @param {Extent} extent1 Extent 1.
     * @param {Extent} extent2 Extent 2.
     * @return {boolean} The two extents are equivalent.
     * @api
     */
    function equals$1(extent1, extent2) {
        return (extent1[0] == extent2[0] &&
            extent1[2] == extent2[2] &&
            extent1[1] == extent2[1] &&
            extent1[3] == extent2[3]);
    }
    /**
     * Modify an extent to include another extent.
     * @param {Extent} extent1 The extent to be modified.
     * @param {Extent} extent2 The extent that will be included in the first.
     * @return {Extent} A reference to the first (extended) extent.
     * @api
     */
    function extend$1(extent1, extent2) {
        if (extent2[0] < extent1[0]) {
            extent1[0] = extent2[0];
        }
        if (extent2[2] > extent1[2]) {
            extent1[2] = extent2[2];
        }
        if (extent2[1] < extent1[1]) {
            extent1[1] = extent2[1];
        }
        if (extent2[3] > extent1[3]) {
            extent1[3] = extent2[3];
        }
        return extent1;
    }
    /**
     * @param {Extent} extent Extent.
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     */
    function extendCoordinate(extent, coordinate) {
        if (coordinate[0] < extent[0]) {
            extent[0] = coordinate[0];
        }
        if (coordinate[0] > extent[2]) {
            extent[2] = coordinate[0];
        }
        if (coordinate[1] < extent[1]) {
            extent[1] = coordinate[1];
        }
        if (coordinate[1] > extent[3]) {
            extent[3] = coordinate[1];
        }
    }
    /**
     * @param {Extent} extent Extent.
     * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
     * @return {Extent} Extent.
     */
    function extendCoordinates(extent, coordinates) {
        for (var i = 0, ii = coordinates.length; i < ii; ++i) {
            extendCoordinate(extent, coordinates[i]);
        }
        return extent;
    }
    /**
     * @param {Extent} extent Extent.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @return {Extent} Extent.
     */
    function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
        for (; offset < end; offset += stride) {
            extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
        }
        return extent;
    }
    /**
     * @param {Extent} extent Extent.
     * @param {number} x X.
     * @param {number} y Y.
     */
    function extendXY(extent, x, y) {
        extent[0] = Math.min(extent[0], x);
        extent[1] = Math.min(extent[1], y);
        extent[2] = Math.max(extent[2], x);
        extent[3] = Math.max(extent[3], y);
    }
    /**
     * This function calls `callback` for each corner of the extent. If the
     * callback returns a truthy value the function returns that value
     * immediately. Otherwise the function returns `false`.
     * @param {Extent} extent Extent.
     * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
     * @return {S|boolean} Value.
     * @template S
     */
    function forEachCorner(extent, callback) {
        var val;
        val = callback(getBottomLeft(extent));
        if (val) {
            return val;
        }
        val = callback(getBottomRight(extent));
        if (val) {
            return val;
        }
        val = callback(getTopRight(extent));
        if (val) {
            return val;
        }
        val = callback(getTopLeft(extent));
        if (val) {
            return val;
        }
        return false;
    }
    /**
     * Get the size of an extent.
     * @param {Extent} extent Extent.
     * @return {number} Area.
     * @api
     */
    function getArea(extent) {
        var area = 0;
        if (!isEmpty(extent)) {
            area = getWidth(extent) * getHeight(extent);
        }
        return area;
    }
    /**
     * Get the bottom left coordinate of an extent.
     * @param {Extent} extent Extent.
     * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
     * @api
     */
    function getBottomLeft(extent) {
        return [extent[0], extent[1]];
    }
    /**
     * Get the bottom right coordinate of an extent.
     * @param {Extent} extent Extent.
     * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
     * @api
     */
    function getBottomRight(extent) {
        return [extent[2], extent[1]];
    }
    /**
     * Get the center coordinate of an extent.
     * @param {Extent} extent Extent.
     * @return {import("./coordinate.js").Coordinate} Center.
     * @api
     */
    function getCenter(extent) {
        return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
    }
    /**
     * Get a corner coordinate of an extent.
     * @param {Extent} extent Extent.
     * @param {import("./extent/Corner.js").default} corner Corner.
     * @return {import("./coordinate.js").Coordinate} Corner coordinate.
     */
    function getCorner(extent, corner) {
        var coordinate;
        if (corner === Corner.BOTTOM_LEFT) {
            coordinate = getBottomLeft(extent);
        }
        else if (corner === Corner.BOTTOM_RIGHT) {
            coordinate = getBottomRight(extent);
        }
        else if (corner === Corner.TOP_LEFT) {
            coordinate = getTopLeft(extent);
        }
        else if (corner === Corner.TOP_RIGHT) {
            coordinate = getTopRight(extent);
        }
        else {
            assert(false, 13); // Invalid corner
        }
        return coordinate;
    }
    /**
     * @param {import("./coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {import("./size.js").Size} size Size.
     * @param {Extent=} opt_extent Destination extent.
     * @return {Extent} Extent.
     */
    function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
        var dx = (resolution * size[0]) / 2;
        var dy = (resolution * size[1]) / 2;
        var cosRotation = Math.cos(rotation);
        var sinRotation = Math.sin(rotation);
        var xCos = dx * cosRotation;
        var xSin = dx * sinRotation;
        var yCos = dy * cosRotation;
        var ySin = dy * sinRotation;
        var x = center[0];
        var y = center[1];
        var x0 = x - xCos + ySin;
        var x1 = x - xCos - ySin;
        var x2 = x + xCos - ySin;
        var x3 = x + xCos + ySin;
        var y0 = y - xSin - yCos;
        var y1 = y - xSin + yCos;
        var y2 = y + xSin + yCos;
        var y3 = y + xSin - yCos;
        return createOrUpdate$2(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
    }
    /**
     * Get the height of an extent.
     * @param {Extent} extent Extent.
     * @return {number} Height.
     * @api
     */
    function getHeight(extent) {
        return extent[3] - extent[1];
    }
    /**
     * Get the intersection of two extents.
     * @param {Extent} extent1 Extent 1.
     * @param {Extent} extent2 Extent 2.
     * @param {Extent=} opt_extent Optional extent to populate with intersection.
     * @return {Extent} Intersecting extent.
     * @api
     */
    function getIntersection(extent1, extent2, opt_extent) {
        var intersection = opt_extent ? opt_extent : createEmpty();
        if (intersects(extent1, extent2)) {
            if (extent1[0] > extent2[0]) {
                intersection[0] = extent1[0];
            }
            else {
                intersection[0] = extent2[0];
            }
            if (extent1[1] > extent2[1]) {
                intersection[1] = extent1[1];
            }
            else {
                intersection[1] = extent2[1];
            }
            if (extent1[2] < extent2[2]) {
                intersection[2] = extent1[2];
            }
            else {
                intersection[2] = extent2[2];
            }
            if (extent1[3] < extent2[3]) {
                intersection[3] = extent1[3];
            }
            else {
                intersection[3] = extent2[3];
            }
        }
        else {
            createOrUpdateEmpty(intersection);
        }
        return intersection;
    }
    /**
     * Get the top left coordinate of an extent.
     * @param {Extent} extent Extent.
     * @return {import("./coordinate.js").Coordinate} Top left coordinate.
     * @api
     */
    function getTopLeft(extent) {
        return [extent[0], extent[3]];
    }
    /**
     * Get the top right coordinate of an extent.
     * @param {Extent} extent Extent.
     * @return {import("./coordinate.js").Coordinate} Top right coordinate.
     * @api
     */
    function getTopRight(extent) {
        return [extent[2], extent[3]];
    }
    /**
     * Get the width of an extent.
     * @param {Extent} extent Extent.
     * @return {number} Width.
     * @api
     */
    function getWidth(extent) {
        return extent[2] - extent[0];
    }
    /**
     * Determine if one extent intersects another.
     * @param {Extent} extent1 Extent 1.
     * @param {Extent} extent2 Extent.
     * @return {boolean} The two extents intersect.
     * @api
     */
    function intersects(extent1, extent2) {
        return (extent1[0] <= extent2[2] &&
            extent1[2] >= extent2[0] &&
            extent1[1] <= extent2[3] &&
            extent1[3] >= extent2[1]);
    }
    /**
     * Determine if an extent is empty.
     * @param {Extent} extent Extent.
     * @return {boolean} Is empty.
     * @api
     */
    function isEmpty(extent) {
        return extent[2] < extent[0] || extent[3] < extent[1];
    }
    /**
     * @param {Extent} extent Extent.
     * @param {Extent=} opt_extent Extent.
     * @return {Extent} Extent.
     */
    function returnOrUpdate(extent, opt_extent) {
        if (opt_extent) {
            opt_extent[0] = extent[0];
            opt_extent[1] = extent[1];
            opt_extent[2] = extent[2];
            opt_extent[3] = extent[3];
            return opt_extent;
        }
        else {
            return extent;
        }
    }
    /**
     * @param {Extent} extent Extent.
     * @param {number} value Value.
     */
    function scaleFromCenter(extent, value) {
        var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
        var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
        extent[0] -= deltaX;
        extent[2] += deltaX;
        extent[1] -= deltaY;
        extent[3] += deltaY;
    }
    /**
     * Determine if the segment between two coordinates intersects (crosses,
     * touches, or is contained by) the provided extent.
     * @param {Extent} extent The extent.
     * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
     * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
     * @return {boolean} The segment intersects the extent.
     */
    function intersectsSegment(extent, start, end) {
        var intersects = false;
        var startRel = coordinateRelationship(extent, start);
        var endRel = coordinateRelationship(extent, end);
        if (startRel === Relationship.INTERSECTING ||
            endRel === Relationship.INTERSECTING) {
            intersects = true;
        }
        else {
            var minX = extent[0];
            var minY = extent[1];
            var maxX = extent[2];
            var maxY = extent[3];
            var startX = start[0];
            var startY = start[1];
            var endX = end[0];
            var endY = end[1];
            var slope = (endY - startY) / (endX - startX);
            var x = void 0, y = void 0;
            if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {
                // potentially intersects top
                x = endX - (endY - maxY) / slope;
                intersects = x >= minX && x <= maxX;
            }
            if (!intersects &&
                !!(endRel & Relationship.RIGHT) &&
                !(startRel & Relationship.RIGHT)) {
                // potentially intersects right
                y = endY - (endX - maxX) * slope;
                intersects = y >= minY && y <= maxY;
            }
            if (!intersects &&
                !!(endRel & Relationship.BELOW) &&
                !(startRel & Relationship.BELOW)) {
                // potentially intersects bottom
                x = endX - (endY - minY) / slope;
                intersects = x >= minX && x <= maxX;
            }
            if (!intersects &&
                !!(endRel & Relationship.LEFT) &&
                !(startRel & Relationship.LEFT)) {
                // potentially intersects left
                y = endY - (endX - minX) * slope;
                intersects = y >= minY && y <= maxY;
            }
        }
        return intersects;
    }
    /**
     * Apply a transform function to the extent.
     * @param {Extent} extent Extent.
     * @param {import("./proj.js").TransformFunction} transformFn Transform function.
     * Called with `[minX, minY, maxX, maxY]` extent coordinates.
     * @param {Extent=} opt_extent Destination extent.
     * @param {number=} opt_stops Number of stops per side used for the transform.
     * By default only the corners are used.
     * @return {Extent} Extent.
     * @api
     */
    function applyTransform(extent, transformFn, opt_extent, opt_stops) {
        var coordinates = [];
        if (opt_stops > 1) {
            var width = extent[2] - extent[0];
            var height = extent[3] - extent[1];
            for (var i = 0; i < opt_stops; ++i) {
                coordinates.push(extent[0] + (width * i) / opt_stops, extent[1], extent[2], extent[1] + (height * i) / opt_stops, extent[2] - (width * i) / opt_stops, extent[3], extent[0], extent[3] - (height * i) / opt_stops);
            }
        }
        else {
            coordinates = [
                extent[0],
                extent[1],
                extent[2],
                extent[1],
                extent[2],
                extent[3],
                extent[0],
                extent[3],
            ];
        }
        transformFn(coordinates, coordinates, 2);
        var xs = [];
        var ys = [];
        for (var i = 0, l = coordinates.length; i < l; i += 2) {
            xs.push(coordinates[i]);
            ys.push(coordinates[i + 1]);
        }
        return _boundingExtentXYs(xs, ys, opt_extent);
    }
    /**
     * Modifies the provided extent in-place to be within the real world
     * extent.
     *
     * @param {Extent} extent Extent.
     * @param {import("./proj/Projection.js").default} projection Projection
     * @return {Extent} The extent within the real world extent.
     */
    function wrapX$2(extent, projection) {
        var projectionExtent = projection.getExtent();
        var center = getCenter(extent);
        if (projection.canWrapX() &&
            (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
            var worldWidth = getWidth(projectionExtent);
            var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
            var offset = worldsAway * worldWidth;
            extent[0] -= offset;
            extent[2] -= offset;
        }
        return extent;
    }

    /**
     * @module ol/geom/GeometryType
     */
    /**
     * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
     * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
     * `'GeometryCollection'`, `'Circle'`.
     * @enum {string}
     */
    var GeometryType = {
        POINT: 'Point',
        LINE_STRING: 'LineString',
        LINEAR_RING: 'LinearRing',
        POLYGON: 'Polygon',
        MULTI_POINT: 'MultiPoint',
        MULTI_LINE_STRING: 'MultiLineString',
        MULTI_POLYGON: 'MultiPolygon',
        GEOMETRY_COLLECTION: 'GeometryCollection',
        CIRCLE: 'Circle',
    };

    /**
     * @module ol/sphere
     */
    /**
     * Object literal with options for the {@link getLength} or {@link getArea}
     * functions.
     * @typedef {Object} SphereMetricOptions
     * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
     * Projection of the  geometry.  By default, the geometry is assumed to be in
     * Web Mercator.
     * @property {number} [radius=6371008.8] Sphere radius.  By default, the
     * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
     * for the WGS84 ellipsoid is used.
     */
    /**
     * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
     * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
     * @type {number}
     */
    var DEFAULT_RADIUS = 6371008.8;
    /**
     * Get the great circle distance (in meters) between two geographic coordinates.
     * @param {Array} c1 Starting coordinate.
     * @param {Array} c2 Ending coordinate.
     * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
     *     mean radius using the WGS84 ellipsoid.
     * @return {number} The great circle distance between the points (in meters).
     * @api
     */
    function getDistance(c1, c2, opt_radius) {
        var radius = opt_radius || DEFAULT_RADIUS;
        var lat1 = toRadians(c1[1]);
        var lat2 = toRadians(c2[1]);
        var deltaLatBy2 = (lat2 - lat1) / 2;
        var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
        var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
            Math.sin(deltaLonBy2) *
                Math.sin(deltaLonBy2) *
                Math.cos(lat1) *
                Math.cos(lat2);
        return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    /**
     * @module ol/coordinate
     */
    /**
     * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
     * @typedef {Array<number>} Coordinate
     * @api
     */
    /**
     * A function that takes a {@link module:ol/coordinate~Coordinate} and
     * transforms it into a `{string}`.
     *
     * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
     * @api
     */
    /**
     * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
     * by the function.
     *
     * Example:
     *
     *     import {add} from 'ol/coordinate';
     *
     *     var coord = [7.85, 47.983333];
     *     add(coord, [-2, 4]);
     *     // coord is now [5.85, 51.983333]
     *
     * @param {Coordinate} coordinate Coordinate.
     * @param {Coordinate} delta Delta.
     * @return {Coordinate} The input coordinate adjusted by
     * the given delta.
     * @api
     */
    function add(coordinate, delta) {
        coordinate[0] += +delta[0];
        coordinate[1] += +delta[1];
        return coordinate;
    }
    /**
     * @param {Coordinate} coordinate1 First coordinate.
     * @param {Coordinate} coordinate2 Second coordinate.
     * @return {boolean} The two coordinates are equal.
     */
    function equals(coordinate1, coordinate2) {
        var equals = true;
        for (var i = coordinate1.length - 1; i >= 0; --i) {
            if (coordinate1[i] != coordinate2[i]) {
                equals = false;
                break;
            }
        }
        return equals;
    }
    /**
     * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
     * returned by the function.
     *
     * Example:
     *
     *     import {rotate} from 'ol/coordinate';
     *
     *     var coord = [7.85, 47.983333];
     *     var rotateRadians = Math.PI / 2; // 90 degrees
     *     rotate(coord, rotateRadians);
     *     // coord is now [-47.983333, 7.85]
     *
     * @param {Coordinate} coordinate Coordinate.
     * @param {number} angle Angle in radian.
     * @return {Coordinate} Coordinate.
     * @api
     */
    function rotate$1(coordinate, angle) {
        var cosAngle = Math.cos(angle);
        var sinAngle = Math.sin(angle);
        var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
        var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
        coordinate[0] = x;
        coordinate[1] = y;
        return coordinate;
    }
    /**
     * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
     * by the function.
     *
     * Example:
     *
     *     import {scale as scaleCoordinate} from 'ol/coordinate';
     *
     *     var coord = [7.85, 47.983333];
     *     var scale = 1.2;
     *     scaleCoordinate(coord, scale);
     *     // coord is now [9.42, 57.5799996]
     *
     * @param {Coordinate} coordinate Coordinate.
     * @param {number} scale Scale factor.
     * @return {Coordinate} Coordinate.
     */
    function scale$2(coordinate, scale) {
        coordinate[0] *= scale;
        coordinate[1] *= scale;
        return coordinate;
    }
    /**
     * Modifies the provided coordinate in-place to be within the real world
     * extent. The lower projection extent boundary is inclusive, the upper one
     * exclusive.
     *
     * @param {Coordinate} coordinate Coordinate.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {Coordinate} The coordinate within the real world extent.
     */
    function wrapX$1(coordinate, projection) {
        if (projection.canWrapX()) {
            var worldWidth = getWidth(projection.getExtent());
            var worldsAway = getWorldsAway(coordinate, projection, worldWidth);
            if (worldsAway) {
                coordinate[0] -= worldsAway * worldWidth;
            }
        }
        return coordinate;
    }
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @param {number=} opt_sourceExtentWidth Width of the source extent.
     * @return {number} Offset in world widths.
     */
    function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
        var projectionExtent = projection.getExtent();
        var worldsAway = 0;
        if (projection.canWrapX() &&
            (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
            var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);
            worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
        }
        return worldsAway;
    }

    /**
     * @module ol/proj
     */
    /**
     * @param {Array<number>} input Input coordinate array.
     * @param {Array<number>=} opt_output Output array of coordinate values.
     * @param {number=} opt_dimension Dimension.
     * @return {Array<number>} Output coordinate array (new array, same coordinate
     *     values).
     */
    function cloneTransform(input, opt_output, opt_dimension) {
        var output;
        if (opt_output !== undefined) {
            for (var i = 0, ii = input.length; i < ii; ++i) {
                opt_output[i] = input[i];
            }
            output = opt_output;
        }
        else {
            output = input.slice();
        }
        return output;
    }
    /**
     * @param {Array<number>} input Input coordinate array.
     * @param {Array<number>=} opt_output Output array of coordinate values.
     * @param {number=} opt_dimension Dimension.
     * @return {Array<number>} Input coordinate array (same array as input).
     */
    function identityTransform(input, opt_output, opt_dimension) {
        if (opt_output !== undefined && input !== opt_output) {
            for (var i = 0, ii = input.length; i < ii; ++i) {
                opt_output[i] = input[i];
            }
            input = opt_output;
        }
        return input;
    }
    /**
     * Add a Projection object to the list of supported projections that can be
     * looked up by their code.
     *
     * @param {Projection} projection Projection instance.
     * @api
     */
    function addProjection(projection) {
        add$2(projection.getCode(), projection);
        add$1(projection, projection, cloneTransform);
    }
    /**
     * @param {Array<Projection>} projections Projections.
     */
    function addProjections(projections) {
        projections.forEach(addProjection);
    }
    /**
     * Fetches a Projection object for the code specified.
     *
     * @param {ProjectionLike} projectionLike Either a code string which is
     *     a combination of authority and identifier such as "EPSG:4326", or an
     *     existing projection object, or undefined.
     * @return {Projection} Projection object, or null if not in list.
     * @api
     */
    function get$1(projectionLike) {
        return typeof projectionLike === 'string'
            ? get$3(/** @type {string} */ (projectionLike))
            : /** @type {Projection} */ (projectionLike) || null;
    }
    /**
     * Get the resolution of the point in degrees or distance units.
     * For projections with degrees as the unit this will simply return the
     * provided resolution. For other projections the point resolution is
     * by default estimated by transforming the 'point' pixel to EPSG:4326,
     * measuring its width and height on the normal sphere,
     * and taking the average of the width and height.
     * A custom function can be provided for a specific projection, either
     * by setting the `getPointResolution` option in the
     * {@link module:ol/proj/Projection~Projection} constructor or by using
     * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
     * projection object.
     * @param {ProjectionLike} projection The projection.
     * @param {number} resolution Nominal resolution in projection units.
     * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
     * @param {import("./proj/Units.js").default=} opt_units Units to get the point resolution in.
     * Default is the projection's units.
     * @return {number} Point resolution.
     * @api
     */
    function getPointResolution(projection, resolution, point, opt_units) {
        projection = get$1(projection);
        var pointResolution;
        var getter = projection.getPointResolutionFunc();
        if (getter) {
            pointResolution = getter(resolution, point);
            if (opt_units && opt_units !== projection.getUnits()) {
                var metersPerUnit = projection.getMetersPerUnit();
                if (metersPerUnit) {
                    pointResolution =
                        (pointResolution * metersPerUnit) / METERS_PER_UNIT$1[opt_units];
                }
            }
        }
        else {
            var units = projection.getUnits();
            if ((units == Units.DEGREES && !opt_units) || opt_units == Units.DEGREES) {
                pointResolution = resolution;
            }
            else {
                // Estimate point resolution by transforming the center pixel to EPSG:4326,
                // measuring its width and height on the normal sphere, and taking the
                // average of the width and height.
                var toEPSG4326_1 = getTransformFromProjections(projection, get$1('EPSG:4326'));
                if (toEPSG4326_1 === identityTransform && units !== Units.DEGREES) {
                    // no transform is available
                    pointResolution = resolution * projection.getMetersPerUnit();
                }
                else {
                    var vertices = [
                        point[0] - resolution / 2,
                        point[1],
                        point[0] + resolution / 2,
                        point[1],
                        point[0],
                        point[1] - resolution / 2,
                        point[0],
                        point[1] + resolution / 2,
                    ];
                    vertices = toEPSG4326_1(vertices, vertices, 2);
                    var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
                    var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
                    pointResolution = (width + height) / 2;
                }
                var metersPerUnit = opt_units
                    ? METERS_PER_UNIT$1[opt_units]
                    : projection.getMetersPerUnit();
                if (metersPerUnit !== undefined) {
                    pointResolution /= metersPerUnit;
                }
            }
        }
        return pointResolution;
    }
    /**
     * Registers transformation functions that don't alter coordinates. Those allow
     * to transform between projections with equal meaning.
     *
     * @param {Array<Projection>} projections Projections.
     * @api
     */
    function addEquivalentProjections(projections) {
        addProjections(projections);
        projections.forEach(function (source) {
            projections.forEach(function (destination) {
                if (source !== destination) {
                    add$1(source, destination, cloneTransform);
                }
            });
        });
    }
    /**
     * Registers transformation functions to convert coordinates in any projection
     * in projection1 to any projection in projection2.
     *
     * @param {Array<Projection>} projections1 Projections with equal
     *     meaning.
     * @param {Array<Projection>} projections2 Projections with equal
     *     meaning.
     * @param {TransformFunction} forwardTransform Transformation from any
     *   projection in projection1 to any projection in projection2.
     * @param {TransformFunction} inverseTransform Transform from any projection
     *   in projection2 to any projection in projection1..
     */
    function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
        projections1.forEach(function (projection1) {
            projections2.forEach(function (projection2) {
                add$1(projection1, projection2, forwardTransform);
                add$1(projection2, projection1, inverseTransform);
            });
        });
    }
    /**
     * @param {Projection|string|undefined} projection Projection.
     * @param {string} defaultCode Default code.
     * @return {Projection} Projection.
     */
    function createProjection(projection, defaultCode) {
        if (!projection) {
            return get$1(defaultCode);
        }
        else if (typeof projection === 'string') {
            return get$1(projection);
        }
        else {
            return /** @type {Projection} */ (projection);
        }
    }
    /**
     * Checks if two projections are the same, that is every coordinate in one
     * projection does represent the same geographic point as the same coordinate in
     * the other projection.
     *
     * @param {Projection} projection1 Projection 1.
     * @param {Projection} projection2 Projection 2.
     * @return {boolean} Equivalent.
     * @api
     */
    function equivalent(projection1, projection2) {
        if (projection1 === projection2) {
            return true;
        }
        var equalUnits = projection1.getUnits() === projection2.getUnits();
        if (projection1.getCode() === projection2.getCode()) {
            return equalUnits;
        }
        else {
            var transformFunc = getTransformFromProjections(projection1, projection2);
            return transformFunc === cloneTransform && equalUnits;
        }
    }
    /**
     * Searches in the list of transform functions for the function for converting
     * coordinates from the source projection to the destination projection.
     *
     * @param {Projection} sourceProjection Source Projection object.
     * @param {Projection} destinationProjection Destination Projection
     *     object.
     * @return {TransformFunction} Transform function.
     */
    function getTransformFromProjections(sourceProjection, destinationProjection) {
        var sourceCode = sourceProjection.getCode();
        var destinationCode = destinationProjection.getCode();
        var transformFunc = get$2(sourceCode, destinationCode);
        if (!transformFunc) {
            transformFunc = identityTransform;
        }
        return transformFunc;
    }
    /**
     * Given the projection-like objects, searches for a transformation
     * function to convert a coordinates array from the source projection to the
     * destination projection.
     *
     * @param {ProjectionLike} source Source.
     * @param {ProjectionLike} destination Destination.
     * @return {TransformFunction} Transform function.
     * @api
     */
    function getTransform(source, destination) {
        var sourceProjection = get$1(source);
        var destinationProjection = get$1(destination);
        return getTransformFromProjections(sourceProjection, destinationProjection);
    }
    /**
     * Transforms a coordinate from source projection to destination projection.
     * This returns a new coordinate (and does not modify the original).
     *
     * See {@link module:ol/proj~transformExtent} for extent transformation.
     * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
     * subclasses for geometry transforms.
     *
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {ProjectionLike} source Source projection-like.
     * @param {ProjectionLike} destination Destination projection-like.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     * @api
     */
    function transform(coordinate, source, destination) {
        var transformFunc = getTransform(source, destination);
        return transformFunc(coordinate, undefined, coordinate.length);
    }
    /**
     * Transforms an extent from source projection to destination projection.  This
     * returns a new extent (and does not modify the original).
     *
     * @param {import("./extent.js").Extent} extent The extent to transform.
     * @param {ProjectionLike} source Source projection-like.
     * @param {ProjectionLike} destination Destination projection-like.
     * @param {number=} opt_stops Number of stops per side used for the transform.
     * By default only the corners are used.
     * @return {import("./extent.js").Extent} The transformed extent.
     * @api
     */
    function transformExtent(extent, source, destination, opt_stops) {
        var transformFunc = getTransform(source, destination);
        return applyTransform(extent, transformFunc, undefined, opt_stops);
    }
    /**
     * @type {?Projection}
     */
    var userProjection = null;
    /**
     * Get the projection for coordinates supplied from and returned by API methods.
     * Note that this method is not yet a part of the stable API.  Support for user
     * projections is not yet complete and should be considered experimental.
     * @returns {?Projection} The user projection (or null if not set).
     */
    function getUserProjection() {
        return userProjection;
    }
    /**
     * Return a coordinate transformed into the user projection.  If no user projection
     * is set, the original coordinate is returned.
     * @param {Array<number>} coordinate Input coordinate.
     * @param {ProjectionLike} sourceProjection The input coordinate projection.
     * @returns {Array<number>} The input coordinate in the user projection.
     */
    function toUserCoordinate(coordinate, sourceProjection) {
        {
            return coordinate;
        }
    }
    /**
     * Return a coordinate transformed from the user projection.  If no user projection
     * is set, the original coordinate is returned.
     * @param {Array<number>} coordinate Input coordinate.
     * @param {ProjectionLike} destProjection The destination projection.
     * @returns {Array<number>} The input coordinate transformed.
     */
    function fromUserCoordinate(coordinate, destProjection) {
        {
            return coordinate;
        }
    }
    /**
     * Return an extent transformed into the user projection.  If no user projection
     * is set, the original extent is returned.
     * @param {import("./extent.js").Extent} extent Input extent.
     * @param {ProjectionLike} sourceProjection The input extent projection.
     * @returns {import("./extent.js").Extent} The input extent in the user projection.
     */
    function toUserExtent(extent, sourceProjection) {
        {
            return extent;
        }
    }
    /**
     * Return an extent transformed from the user projection.  If no user projection
     * is set, the original extent is returned.
     * @param {import("./extent.js").Extent} extent Input extent.
     * @param {ProjectionLike} destProjection The destination projection.
     * @returns {import("./extent.js").Extent} The input extent transformed.
     */
    function fromUserExtent(extent, destProjection) {
        {
            return extent;
        }
    }
    /**
     * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
     * by when this module is executed and should only need to be called again after
     * `clearAllProjections()` is called (e.g. in tests).
     */
    function addCommon() {
        // Add transformations that don't alter coordinates to convert within set of
        // projections with equal meaning.
        addEquivalentProjections(PROJECTIONS$1);
        addEquivalentProjections(PROJECTIONS);
        // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
        // coordinates and back.
        addEquivalentTransforms(PROJECTIONS, PROJECTIONS$1, fromEPSG4326, toEPSG4326);
    }
    addCommon();

    /**
     * @module ol/interaction/DragAndDrop
     */
    // FIXME should handle all geo-referenced data, not just vector data
    var __extends$1e = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {Array<typeof import("../format/Feature.js").default|import("../format/Feature.js").default>} [formatConstructors] Format constructors
     * (and/or formats pre-constructed with options).
     * @property {import("../source/Vector.js").default} [source] Optional vector source where features will be added.  If a source is provided
     * all existing features will be removed and new features will be added when
     * they are dropped on the target.  If you want to add features to a vector
     * source without removing the existing features (append only), instead of
     * providing the source option listen for the "addfeatures" event.
     * @property {import("../proj.js").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.
     * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.
     */
    /**
     * @enum {string}
     */
    var DragAndDropEventType = {
        /**
         * Triggered when features are added
         * @event DragAndDropEvent#addfeatures
         * @api
         */
        ADD_FEATURES: 'addfeatures',
    };
    /**
     * @classdesc
     * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances
     * of this type.
     */
    var DragAndDropEvent = /** @class */ (function (_super) {
        __extends$1e(DragAndDropEvent, _super);
        /**
         * @param {DragAndDropEventType} type Type.
         * @param {File} file File.
         * @param {Array<import("../Feature.js").default>=} opt_features Features.
         * @param {import("../proj/Projection.js").default=} opt_projection Projection.
         */
        function DragAndDropEvent(type, file, opt_features, opt_projection) {
            var _this = _super.call(this, type) || this;
            /**
             * The features parsed from dropped data.
             * @type {Array<import("../Feature.js").FeatureLike>|undefined}
             * @api
             */
            _this.features = opt_features;
            /**
             * The dropped file.
             * @type {File}
             * @api
             */
            _this.file = file;
            /**
             * The feature projection.
             * @type {import("../proj/Projection.js").default|undefined}
             * @api
             */
            _this.projection = opt_projection;
            return _this;
        }
        return DragAndDropEvent;
    }(BaseEvent));
    /**
     * @classdesc
     * Handles input of vector data by drag and drop.
     *
     * Note that the DragAndDrop interaction uses the TextDecoder() constructor if the supplied
     * combinnation of formats read both text string and ArrayBuffer sources. Older browsers such
     * as IE which do not support this will need a TextDecoder polyfill to be loaded before use.
     *
     * @api
     *
     * @fires DragAndDropEvent
     */
    var DragAndDrop = /** @class */ (function (_super) {
        __extends$1e(DragAndDrop, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function DragAndDrop(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
                handleEvent: TRUE,
            }) || this;
            /**
             * @private
             * @type {boolean}
             */
            _this.readAsBuffer_ = false;
            /**
             * @private
             * @type {Array<import("../format/Feature.js").default>}
             */
            _this.formats_ = [];
            var formatConstructors = options.formatConstructors
                ? options.formatConstructors
                : [];
            for (var i = 0, ii = formatConstructors.length; i < ii; ++i) {
                var format = formatConstructors[i];
                if (typeof format === 'function') {
                    format = new format();
                }
                _this.formats_.push(format);
                _this.readAsBuffer_ =
                    _this.readAsBuffer_ || format.getType() === FormatType.ARRAY_BUFFER;
            }
            /**
             * @private
             * @type {import("../proj/Projection.js").default}
             */
            _this.projection_ = options.projection
                ? get$1(options.projection)
                : null;
            /**
             * @private
             * @type {?Array<import("../events.js").EventsKey>}
             */
            _this.dropListenKeys_ = null;
            /**
             * @private
             * @type {import("../source/Vector.js").default}
             */
            _this.source_ = options.source || null;
            /**
             * @private
             * @type {HTMLElement}
             */
            _this.target = options.target ? options.target : null;
            return _this;
        }
        /**
         * @param {File} file File.
         * @param {Event} event Load event.
         * @private
         */
        DragAndDrop.prototype.handleResult_ = function (file, event) {
            var result = event.target.result;
            var map = this.getMap();
            var projection = this.projection_;
            if (!projection) {
                var view = map.getView();
                projection = view.getProjection();
            }
            var text;
            var formats = this.formats_;
            for (var i = 0, ii = formats.length; i < ii; ++i) {
                var format = formats[i];
                var input = result;
                if (this.readAsBuffer_ && format.getType() !== FormatType.ARRAY_BUFFER) {
                    if (text === undefined) {
                        text = new TextDecoder().decode(result);
                    }
                    input = text;
                }
                var features = this.tryReadFeatures_(format, input, {
                    featureProjection: projection,
                });
                if (features && features.length > 0) {
                    if (this.source_) {
                        this.source_.clear();
                        this.source_.addFeatures(features);
                    }
                    this.dispatchEvent(new DragAndDropEvent(DragAndDropEventType.ADD_FEATURES, file, features, projection));
                    break;
                }
            }
        };
        /**
         * @private
         */
        DragAndDrop.prototype.registerListeners_ = function () {
            var map = this.getMap();
            if (map) {
                var dropArea = this.target ? this.target : map.getViewport();
                this.dropListenKeys_ = [
                    listen(dropArea, EventType.DROP, this.handleDrop, this),
                    listen(dropArea, EventType.DRAGENTER, this.handleStop, this),
                    listen(dropArea, EventType.DRAGOVER, this.handleStop, this),
                    listen(dropArea, EventType.DROP, this.handleStop, this),
                ];
            }
        };
        /**
         * Activate or deactivate the interaction.
         * @param {boolean} active Active.
         * @observable
         * @api
         */
        DragAndDrop.prototype.setActive = function (active) {
            if (!this.getActive() && active) {
                this.registerListeners_();
            }
            if (this.getActive() && !active) {
                this.unregisterListeners_();
            }
            _super.prototype.setActive.call(this, active);
        };
        /**
         * Remove the interaction from its current map and attach it to the new map.
         * Subclasses may set up event handlers to get notified about changes to
         * the map here.
         * @param {import("../PluggableMap.js").default} map Map.
         */
        DragAndDrop.prototype.setMap = function (map) {
            this.unregisterListeners_();
            _super.prototype.setMap.call(this, map);
            if (this.getActive()) {
                this.registerListeners_();
            }
        };
        /**
         * @param {import("../format/Feature.js").default} format Format.
         * @param {string} text Text.
         * @param {import("../format/Feature.js").ReadOptions} options Read options.
         * @private
         * @return {Array<import("../Feature.js").default>} Features.
         */
        DragAndDrop.prototype.tryReadFeatures_ = function (format, text, options) {
            try {
                return (
                /** @type {Array<import("../Feature.js").default>} */
                (format.readFeatures(text, options)));
            }
            catch (e) {
                return null;
            }
        };
        /**
         * @private
         */
        DragAndDrop.prototype.unregisterListeners_ = function () {
            if (this.dropListenKeys_) {
                this.dropListenKeys_.forEach(unlistenByKey);
                this.dropListenKeys_ = null;
            }
        };
        /**
         * @param {DragEvent} event Event.
         */
        DragAndDrop.prototype.handleDrop = function (event) {
            var files = event.dataTransfer.files;
            for (var i = 0, ii = files.length; i < ii; ++i) {
                var file = files.item(i);
                var reader = new FileReader();
                reader.addEventListener(EventType.LOAD, this.handleResult_.bind(this, file));
                if (this.readAsBuffer_) {
                    reader.readAsArrayBuffer(file);
                }
                else {
                    reader.readAsText(file);
                }
            }
        };
        /**
         * @param {DragEvent} event Event.
         */
        DragAndDrop.prototype.handleStop = function (event) {
            event.stopPropagation();
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';
        };
        return DragAndDrop;
    }(Interaction));

    var __extends$1d = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
     */
    /**
     * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
     */
    /**
     * @classdesc
     * A vector object for geographic features with a geometry and other
     * attribute properties, similar to the features in vector file formats like
     * GeoJSON.
     *
     * Features can be styled individually with `setStyle`; otherwise they use the
     * style of their vector layer.
     *
     * Note that attribute properties are set as {@link module:ol/Object} properties on
     * the feature object, so they are observable, and have get/set accessors.
     *
     * Typically, a feature has a single geometry property. You can set the
     * geometry using the `setGeometry` method and get it with `getGeometry`.
     * It is possible to store more than one geometry on a feature using attribute
     * properties. By default, the geometry used for rendering is identified by
     * the property name `geometry`. If you want to use another geometry property
     * for rendering, use the `setGeometryName` method to change the attribute
     * property associated with the geometry for the feature.  For example:
     *
     * ```js
     *
     * import Feature from 'ol/Feature';
     * import Polygon from 'ol/geom/Polygon';
     * import Point from 'ol/geom/Point';
     *
     * var feature = new Feature({
     *   geometry: new Polygon(polyCoords),
     *   labelPoint: new Point(labelCoords),
     *   name: 'My Polygon'
     * });
     *
     * // get the polygon geometry
     * var poly = feature.getGeometry();
     *
     * // Render the feature as a point using the coordinates from labelPoint
     * feature.setGeometryName('labelPoint');
     *
     * // get the point geometry
     * var point = feature.getGeometry();
     * ```
     *
     * @api
     * @template {import("./geom/Geometry.js").default} Geometry
     */
    var Feature = /** @class */ (function (_super) {
        __extends$1d(Feature, _super);
        /**
         * @param {Geometry|Object<string, *>=} opt_geometryOrProperties
         *     You may pass a Geometry object directly, or an object literal containing
         *     properties. If you pass an object literal, you may include a Geometry
         *     associated with a `geometry` key.
         */
        function Feature(opt_geometryOrProperties) {
            var _this = _super.call(this) || this;
            /**
             * @private
             * @type {number|string|undefined}
             */
            _this.id_ = undefined;
            /**
             * @type {string}
             * @private
             */
            _this.geometryName_ = 'geometry';
            /**
             * User provided style.
             * @private
             * @type {import("./style/Style.js").StyleLike}
             */
            _this.style_ = null;
            /**
             * @private
             * @type {import("./style/Style.js").StyleFunction|undefined}
             */
            _this.styleFunction_ = undefined;
            /**
             * @private
             * @type {?import("./events.js").EventsKey}
             */
            _this.geometryChangeKey_ = null;
            _this.addEventListener(getChangeEventType(_this.geometryName_), _this.handleGeometryChanged_);
            if (opt_geometryOrProperties) {
                if (typeof (
                /** @type {?} */ (opt_geometryOrProperties).getSimplifiedGeometry) === 'function') {
                    var geometry = /** @type {Geometry} */ (opt_geometryOrProperties);
                    _this.setGeometry(geometry);
                }
                else {
                    /** @type {Object<string, *>} */
                    var properties = opt_geometryOrProperties;
                    _this.setProperties(properties);
                }
            }
            return _this;
        }
        /**
         * Clone this feature. If the original feature has a geometry it
         * is also cloned. The feature id is not set in the clone.
         * @return {Feature} The clone.
         * @api
         */
        Feature.prototype.clone = function () {
            var clone = new Feature(this.hasProperties() ? this.getProperties() : null);
            clone.setGeometryName(this.getGeometryName());
            var geometry = this.getGeometry();
            if (geometry) {
                clone.setGeometry(geometry.clone());
            }
            var style = this.getStyle();
            if (style) {
                clone.setStyle(style);
            }
            return clone;
        };
        /**
         * Get the feature's default geometry.  A feature may have any number of named
         * geometries.  The "default" geometry (the one that is rendered by default) is
         * set when calling {@link module:ol/Feature~Feature#setGeometry}.
         * @return {Geometry|undefined} The default geometry for the feature.
         * @api
         * @observable
         */
        Feature.prototype.getGeometry = function () {
            return /** @type {Geometry|undefined} */ (this.get(this.geometryName_));
        };
        /**
         * Get the feature identifier.  This is a stable identifier for the feature and
         * is either set when reading data from a remote source or set explicitly by
         * calling {@link module:ol/Feature~Feature#setId}.
         * @return {number|string|undefined} Id.
         * @api
         */
        Feature.prototype.getId = function () {
            return this.id_;
        };
        /**
         * Get the name of the feature's default geometry.  By default, the default
         * geometry is named `geometry`.
         * @return {string} Get the property name associated with the default geometry
         *     for this feature.
         * @api
         */
        Feature.prototype.getGeometryName = function () {
            return this.geometryName_;
        };
        /**
         * Get the feature's style. Will return what was provided to the
         * {@link module:ol/Feature~Feature#setStyle} method.
         * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
         * @api
         */
        Feature.prototype.getStyle = function () {
            return this.style_;
        };
        /**
         * Get the feature's style function.
         * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
         * representing the current style of this feature.
         * @api
         */
        Feature.prototype.getStyleFunction = function () {
            return this.styleFunction_;
        };
        /**
         * @private
         */
        Feature.prototype.handleGeometryChange_ = function () {
            this.changed();
        };
        /**
         * @private
         */
        Feature.prototype.handleGeometryChanged_ = function () {
            if (this.geometryChangeKey_) {
                unlistenByKey(this.geometryChangeKey_);
                this.geometryChangeKey_ = null;
            }
            var geometry = this.getGeometry();
            if (geometry) {
                this.geometryChangeKey_ = listen(geometry, EventType.CHANGE, this.handleGeometryChange_, this);
            }
            this.changed();
        };
        /**
         * Set the default geometry for the feature.  This will update the property
         * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
         * @param {Geometry|undefined} geometry The new geometry.
         * @api
         * @observable
         */
        Feature.prototype.setGeometry = function (geometry) {
            this.set(this.geometryName_, geometry);
        };
        /**
         * Set the style for the feature to override the layer style.  This can be a
         * single style object, an array of styles, or a function that takes a
         * resolution and returns an array of styles. To unset the feature style, call
         * `setStyle()` without arguments or a falsey value.
         * @param {import("./style/Style.js").StyleLike=} opt_style Style for this feature.
         * @api
         * @fires module:ol/events/Event~BaseEvent#event:change
         */
        Feature.prototype.setStyle = function (opt_style) {
            this.style_ = opt_style;
            this.styleFunction_ = !opt_style
                ? undefined
                : createStyleFunction(opt_style);
            this.changed();
        };
        /**
         * Set the feature id.  The feature id is considered stable and may be used when
         * requesting features or comparing identifiers returned from a remote source.
         * The feature id can be used with the
         * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
         * @param {number|string|undefined} id The feature id.
         * @api
         * @fires module:ol/events/Event~BaseEvent#event:change
         */
        Feature.prototype.setId = function (id) {
            this.id_ = id;
            this.changed();
        };
        /**
         * Set the property name to be used when getting the feature's default geometry.
         * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
         * this name will be returned.
         * @param {string} name The property name of the default geometry.
         * @api
         */
        Feature.prototype.setGeometryName = function (name) {
            this.removeEventListener(getChangeEventType(this.geometryName_), this.handleGeometryChanged_);
            this.geometryName_ = name;
            this.addEventListener(getChangeEventType(this.geometryName_), this.handleGeometryChanged_);
            this.handleGeometryChanged_();
        };
        return Feature;
    }(BaseObject));
    /**
     * Convert the provided object into a feature style function.  Functions passed
     * through unchanged.  Arrays of Style or single style objects wrapped
     * in a new feature style function.
     * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
     *     A feature style function, a single style, or an array of styles.
     * @return {import("./style/Style.js").StyleFunction} A style function.
     */
    function createStyleFunction(obj) {
        if (typeof obj === 'function') {
            return obj;
        }
        else {
            /**
             * @type {Array<import("./style/Style.js").default>}
             */
            var styles_1;
            if (Array.isArray(obj)) {
                styles_1 = obj;
            }
            else {
                assert(typeof ( /** @type {?} */(obj).getZIndex) === 'function', 41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`
                var style = /** @type {import("./style/Style.js").default} */ (obj);
                styles_1 = [style];
            }
            return function () {
                return styles_1;
            };
        }
    }

    /**
     * @module ol/geom/GeometryLayout
     */
    /**
     * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
     * or measure ('M') coordinate is available. Supported values are `'XY'`,
     * `'XYZ'`, `'XYM'`, `'XYZM'`.
     * @enum {string}
     */
    var GeometryLayout = {
        XY: 'XY',
        XYZ: 'XYZ',
        XYM: 'XYM',
        XYZM: 'XYZM',
    };

    /**
     * @module ol/format/Feature
     */
    /**
     * @typedef {Object} ReadOptions
     * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.
     * If not provided, the projection will be derived from the data (where possible) or
     * the `dataProjection` of the format is assigned (where set). If the projection
     * can not be derived from the data and if no `dataProjection` is set for a format,
     * the features will not be reprojected.
     * @property {import("../extent.js").Extent} [extent] Tile extent in map units of the tile being read.
     * This is only required when reading data with tile pixels as geometry units. When configured,
     * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
     * provided.
     * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
     * created by the format reader. If not provided, features will be returned in the
     * `dataProjection`.
     */
    /**
     * @typedef {Object} WriteOptions
     * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.
     * If not provided, the `dataProjection` of the format is assigned (where set).
     * If no `dataProjection` is set for a format, the features will be returned
     * in the `featureProjection`.
     * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
     * that will be serialized by the format writer. If not provided, geometries are assumed
     * to be in the `dataProjection` if that is set; in other words, they are not transformed.
     * @property {boolean} [rightHanded] When writing geometries, follow the right-hand
     * rule for linear ring orientation.  This means that polygons will have counter-clockwise
     * exterior rings and clockwise interior rings.  By default, coordinates are serialized
     * as they are provided at construction.  If `true`, the right-hand rule will
     * be applied.  If `false`, the left-hand rule will be applied (clockwise for
     * exterior and counter-clockwise for interior rings).  Note that not all
     * formats support this.  The GeoJSON format does use this property when writing
     * geometries.
     * @property {number} [decimals] Maximum number of decimal places for coordinates.
     * Coordinates are stored internally as floats, but floating-point arithmetic can create
     * coordinates with a large number of decimal places, not generally wanted on output.
     * Set a number here to round coordinates. Can also be used to ensure that
     * coordinates read in can be written back out with the same number of decimals.
     * Default is no rounding.
     */
    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Base class for feature formats.
     * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode
     * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial
     * file formats.  See the documentation for each format for more details.
     *
     * @abstract
     * @api
     */
    var FeatureFormat = /** @class */ (function () {
        function FeatureFormat() {
            /**
             * @protected
             * @type {import("../proj/Projection.js").default}
             */
            this.dataProjection = null;
            /**
             * @protected
             * @type {import("../proj/Projection.js").default}
             */
            this.defaultFeatureProjection = null;
        }
        /**
         * Adds the data projection to the read options.
         * @param {Document|Element|Object|string} source Source.
         * @param {ReadOptions=} opt_options Options.
         * @return {ReadOptions|undefined} Options.
         * @protected
         */
        FeatureFormat.prototype.getReadOptions = function (source, opt_options) {
            var options;
            if (opt_options) {
                var dataProjection = opt_options.dataProjection
                    ? get$1(opt_options.dataProjection)
                    : this.readProjection(source);
                if (opt_options.extent &&
                    dataProjection &&
                    dataProjection.getUnits() === Units.TILE_PIXELS) {
                    dataProjection = get$1(dataProjection);
                    dataProjection.setWorldExtent(opt_options.extent);
                }
                options = {
                    dataProjection: dataProjection,
                    featureProjection: opt_options.featureProjection,
                };
            }
            return this.adaptOptions(options);
        };
        /**
         * Sets the `dataProjection` on the options, if no `dataProjection`
         * is set.
         * @param {WriteOptions|ReadOptions|undefined} options
         *     Options.
         * @protected
         * @return {WriteOptions|ReadOptions|undefined}
         *     Updated options.
         */
        FeatureFormat.prototype.adaptOptions = function (options) {
            return assign({
                dataProjection: this.dataProjection,
                featureProjection: this.defaultFeatureProjection,
            }, options);
        };
        /**
         * @abstract
         * @return {import("./FormatType.js").default} Format.
         */
        FeatureFormat.prototype.getType = function () {
            return abstract();
        };
        /**
         * Read a single feature from a source.
         *
         * @abstract
         * @param {Document|Element|Object|string} source Source.
         * @param {ReadOptions=} opt_options Read options.
         * @return {import("../Feature.js").FeatureLike} Feature.
         */
        FeatureFormat.prototype.readFeature = function (source, opt_options) {
            return abstract();
        };
        /**
         * Read all features from a source.
         *
         * @abstract
         * @param {Document|Element|ArrayBuffer|Object|string} source Source.
         * @param {ReadOptions=} opt_options Read options.
         * @return {Array<import("../Feature.js").FeatureLike>} Features.
         */
        FeatureFormat.prototype.readFeatures = function (source, opt_options) {
            return abstract();
        };
        /**
         * Read a single geometry from a source.
         *
         * @abstract
         * @param {Document|Element|Object|string} source Source.
         * @param {ReadOptions=} opt_options Read options.
         * @return {import("../geom/Geometry.js").default} Geometry.
         */
        FeatureFormat.prototype.readGeometry = function (source, opt_options) {
            return abstract();
        };
        /**
         * Read the projection from a source.
         *
         * @abstract
         * @param {Document|Element|Object|string} source Source.
         * @return {import("../proj/Projection.js").default} Projection.
         */
        FeatureFormat.prototype.readProjection = function (source) {
            return abstract();
        };
        /**
         * Encode a feature in this format.
         *
         * @abstract
         * @param {import("../Feature.js").default} feature Feature.
         * @param {WriteOptions=} opt_options Write options.
         * @return {string} Result.
         */
        FeatureFormat.prototype.writeFeature = function (feature, opt_options) {
            return abstract();
        };
        /**
         * Encode an array of features in this format.
         *
         * @abstract
         * @param {Array<import("../Feature.js").default>} features Features.
         * @param {WriteOptions=} opt_options Write options.
         * @return {string} Result.
         */
        FeatureFormat.prototype.writeFeatures = function (features, opt_options) {
            return abstract();
        };
        /**
         * Write a single geometry in this format.
         *
         * @abstract
         * @param {import("../geom/Geometry.js").default} geometry Geometry.
         * @param {WriteOptions=} opt_options Write options.
         * @return {string} Result.
         */
        FeatureFormat.prototype.writeGeometry = function (geometry, opt_options) {
            return abstract();
        };
        return FeatureFormat;
    }());
    /**
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {boolean} write Set to true for writing, false for reading.
     * @param {(WriteOptions|ReadOptions)=} opt_options Options.
     * @return {import("../geom/Geometry.js").default} Transformed geometry.
     */
    function transformGeometryWithOptions(geometry, write, opt_options) {
        var featureProjection = opt_options
            ? get$1(opt_options.featureProjection)
            : null;
        var dataProjection = opt_options
            ? get$1(opt_options.dataProjection)
            : null;
        var transformed;
        if (featureProjection &&
            dataProjection &&
            !equivalent(featureProjection, dataProjection)) {
            transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
        }
        else {
            transformed = geometry;
        }
        if (write &&
            opt_options &&
            /** @type {WriteOptions} */ (opt_options).decimals !== undefined) {
            var power_1 = Math.pow(10, 
            /** @type {WriteOptions} */ (opt_options).decimals);
            // if decimals option on write, round each coordinate appropriately
            /**
             * @param {Array<number>} coordinates Coordinates.
             * @return {Array<number>} Transformed coordinates.
             */
            var transform = function (coordinates) {
                for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                    coordinates[i] = Math.round(coordinates[i] * power_1) / power_1;
                }
                return coordinates;
            };
            if (transformed === geometry) {
                transformed = geometry.clone();
            }
            transformed.applyTransform(transform);
        }
        return transformed;
    }

    var __extends$1c = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Base class for JSON feature formats.
     *
     * @abstract
     */
    var JSONFeature = /** @class */ (function (_super) {
        __extends$1c(JSONFeature, _super);
        function JSONFeature() {
            return _super.call(this) || this;
        }
        /**
         * @return {import("./FormatType.js").default} Format.
         */
        JSONFeature.prototype.getType = function () {
            return FormatType.JSON;
        };
        /**
         * Read a feature.  Only works for a single feature. Use `readFeatures` to
         * read a feature collection.
         *
         * @param {ArrayBuffer|Document|Element|Object|string} source Source.
         * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
         * @return {import("../Feature.js").default} Feature.
         * @api
         */
        JSONFeature.prototype.readFeature = function (source, opt_options) {
            return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));
        };
        /**
         * Read all features.  Works with both a single feature and a feature
         * collection.
         *
         * @param {ArrayBuffer|Document|Element|Object|string} source Source.
         * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
         * @return {Array<import("../Feature.js").default>} Features.
         * @api
         */
        JSONFeature.prototype.readFeatures = function (source, opt_options) {
            return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));
        };
        /**
         * @abstract
         * @param {Object} object Object.
         * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
         * @protected
         * @return {import("../Feature.js").default} Feature.
         */
        JSONFeature.prototype.readFeatureFromObject = function (object, opt_options) {
            return abstract();
        };
        /**
         * @abstract
         * @param {Object} object Object.
         * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
         * @protected
         * @return {Array<import("../Feature.js").default>} Features.
         */
        JSONFeature.prototype.readFeaturesFromObject = function (object, opt_options) {
            return abstract();
        };
        /**
         * Read a geometry.
         *
         * @param {ArrayBuffer|Document|Element|Object|string} source Source.
         * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
         * @return {import("../geom/Geometry.js").default} Geometry.
         * @api
         */
        JSONFeature.prototype.readGeometry = function (source, opt_options) {
            return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));
        };
        /**
         * @abstract
         * @param {Object} object Object.
         * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
         * @protected
         * @return {import("../geom/Geometry.js").default} Geometry.
         */
        JSONFeature.prototype.readGeometryFromObject = function (object, opt_options) {
            return abstract();
        };
        /**
         * Read the projection.
         *
         * @param {ArrayBuffer|Document|Element|Object|string} source Source.
         * @return {import("../proj/Projection.js").default} Projection.
         * @api
         */
        JSONFeature.prototype.readProjection = function (source) {
            return this.readProjectionFromObject(getObject(source));
        };
        /**
         * @abstract
         * @param {Object} object Object.
         * @protected
         * @return {import("../proj/Projection.js").default} Projection.
         */
        JSONFeature.prototype.readProjectionFromObject = function (object) {
            return abstract();
        };
        /**
         * Encode a feature as string.
         *
         * @param {import("../Feature.js").default} feature Feature.
         * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
         * @return {string} Encoded feature.
         * @api
         */
        JSONFeature.prototype.writeFeature = function (feature, opt_options) {
            return JSON.stringify(this.writeFeatureObject(feature, opt_options));
        };
        /**
         * @abstract
         * @param {import("../Feature.js").default} feature Feature.
         * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
         * @return {Object} Object.
         */
        JSONFeature.prototype.writeFeatureObject = function (feature, opt_options) {
            return abstract();
        };
        /**
         * Encode an array of features as string.
         *
         * @param {Array<import("../Feature.js").default>} features Features.
         * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
         * @return {string} Encoded features.
         * @api
         */
        JSONFeature.prototype.writeFeatures = function (features, opt_options) {
            return JSON.stringify(this.writeFeaturesObject(features, opt_options));
        };
        /**
         * @abstract
         * @param {Array<import("../Feature.js").default>} features Features.
         * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
         * @return {Object} Object.
         */
        JSONFeature.prototype.writeFeaturesObject = function (features, opt_options) {
            return abstract();
        };
        /**
         * Encode a geometry as string.
         *
         * @param {import("../geom/Geometry.js").default} geometry Geometry.
         * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
         * @return {string} Encoded geometry.
         * @api
         */
        JSONFeature.prototype.writeGeometry = function (geometry, opt_options) {
            return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
        };
        /**
         * @abstract
         * @param {import("../geom/Geometry.js").default} geometry Geometry.
         * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
         * @return {Object} Object.
         */
        JSONFeature.prototype.writeGeometryObject = function (geometry, opt_options) {
            return abstract();
        };
        return JSONFeature;
    }(FeatureFormat));
    /**
     * @param {Document|Element|Object|string} source Source.
     * @return {Object} Object.
     */
    function getObject(source) {
        if (typeof source === 'string') {
            var object = JSON.parse(source);
            return object ? /** @type {Object} */ (object) : null;
        }
        else if (source !== null) {
            return source;
        }
        else {
            return null;
        }
    }

    /**
     * @module ol/transform
     */
    /**
     * An array representing an affine 2d transformation for use with
     * {@link module:ol/transform} functions. The array has 6 elements.
     * @typedef {!Array<number>} Transform
     * @api
     */
    /**
     * Collection of affine 2d transformation functions. The functions work on an
     * array of 6 elements. The element order is compatible with the [SVGMatrix
     * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
     * a subset (elements a to f) of a 3×3 matrix:
     * ```
     * [ a c e ]
     * [ b d f ]
     * [ 0 0 1 ]
     * ```
     */
    /**
     * @private
     * @type {Transform}
     */
    new Array(6);
    /**
     * Create an identity transform.
     * @return {!Transform} Identity transform.
     */
    function create() {
        return [1, 0, 0, 1, 0, 0];
    }
    /**
     * Set the transform components a-f on a given transform.
     * @param {!Transform} transform Transform.
     * @param {number} a The a component of the transform.
     * @param {number} b The b component of the transform.
     * @param {number} c The c component of the transform.
     * @param {number} d The d component of the transform.
     * @param {number} e The e component of the transform.
     * @param {number} f The f component of the transform.
     * @return {!Transform} Matrix with transform applied.
     */
    function set(transform, a, b, c, d, e, f) {
        transform[0] = a;
        transform[1] = b;
        transform[2] = c;
        transform[3] = d;
        transform[4] = e;
        transform[5] = f;
        return transform;
    }
    /**
     * Set transform on one matrix from another matrix.
     * @param {!Transform} transform1 Matrix to set transform to.
     * @param {!Transform} transform2 Matrix to set transform from.
     * @return {!Transform} transform1 with transform from transform2 applied.
     */
    function setFromArray(transform1, transform2) {
        transform1[0] = transform2[0];
        transform1[1] = transform2[1];
        transform1[2] = transform2[2];
        transform1[3] = transform2[3];
        transform1[4] = transform2[4];
        transform1[5] = transform2[5];
        return transform1;
    }
    /**
     * Transforms the given coordinate with the given transform returning the
     * resulting, transformed coordinate. The coordinate will be modified in-place.
     *
     * @param {Transform} transform The transformation.
     * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
     * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
     *     chained together.
     */
    function apply(transform, coordinate) {
        var x = coordinate[0];
        var y = coordinate[1];
        coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
        coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
        return coordinate;
    }
    /**
     * Creates a scale transform.
     * @param {!Transform} target Transform to overwrite.
     * @param {number} x Scale factor x.
     * @param {number} y Scale factor y.
     * @return {!Transform} The scale transform.
     */
    function makeScale(target, x, y) {
        return set(target, x, 0, 0, y, 0, 0);
    }
    /**
     * Creates a composite transform given an initial translation, scale, rotation, and
     * final translation (in that order only, not commutative).
     * @param {!Transform} transform The transform (will be modified in place).
     * @param {number} dx1 Initial translation x.
     * @param {number} dy1 Initial translation y.
     * @param {number} sx Scale factor x.
     * @param {number} sy Scale factor y.
     * @param {number} angle Rotation (in counter-clockwise radians).
     * @param {number} dx2 Final translation x.
     * @param {number} dy2 Final translation y.
     * @return {!Transform} The composite transform.
     */
    function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
        var sin = Math.sin(angle);
        var cos = Math.cos(angle);
        transform[0] = sx * cos;
        transform[1] = sy * sin;
        transform[2] = -sx * sin;
        transform[3] = sy * cos;
        transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
        transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
        return transform;
    }
    /**
     * Invert the given transform.
     * @param {!Transform} target Transform to be set as the inverse of
     *     the source transform.
     * @param {!Transform} source The source transform to invert.
     * @return {!Transform} The inverted (target) transform.
     */
    function makeInverse(target, source) {
        var det = determinant(source);
        assert(det !== 0, 32); // Transformation matrix cannot be inverted
        var a = source[0];
        var b = source[1];
        var c = source[2];
        var d = source[3];
        var e = source[4];
        var f = source[5];
        target[0] = d / det;
        target[1] = -b / det;
        target[2] = -c / det;
        target[3] = a / det;
        target[4] = (c * f - d * e) / det;
        target[5] = -(a * f - b * e) / det;
        return target;
    }
    /**
     * Returns the determinant of the given matrix.
     * @param {!Transform} mat Matrix.
     * @return {number} Determinant.
     */
    function determinant(mat) {
        return mat[0] * mat[3] - mat[1] * mat[2];
    }
    /**
     * A string version of the transform.  This can be used
     * for CSS transforms.
     * @param {!Transform} mat Matrix.
     * @return {string} The transform as a string.
     */
    function toString$2(mat) {
        return 'matrix(' + mat.join(', ') + ')';
    }

    /**
     * @module ol/geom/flat/transform
     */
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {Array<number>=} opt_dest Destination.
     * @return {Array<number>} Transformed coordinates.
     */
    function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
        var dest = opt_dest ? opt_dest : [];
        var i = 0;
        for (var j = offset; j < end; j += stride) {
            var x = flatCoordinates[j];
            var y = flatCoordinates[j + 1];
            dest[i++] = transform[0] * x + transform[2] * y + transform[4];
            dest[i++] = transform[1] * x + transform[3] * y + transform[5];
        }
        if (opt_dest && dest.length != i) {
            dest.length = i;
        }
        return dest;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} angle Angle.
     * @param {Array<number>} anchor Rotation anchor point.
     * @param {Array<number>=} opt_dest Destination.
     * @return {Array<number>} Transformed coordinates.
     */
    function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
        var dest = opt_dest ? opt_dest : [];
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var anchorX = anchor[0];
        var anchorY = anchor[1];
        var i = 0;
        for (var j = offset; j < end; j += stride) {
            var deltaX = flatCoordinates[j] - anchorX;
            var deltaY = flatCoordinates[j + 1] - anchorY;
            dest[i++] = anchorX + deltaX * cos - deltaY * sin;
            dest[i++] = anchorY + deltaX * sin + deltaY * cos;
            for (var k = j + 2; k < j + stride; ++k) {
                dest[i++] = flatCoordinates[k];
            }
        }
        if (opt_dest && dest.length != i) {
            dest.length = i;
        }
        return dest;
    }
    /**
     * Scale the coordinates.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} sx Scale factor in the x-direction.
     * @param {number} sy Scale factor in the y-direction.
     * @param {Array<number>} anchor Scale anchor point.
     * @param {Array<number>=} opt_dest Destination.
     * @return {Array<number>} Transformed coordinates.
     */
    function scale$1(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
        var dest = opt_dest ? opt_dest : [];
        var anchorX = anchor[0];
        var anchorY = anchor[1];
        var i = 0;
        for (var j = offset; j < end; j += stride) {
            var deltaX = flatCoordinates[j] - anchorX;
            var deltaY = flatCoordinates[j + 1] - anchorY;
            dest[i++] = anchorX + sx * deltaX;
            dest[i++] = anchorY + sy * deltaY;
            for (var k = j + 2; k < j + stride; ++k) {
                dest[i++] = flatCoordinates[k];
            }
        }
        if (opt_dest && dest.length != i) {
            dest.length = i;
        }
        return dest;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @param {Array<number>=} opt_dest Destination.
     * @return {Array<number>} Transformed coordinates.
     */
    function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
        var dest = opt_dest ? opt_dest : [];
        var i = 0;
        for (var j = offset; j < end; j += stride) {
            dest[i++] = flatCoordinates[j] + deltaX;
            dest[i++] = flatCoordinates[j + 1] + deltaY;
            for (var k = j + 2; k < j + stride; ++k) {
                dest[i++] = flatCoordinates[k];
            }
        }
        if (opt_dest && dest.length != i) {
            dest.length = i;
        }
        return dest;
    }

    var __extends$1b = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @type {import("../transform.js").Transform}
     */
    var tmpTransform = create();
    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Base class for vector geometries.
     *
     * To get notified of changes to the geometry, register a listener for the
     * generic `change` event on your geometry instance.
     *
     * @abstract
     * @api
     */
    var Geometry = /** @class */ (function (_super) {
        __extends$1b(Geometry, _super);
        function Geometry() {
            var _this = _super.call(this) || this;
            /**
             * @private
             * @type {import("../extent.js").Extent}
             */
            _this.extent_ = createEmpty();
            /**
             * @private
             * @type {number}
             */
            _this.extentRevision_ = -1;
            /**
             * @protected
             * @type {number}
             */
            _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
            /**
             * @protected
             * @type {number}
             */
            _this.simplifiedGeometryRevision = 0;
            /**
             * Get a transformed and simplified version of the geometry.
             * @abstract
             * @param {number} revision The geometry revision.
             * @param {number} squaredTolerance Squared tolerance.
             * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
             * @return {Geometry} Simplified geometry.
             */
            _this.simplifyTransformedInternal = memoizeOne(function (revision, squaredTolerance, opt_transform) {
                if (!opt_transform) {
                    return this.getSimplifiedGeometry(squaredTolerance);
                }
                var clone = this.clone();
                clone.applyTransform(opt_transform);
                return clone.getSimplifiedGeometry(squaredTolerance);
            });
            return _this;
        }
        /**
         * Get a transformed and simplified version of the geometry.
         * @abstract
         * @param {number} squaredTolerance Squared tolerance.
         * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
         * @return {Geometry} Simplified geometry.
         */
        Geometry.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {
            return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);
        };
        /**
         * Make a complete copy of the geometry.
         * @abstract
         * @return {!Geometry} Clone.
         */
        Geometry.prototype.clone = function () {
            return abstract();
        };
        /**
         * @abstract
         * @param {number} x X.
         * @param {number} y Y.
         * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
         * @param {number} minSquaredDistance Minimum squared distance.
         * @return {number} Minimum squared distance.
         */
        Geometry.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
            return abstract();
        };
        /**
         * @param {number} x X.
         * @param {number} y Y.
         * @return {boolean} Contains (x, y).
         */
        Geometry.prototype.containsXY = function (x, y) {
            var coord = this.getClosestPoint([x, y]);
            return coord[0] === x && coord[1] === y;
        };
        /**
         * Return the closest point of the geometry to the passed point as
         * {@link module:ol/coordinate~Coordinate coordinate}.
         * @param {import("../coordinate.js").Coordinate} point Point.
         * @param {import("../coordinate.js").Coordinate=} opt_closestPoint Closest point.
         * @return {import("../coordinate.js").Coordinate} Closest point.
         * @api
         */
        Geometry.prototype.getClosestPoint = function (point, opt_closestPoint) {
            var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
            this.closestPointXY(point[0], point[1], closestPoint, Infinity);
            return closestPoint;
        };
        /**
         * Returns true if this geometry includes the specified coordinate. If the
         * coordinate is on the boundary of the geometry, returns false.
         * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
         * @return {boolean} Contains coordinate.
         * @api
         */
        Geometry.prototype.intersectsCoordinate = function (coordinate) {
            return this.containsXY(coordinate[0], coordinate[1]);
        };
        /**
         * @abstract
         * @param {import("../extent.js").Extent} extent Extent.
         * @protected
         * @return {import("../extent.js").Extent} extent Extent.
         */
        Geometry.prototype.computeExtent = function (extent) {
            return abstract();
        };
        /**
         * Get the extent of the geometry.
         * @param {import("../extent.js").Extent=} opt_extent Extent.
         * @return {import("../extent.js").Extent} extent Extent.
         * @api
         */
        Geometry.prototype.getExtent = function (opt_extent) {
            if (this.extentRevision_ != this.getRevision()) {
                var extent = this.computeExtent(this.extent_);
                if (isNaN(extent[0]) || isNaN(extent[1])) {
                    createOrUpdateEmpty(extent);
                }
                this.extentRevision_ = this.getRevision();
            }
            return returnOrUpdate(this.extent_, opt_extent);
        };
        /**
         * Rotate the geometry around a given coordinate. This modifies the geometry
         * coordinates in place.
         * @abstract
         * @param {number} angle Rotation angle in radians.
         * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
         * @api
         */
        Geometry.prototype.rotate = function (angle, anchor) {
            abstract();
        };
        /**
         * Scale the geometry (with an optional origin).  This modifies the geometry
         * coordinates in place.
         * @abstract
         * @param {number} sx The scaling factor in the x-direction.
         * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).
         * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
         *     of the geometry extent).
         * @api
         */
        Geometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
            abstract();
        };
        /**
         * Create a simplified version of this geometry.  For linestrings, this uses
         * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
         * algorithm.  For polygons, a quantization-based
         * simplification is used to preserve topology.
         * @param {number} tolerance The tolerance distance for simplification.
         * @return {Geometry} A new, simplified version of the original geometry.
         * @api
         */
        Geometry.prototype.simplify = function (tolerance) {
            return this.getSimplifiedGeometry(tolerance * tolerance);
        };
        /**
         * Create a simplified version of this geometry using the Douglas Peucker
         * algorithm.
         * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
         * @abstract
         * @param {number} squaredTolerance Squared tolerance.
         * @return {Geometry} Simplified geometry.
         */
        Geometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
            return abstract();
        };
        /**
         * Get the type of this geometry.
         * @abstract
         * @return {import("./GeometryType.js").default} Geometry type.
         */
        Geometry.prototype.getType = function () {
            return abstract();
        };
        /**
         * Apply a transform function to the coordinates of the geometry.
         * The geometry is modified in place.
         * If you do not want the geometry modified in place, first `clone()` it and
         * then use this function on the clone.
         * @abstract
         * @param {import("../proj.js").TransformFunction} transformFn Transform function.
         * Called with a flat array of geometry coordinates.
         */
        Geometry.prototype.applyTransform = function (transformFn) {
            abstract();
        };
        /**
         * Test if the geometry and the passed extent intersect.
         * @abstract
         * @param {import("../extent.js").Extent} extent Extent.
         * @return {boolean} `true` if the geometry and the extent intersect.
         */
        Geometry.prototype.intersectsExtent = function (extent) {
            return abstract();
        };
        /**
         * Translate the geometry.  This modifies the geometry coordinates in place.  If
         * instead you want a new geometry, first `clone()` this geometry.
         * @abstract
         * @param {number} deltaX Delta X.
         * @param {number} deltaY Delta Y.
         * @api
         */
        Geometry.prototype.translate = function (deltaX, deltaY) {
            abstract();
        };
        /**
         * Transform each coordinate of the geometry from one coordinate reference
         * system to another. The geometry is modified in place.
         * For example, a line will be transformed to a line and a circle to a circle.
         * If you do not want the geometry modified in place, first `clone()` it and
         * then use this function on the clone.
         *
         * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
         *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
         * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
         *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
         * @return {Geometry} This geometry.  Note that original geometry is
         *     modified in place.
         * @api
         */
        Geometry.prototype.transform = function (source, destination) {
            /** @type {import("../proj/Projection.js").default} */
            var sourceProj = get$1(source);
            var transformFn = sourceProj.getUnits() == Units.TILE_PIXELS
                ? function (inCoordinates, outCoordinates, stride) {
                    var pixelExtent = sourceProj.getExtent();
                    var projectedExtent = sourceProj.getWorldExtent();
                    var scale = getHeight(projectedExtent) / getHeight(pixelExtent);
                    compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
                    transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
                    return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);
                }
                : getTransform(sourceProj, destination);
            this.applyTransform(transformFn);
            return this;
        };
        return Geometry;
    }(BaseObject));

    var __extends$1a = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Abstract base class; only used for creating subclasses; do not instantiate
     * in apps, as cannot be rendered.
     *
     * @abstract
     * @api
     */
    var SimpleGeometry = /** @class */ (function (_super) {
        __extends$1a(SimpleGeometry, _super);
        function SimpleGeometry() {
            var _this = _super.call(this) || this;
            /**
             * @protected
             * @type {import("./GeometryLayout.js").default}
             */
            _this.layout = GeometryLayout.XY;
            /**
             * @protected
             * @type {number}
             */
            _this.stride = 2;
            /**
             * @protected
             * @type {Array<number>}
             */
            _this.flatCoordinates = null;
            return _this;
        }
        /**
         * @param {import("../extent.js").Extent} extent Extent.
         * @protected
         * @return {import("../extent.js").Extent} extent Extent.
         */
        SimpleGeometry.prototype.computeExtent = function (extent) {
            return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
        };
        /**
         * @abstract
         * @return {Array<*>} Coordinates.
         */
        SimpleGeometry.prototype.getCoordinates = function () {
            return abstract();
        };
        /**
         * Return the first coordinate of the geometry.
         * @return {import("../coordinate.js").Coordinate} First coordinate.
         * @api
         */
        SimpleGeometry.prototype.getFirstCoordinate = function () {
            return this.flatCoordinates.slice(0, this.stride);
        };
        /**
         * @return {Array<number>} Flat coordinates.
         */
        SimpleGeometry.prototype.getFlatCoordinates = function () {
            return this.flatCoordinates;
        };
        /**
         * Return the last coordinate of the geometry.
         * @return {import("../coordinate.js").Coordinate} Last point.
         * @api
         */
        SimpleGeometry.prototype.getLastCoordinate = function () {
            return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
        };
        /**
         * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.
         * @return {import("./GeometryLayout.js").default} Layout.
         * @api
         */
        SimpleGeometry.prototype.getLayout = function () {
            return this.layout;
        };
        /**
         * Create a simplified version of this geometry using the Douglas Peucker algorithm.
         * @param {number} squaredTolerance Squared tolerance.
         * @return {SimpleGeometry} Simplified geometry.
         */
        SimpleGeometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
            if (this.simplifiedGeometryRevision !== this.getRevision()) {
                this.simplifiedGeometryMaxMinSquaredTolerance = 0;
                this.simplifiedGeometryRevision = this.getRevision();
            }
            // If squaredTolerance is negative or if we know that simplification will not
            // have any effect then just return this.
            if (squaredTolerance < 0 ||
                (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
                    squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {
                return this;
            }
            var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
            var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
            if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
                return simplifiedGeometry;
            }
            else {
                // Simplification did not actually remove any coordinates.  We now know
                // that any calls to getSimplifiedGeometry with a squaredTolerance less
                // than or equal to the current squaredTolerance will also not have any
                // effect.  This allows us to short circuit simplification (saving CPU
                // cycles) and prevents the cache of simplified geometries from filling
                // up with useless identical copies of this geometry (saving memory).
                this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
                return this;
            }
        };
        /**
         * @param {number} squaredTolerance Squared tolerance.
         * @return {SimpleGeometry} Simplified geometry.
         * @protected
         */
        SimpleGeometry.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
            return this;
        };
        /**
         * @return {number} Stride.
         */
        SimpleGeometry.prototype.getStride = function () {
            return this.stride;
        };
        /**
         * @param {import("./GeometryLayout.js").default} layout Layout.
         * @param {Array<number>} flatCoordinates Flat coordinates.
         */
        SimpleGeometry.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
            this.stride = getStrideForLayout(layout);
            this.layout = layout;
            this.flatCoordinates = flatCoordinates;
        };
        /**
         * @abstract
         * @param {!Array<*>} coordinates Coordinates.
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         */
        SimpleGeometry.prototype.setCoordinates = function (coordinates, opt_layout) {
            abstract();
        };
        /**
         * @param {import("./GeometryLayout.js").default|undefined} layout Layout.
         * @param {Array<*>} coordinates Coordinates.
         * @param {number} nesting Nesting.
         * @protected
         */
        SimpleGeometry.prototype.setLayout = function (layout, coordinates, nesting) {
            /** @type {number} */
            var stride;
            if (layout) {
                stride = getStrideForLayout(layout);
            }
            else {
                for (var i = 0; i < nesting; ++i) {
                    if (coordinates.length === 0) {
                        this.layout = GeometryLayout.XY;
                        this.stride = 2;
                        return;
                    }
                    else {
                        coordinates = /** @type {Array} */ (coordinates[0]);
                    }
                }
                stride = coordinates.length;
                layout = getLayoutForStride(stride);
            }
            this.layout = layout;
            this.stride = stride;
        };
        /**
         * Apply a transform function to the coordinates of the geometry.
         * The geometry is modified in place.
         * If you do not want the geometry modified in place, first `clone()` it and
         * then use this function on the clone.
         * @param {import("../proj.js").TransformFunction} transformFn Transform function.
         * Called with a flat array of geometry coordinates.
         * @api
         */
        SimpleGeometry.prototype.applyTransform = function (transformFn) {
            if (this.flatCoordinates) {
                transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
                this.changed();
            }
        };
        /**
         * Rotate the geometry around a given coordinate. This modifies the geometry
         * coordinates in place.
         * @param {number} angle Rotation angle in counter-clockwise radians.
         * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
         * @api
         */
        SimpleGeometry.prototype.rotate = function (angle, anchor) {
            var flatCoordinates = this.getFlatCoordinates();
            if (flatCoordinates) {
                var stride = this.getStride();
                rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
                this.changed();
            }
        };
        /**
         * Scale the geometry (with an optional origin).  This modifies the geometry
         * coordinates in place.
         * @param {number} sx The scaling factor in the x-direction.
         * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).
         * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
         *     of the geometry extent).
         * @api
         */
        SimpleGeometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
            var sy = opt_sy;
            if (sy === undefined) {
                sy = sx;
            }
            var anchor = opt_anchor;
            if (!anchor) {
                anchor = getCenter(this.getExtent());
            }
            var flatCoordinates = this.getFlatCoordinates();
            if (flatCoordinates) {
                var stride = this.getStride();
                scale$1(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
                this.changed();
            }
        };
        /**
         * Translate the geometry.  This modifies the geometry coordinates in place.  If
         * instead you want a new geometry, first `clone()` this geometry.
         * @param {number} deltaX Delta X.
         * @param {number} deltaY Delta Y.
         * @api
         */
        SimpleGeometry.prototype.translate = function (deltaX, deltaY) {
            var flatCoordinates = this.getFlatCoordinates();
            if (flatCoordinates) {
                var stride = this.getStride();
                translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
                this.changed();
            }
        };
        return SimpleGeometry;
    }(Geometry));
    /**
     * @param {number} stride Stride.
     * @return {import("./GeometryLayout.js").default} layout Layout.
     */
    function getLayoutForStride(stride) {
        var layout;
        if (stride == 2) {
            layout = GeometryLayout.XY;
        }
        else if (stride == 3) {
            layout = GeometryLayout.XYZ;
        }
        else if (stride == 4) {
            layout = GeometryLayout.XYZM;
        }
        return /** @type {import("./GeometryLayout.js").default} */ (layout);
    }
    /**
     * @param {import("./GeometryLayout.js").default} layout Layout.
     * @return {number} Stride.
     */
    function getStrideForLayout(layout) {
        var stride;
        if (layout == GeometryLayout.XY) {
            stride = 2;
        }
        else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {
            stride = 3;
        }
        else if (layout == GeometryLayout.XYZM) {
            stride = 4;
        }
        return /** @type {number} */ (stride);
    }
    /**
     * @param {SimpleGeometry} simpleGeometry Simple geometry.
     * @param {import("../transform.js").Transform} transform Transform.
     * @param {Array<number>=} opt_dest Destination.
     * @return {Array<number>} Transformed flat coordinates.
     */
    function transformGeom2D(simpleGeometry, transform, opt_dest) {
        var flatCoordinates = simpleGeometry.getFlatCoordinates();
        if (!flatCoordinates) {
            return null;
        }
        else {
            var stride = simpleGeometry.getStride();
            return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
        }
    }

    /**
     * @module ol/geom/flat/closest
     */
    /**
     * Returns the point on the 2D line segment flatCoordinates[offset1] to
     * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
     * dimensions are linearly interpolated.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset1 Offset 1.
     * @param {number} offset2 Offset 2.
     * @param {number} stride Stride.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {Array<number>} closestPoint Closest point.
     */
    function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
        var x1 = flatCoordinates[offset1];
        var y1 = flatCoordinates[offset1 + 1];
        var dx = flatCoordinates[offset2] - x1;
        var dy = flatCoordinates[offset2 + 1] - y1;
        var offset;
        if (dx === 0 && dy === 0) {
            offset = offset1;
        }
        else {
            var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
            if (t > 1) {
                offset = offset2;
            }
            else if (t > 0) {
                for (var i = 0; i < stride; ++i) {
                    closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
                }
                closestPoint.length = stride;
                return;
            }
            else {
                offset = offset1;
            }
        }
        for (var i = 0; i < stride; ++i) {
            closestPoint[i] = flatCoordinates[offset + i];
        }
        closestPoint.length = stride;
    }
    /**
     * Return the squared of the largest distance between any pair of consecutive
     * coordinates.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} max Max squared delta.
     * @return {number} Max squared delta.
     */
    function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
        var x1 = flatCoordinates[offset];
        var y1 = flatCoordinates[offset + 1];
        for (offset += stride; offset < end; offset += stride) {
            var x2 = flatCoordinates[offset];
            var y2 = flatCoordinates[offset + 1];
            var squaredDelta = squaredDistance(x1, y1, x2, y2);
            if (squaredDelta > max) {
                max = squaredDelta;
            }
            x1 = x2;
            y1 = y2;
        }
        return max;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {number} max Max squared delta.
     * @return {number} Max squared delta.
     */
    function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
            offset = end;
        }
        return max;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<Array<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {number} max Max squared delta.
     * @return {number} Max squared delta.
     */
    function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
        for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
            offset = ends[ends.length - 1];
        }
        return max;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} maxDelta Max delta.
     * @param {boolean} isRing Is ring.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {Array<number>} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @param {Array<number>=} opt_tmpPoint Temporary point object.
     * @return {number} Minimum squared distance.
     */
    function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
        if (offset == end) {
            return minSquaredDistance;
        }
        var i, squaredDistance$1;
        if (maxDelta === 0) {
            // All points are identical, so just test the first point.
            squaredDistance$1 = squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
            if (squaredDistance$1 < minSquaredDistance) {
                for (i = 0; i < stride; ++i) {
                    closestPoint[i] = flatCoordinates[offset + i];
                }
                closestPoint.length = stride;
                return squaredDistance$1;
            }
            else {
                return minSquaredDistance;
            }
        }
        var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
        var index = offset + stride;
        while (index < end) {
            assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
            squaredDistance$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
            if (squaredDistance$1 < minSquaredDistance) {
                minSquaredDistance = squaredDistance$1;
                for (i = 0; i < stride; ++i) {
                    closestPoint[i] = tmpPoint[i];
                }
                closestPoint.length = stride;
                index += stride;
            }
            else {
                // Skip ahead multiple points, because we know that all the skipped
                // points cannot be any closer than the closest point we have found so
                // far.  We know this because we know how close the current point is, how
                // close the closest point we have found so far is, and the maximum
                // distance between consecutive points.  For example, if we're currently
                // at distance 10, the best we've found so far is 3, and that the maximum
                // distance between consecutive points is 2, then we'll need to skip at
                // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
                // finding a closer point.  We use Math.max(..., 1) to ensure that we
                // always advance at least one point, to avoid an infinite loop.
                index +=
                    stride *
                        Math.max(((Math.sqrt(squaredDistance$1) - Math.sqrt(minSquaredDistance)) /
                            maxDelta) |
                            0, 1);
            }
        }
        if (isRing) {
            // Check the closing segment.
            assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
            squaredDistance$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
            if (squaredDistance$1 < minSquaredDistance) {
                minSquaredDistance = squaredDistance$1;
                for (i = 0; i < stride; ++i) {
                    closestPoint[i] = tmpPoint[i];
                }
                closestPoint.length = stride;
            }
        }
        return minSquaredDistance;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {number} maxDelta Max delta.
     * @param {boolean} isRing Is ring.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {Array<number>} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @param {Array<number>=} opt_tmpPoint Temporary point object.
     * @return {number} Minimum squared distance.
     */
    function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
        var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
            offset = end;
        }
        return minSquaredDistance;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<Array<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {number} maxDelta Max delta.
     * @param {boolean} isRing Is ring.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {Array<number>} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @param {Array<number>=} opt_tmpPoint Temporary point object.
     * @return {number} Minimum squared distance.
     */
    function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
        var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
        for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
            offset = ends[ends.length - 1];
        }
        return minSquaredDistance;
    }

    /**
     * @module ol/geom/flat/deflate
     */
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} stride Stride.
     * @return {number} offset Offset.
     */
    function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
        for (var i = 0, ii = coordinate.length; i < ii; ++i) {
            flatCoordinates[offset++] = coordinate[i];
        }
        return offset;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {number} stride Stride.
     * @return {number} offset Offset.
     */
    function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
        for (var i = 0, ii = coordinates.length; i < ii; ++i) {
            var coordinate = coordinates[i];
            for (var j = 0; j < stride; ++j) {
                flatCoordinates[offset++] = coordinate[j];
            }
        }
        return offset;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
     * @param {number} stride Stride.
     * @param {Array<number>=} opt_ends Ends.
     * @return {Array<number>} Ends.
     */
    function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
        var ends = opt_ends ? opt_ends : [];
        var i = 0;
        for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
            var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
            ends[i++] = end;
            offset = end;
        }
        ends.length = i;
        return ends;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
     * @param {number} stride Stride.
     * @param {Array<Array<number>>=} opt_endss Endss.
     * @return {Array<Array<number>>} Endss.
     */
    function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
        var endss = opt_endss ? opt_endss : [];
        var i = 0;
        for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
            var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
            endss[i++] = ends;
            offset = ends[ends.length - 1];
        }
        endss.length = i;
        return endss;
    }

    /**
     * @module ol/geom/flat/simplify
     */
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
     *     coordinates.
     * @param {number} simplifiedOffset Simplified offset.
     * @return {number} Simplified offset.
     */
    function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
        var n = (end - offset) / stride;
        if (n < 3) {
            for (; offset < end; offset += stride) {
                simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
                simplifiedFlatCoordinates[simplifiedOffset++] =
                    flatCoordinates[offset + 1];
            }
            return simplifiedOffset;
        }
        /** @type {Array<number>} */
        var markers = new Array(n);
        markers[0] = 1;
        markers[n - 1] = 1;
        /** @type {Array<number>} */
        var stack = [offset, end - stride];
        var index = 0;
        while (stack.length > 0) {
            var last = stack.pop();
            var first = stack.pop();
            var maxSquaredDistance = 0;
            var x1 = flatCoordinates[first];
            var y1 = flatCoordinates[first + 1];
            var x2 = flatCoordinates[last];
            var y2 = flatCoordinates[last + 1];
            for (var i = first + stride; i < last; i += stride) {
                var x = flatCoordinates[i];
                var y = flatCoordinates[i + 1];
                var squaredDistance_1 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
                if (squaredDistance_1 > maxSquaredDistance) {
                    index = i;
                    maxSquaredDistance = squaredDistance_1;
                }
            }
            if (maxSquaredDistance > squaredTolerance) {
                markers[(index - offset) / stride] = 1;
                if (first + stride < index) {
                    stack.push(first, index);
                }
                if (index + stride < last) {
                    stack.push(index, last);
                }
            }
        }
        for (var i = 0; i < n; ++i) {
            if (markers[i]) {
                simplifiedFlatCoordinates[simplifiedOffset++] =
                    flatCoordinates[offset + i * stride];
                simplifiedFlatCoordinates[simplifiedOffset++] =
                    flatCoordinates[offset + i * stride + 1];
            }
        }
        return simplifiedOffset;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
     *     coordinates.
     * @param {number} simplifiedOffset Simplified offset.
     * @param {Array<number>} simplifiedEnds Simplified ends.
     * @return {number} Simplified offset.
     */
    function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
            simplifiedEnds.push(simplifiedOffset);
            offset = end;
        }
        return simplifiedOffset;
    }
    /**
     * @param {number} value Value.
     * @param {number} tolerance Tolerance.
     * @return {number} Rounded value.
     */
    function snap(value, tolerance) {
        return tolerance * Math.round(value / tolerance);
    }
    /**
     * Simplifies a line string using an algorithm designed by Tim Schaub.
     * Coordinates are snapped to the nearest value in a virtual grid and
     * consecutive duplicate coordinates are discarded.  This effectively preserves
     * topology as the simplification of any subsection of a line string is
     * independent of the rest of the line string.  This means that, for examples,
     * the common edge between two polygons will be simplified to the same line
     * string independently in both polygons.  This implementation uses a single
     * pass over the coordinates and eliminates intermediate collinear points.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} tolerance Tolerance.
     * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
     *     coordinates.
     * @param {number} simplifiedOffset Simplified offset.
     * @return {number} Simplified offset.
     */
    function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
        // do nothing if the line is empty
        if (offset == end) {
            return simplifiedOffset;
        }
        // snap the first coordinate (P1)
        var x1 = snap(flatCoordinates[offset], tolerance);
        var y1 = snap(flatCoordinates[offset + 1], tolerance);
        offset += stride;
        // add the first coordinate to the output
        simplifiedFlatCoordinates[simplifiedOffset++] = x1;
        simplifiedFlatCoordinates[simplifiedOffset++] = y1;
        // find the next coordinate that does not snap to the same value as the first
        // coordinate (P2)
        var x2, y2;
        do {
            x2 = snap(flatCoordinates[offset], tolerance);
            y2 = snap(flatCoordinates[offset + 1], tolerance);
            offset += stride;
            if (offset == end) {
                // all coordinates snap to the same value, the line collapses to a point
                // push the last snapped value anyway to ensure that the output contains
                // at least two points
                // FIXME should we really return at least two points anyway?
                simplifiedFlatCoordinates[simplifiedOffset++] = x2;
                simplifiedFlatCoordinates[simplifiedOffset++] = y2;
                return simplifiedOffset;
            }
        } while (x2 == x1 && y2 == y1);
        while (offset < end) {
            // snap the next coordinate (P3)
            var x3 = snap(flatCoordinates[offset], tolerance);
            var y3 = snap(flatCoordinates[offset + 1], tolerance);
            offset += stride;
            // skip P3 if it is equal to P2
            if (x3 == x2 && y3 == y2) {
                continue;
            }
            // calculate the delta between P1 and P2
            var dx1 = x2 - x1;
            var dy1 = y2 - y1;
            // calculate the delta between P3 and P1
            var dx2 = x3 - x1;
            var dy2 = y3 - y1;
            // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
            // P1 in the same direction then P2 is on the straight line between P1 and
            // P3
            if (dx1 * dy2 == dy1 * dx2 &&
                ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&
                ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {
                // discard P2 and set P2 = P3
                x2 = x3;
                y2 = y3;
                continue;
            }
            // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
            // between P3 and P1 or on the opposite half of the line to P2.  add P2,
            // and continue with P1 = P2 and P2 = P3
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            x1 = x2;
            y1 = y2;
            x2 = x3;
            y2 = y3;
        }
        // add the last point (P2)
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
        return simplifiedOffset;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {number} tolerance Tolerance.
     * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
     *     coordinates.
     * @param {number} simplifiedOffset Simplified offset.
     * @param {Array<number>} simplifiedEnds Simplified ends.
     * @return {number} Simplified offset.
     */
    function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
            simplifiedEnds.push(simplifiedOffset);
            offset = end;
        }
        return simplifiedOffset;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<Array<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {number} tolerance Tolerance.
     * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
     *     coordinates.
     * @param {number} simplifiedOffset Simplified offset.
     * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
     * @return {number} Simplified offset.
     */
    function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
        for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            var simplifiedEnds = [];
            simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
            simplifiedEndss.push(simplifiedEnds);
            offset = ends[ends.length - 1];
        }
        return simplifiedOffset;
    }

    /**
     * @module ol/geom/flat/segments
     */
    /**
     * This function calls `callback` for each segment of the flat coordinates
     * array. If the callback returns a truthy value the function returns that
     * value immediately. Otherwise the function returns `false`.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
     *     called for each segment.
     * @return {T|boolean} Value.
     * @template T
     */
    function forEach$1(flatCoordinates, offset, end, stride, callback) {
        var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
        var point2 = [];
        var ret;
        for (; offset + stride < end; offset += stride) {
            point2[0] = flatCoordinates[offset + stride];
            point2[1] = flatCoordinates[offset + stride + 1];
            ret = callback(point1, point2);
            if (ret) {
                return ret;
            }
            point1[0] = point2[0];
            point1[1] = point2[1];
        }
        return false;
    }

    /**
     * @module ol/geom/flat/inflate
     */
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {Array<import("../../coordinate.js").Coordinate>=} opt_coordinates Coordinates.
     * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
     */
    function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
        var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
        var i = 0;
        for (var j = offset; j < end; j += stride) {
            coordinates[i++] = flatCoordinates.slice(j, j + stride);
        }
        coordinates.length = i;
        return coordinates;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Array<Array<import("../../coordinate.js").Coordinate>>=} opt_coordinatess Coordinatess.
     * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
     */
    function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
        var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
        var i = 0;
        for (var j = 0, jj = ends.length; j < jj; ++j) {
            var end = ends[j];
            coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
            offset = end;
        }
        coordinatess.length = i;
        return coordinatess;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<Array<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>=} opt_coordinatesss
     *     Coordinatesss.
     * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
     */
    function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
        var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
        var i = 0;
        for (var j = 0, jj = endss.length; j < jj; ++j) {
            var ends = endss[j];
            coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
            offset = ends[ends.length - 1];
        }
        coordinatesss.length = i;
        return coordinatesss;
    }

    /**
     * @module ol/geom/flat/interpolate
     */
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} fraction Fraction.
     * @param {Array<number>=} opt_dest Destination.
     * @param {number=} opt_dimension Destination dimension (default is `2`)
     * @return {Array<number>} Destination.
     */
    function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {
        var o, t;
        var n = (end - offset) / stride;
        if (n === 1) {
            o = offset;
        }
        else if (n === 2) {
            o = offset;
            t = fraction;
        }
        else if (n !== 0) {
            var x1 = flatCoordinates[offset];
            var y1 = flatCoordinates[offset + 1];
            var length_1 = 0;
            var cumulativeLengths = [0];
            for (var i = offset + stride; i < end; i += stride) {
                var x2 = flatCoordinates[i];
                var y2 = flatCoordinates[i + 1];
                length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                cumulativeLengths.push(length_1);
                x1 = x2;
                y1 = y2;
            }
            var target = fraction * length_1;
            var index = binarySearch(cumulativeLengths, target);
            if (index < 0) {
                t =
                    (target - cumulativeLengths[-index - 2]) /
                        (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
                o = offset + (-index - 2) * stride;
            }
            else {
                o = offset + index * stride;
            }
        }
        var dimension = opt_dimension > 1 ? opt_dimension : 2;
        var dest = opt_dest ? opt_dest : new Array(dimension);
        for (var i = 0; i < dimension; ++i) {
            dest[i] =
                o === undefined
                    ? NaN
                    : t === undefined
                        ? flatCoordinates[o + i]
                        : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
        }
        return dest;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} m M.
     * @param {boolean} extrapolate Extrapolate.
     * @return {import("../../coordinate.js").Coordinate} Coordinate.
     */
    function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
        if (end == offset) {
            return null;
        }
        var coordinate;
        if (m < flatCoordinates[offset + stride - 1]) {
            if (extrapolate) {
                coordinate = flatCoordinates.slice(offset, offset + stride);
                coordinate[stride - 1] = m;
                return coordinate;
            }
            else {
                return null;
            }
        }
        else if (flatCoordinates[end - 1] < m) {
            if (extrapolate) {
                coordinate = flatCoordinates.slice(end - stride, end);
                coordinate[stride - 1] = m;
                return coordinate;
            }
            else {
                return null;
            }
        }
        // FIXME use O(1) search
        if (m == flatCoordinates[offset + stride - 1]) {
            return flatCoordinates.slice(offset, offset + stride);
        }
        var lo = offset / stride;
        var hi = end / stride;
        while (lo < hi) {
            var mid = (lo + hi) >> 1;
            if (m < flatCoordinates[(mid + 1) * stride - 1]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        var m0 = flatCoordinates[lo * stride - 1];
        if (m == m0) {
            return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
        }
        var m1 = flatCoordinates[(lo + 1) * stride - 1];
        var t = (m - m0) / (m1 - m0);
        coordinate = [];
        for (var i = 0; i < stride - 1; ++i) {
            coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
        }
        coordinate.push(m);
        return coordinate;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {number} m M.
     * @param {boolean} extrapolate Extrapolate.
     * @param {boolean} interpolate Interpolate.
     * @return {import("../../coordinate.js").Coordinate} Coordinate.
     */
    function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
        if (interpolate) {
            return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
        }
        var coordinate;
        if (m < flatCoordinates[stride - 1]) {
            if (extrapolate) {
                coordinate = flatCoordinates.slice(0, stride);
                coordinate[stride - 1] = m;
                return coordinate;
            }
            else {
                return null;
            }
        }
        if (flatCoordinates[flatCoordinates.length - 1] < m) {
            if (extrapolate) {
                coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
                coordinate[stride - 1] = m;
                return coordinate;
            }
            else {
                return null;
            }
        }
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            if (offset == end) {
                continue;
            }
            if (m < flatCoordinates[offset + stride - 1]) {
                return null;
            }
            else if (m <= flatCoordinates[end - 1]) {
                return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
            }
            offset = end;
        }
        return null;
    }

    /**
     * @module ol/geom/flat/contains
     */
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @return {boolean} Contains extent.
     */
    function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
        var outside = forEachCorner(extent, 
        /**
         * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
         * @return {boolean} Contains (x, y).
         */
        function (coordinate) {
            return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
        });
        return !outside;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
        // http://geomalgorithms.com/a03-_inclusion.html
        // Copyright 2000 softSurfer, 2012 Dan Sunday
        // This code may be freely used and modified for any purpose
        // providing that this copyright notice is included with it.
        // SoftSurfer makes no warranty for this code, and cannot be held
        // liable for any real or imagined damage resulting from its use.
        // Users of this code must verify correctness for their application.
        var wn = 0;
        var x1 = flatCoordinates[end - stride];
        var y1 = flatCoordinates[end - stride + 1];
        for (; offset < end; offset += stride) {
            var x2 = flatCoordinates[offset];
            var y2 = flatCoordinates[offset + 1];
            if (y1 <= y) {
                if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
                    wn++;
                }
            }
            else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
                wn--;
            }
            x1 = x2;
            y1 = y2;
        }
        return wn !== 0;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
        if (ends.length === 0) {
            return false;
        }
        if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
            return false;
        }
        for (var i = 1, ii = ends.length; i < ii; ++i) {
            if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
                return false;
            }
        }
        return true;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<Array<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
        if (endss.length === 0) {
            return false;
        }
        for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
                return true;
            }
            offset = ends[ends.length - 1];
        }
        return false;
    }

    /**
     * @module ol/geom/flat/intersectsextent
     */
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @return {boolean} True if the geometry and the extent intersect.
     */
    function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
        var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);
        if (!intersects(extent, coordinatesExtent)) {
            return false;
        }
        if (containsExtent(extent, coordinatesExtent)) {
            return true;
        }
        if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
            return true;
        }
        if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
            return true;
        }
        return forEach$1(flatCoordinates, offset, end, stride, 
        /**
         * @param {import("../../coordinate.js").Coordinate} point1 Start point.
         * @param {import("../../coordinate.js").Coordinate} point2 End point.
         * @return {boolean} `true` if the segment and the extent intersect,
         *     `false` otherwise.
         */
        function (point1, point2) {
            return intersectsSegment(extent, point1, point2);
        });
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @return {boolean} True if the geometry and the extent intersect.
     */
    function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
                return true;
            }
            offset = ends[i];
        }
        return false;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @return {boolean} True if the geometry and the extent intersect.
     */
    function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
        if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
            return true;
        }
        if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
            return true;
        }
        if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
            return true;
        }
        if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
            return true;
        }
        if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
            return true;
        }
        return false;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @return {boolean} True if the geometry and the extent intersect.
     */
    function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
        if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
            return false;
        }
        if (ends.length === 1) {
            return true;
        }
        for (var i = 1, ii = ends.length; i < ii; ++i) {
            if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
                if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<Array<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @return {boolean} True if the geometry and the extent intersect.
     */
    function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
        for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
                return true;
            }
            offset = ends[ends.length - 1];
        }
        return false;
    }

    /**
     * @module ol/geom/flat/length
     */
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @return {number} Length.
     */
    function lineStringLength(flatCoordinates, offset, end, stride) {
        var x1 = flatCoordinates[offset];
        var y1 = flatCoordinates[offset + 1];
        var length = 0;
        for (var i = offset + stride; i < end; i += stride) {
            var x2 = flatCoordinates[i];
            var y2 = flatCoordinates[i + 1];
            length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            x1 = x2;
            y1 = y2;
        }
        return length;
    }

    var __extends$19 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Linestring geometry.
     *
     * @api
     */
    var LineString = /** @class */ (function (_super) {
        __extends$19(LineString, _super);
        /**
         * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
         *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         */
        function LineString(coordinates, opt_layout) {
            var _this = _super.call(this) || this;
            /**
             * @private
             * @type {import("../coordinate.js").Coordinate}
             */
            _this.flatMidpoint_ = null;
            /**
             * @private
             * @type {number}
             */
            _this.flatMidpointRevision_ = -1;
            /**
             * @private
             * @type {number}
             */
            _this.maxDelta_ = -1;
            /**
             * @private
             * @type {number}
             */
            _this.maxDeltaRevision_ = -1;
            if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
                _this.setFlatCoordinates(opt_layout, 
                /** @type {Array<number>} */ (coordinates));
            }
            else {
                _this.setCoordinates(
                /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
            }
            return _this;
        }
        /**
         * Append the passed coordinate to the coordinates of the linestring.
         * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
         * @api
         */
        LineString.prototype.appendCoordinate = function (coordinate) {
            if (!this.flatCoordinates) {
                this.flatCoordinates = coordinate.slice();
            }
            else {
                extend$2(this.flatCoordinates, coordinate);
            }
            this.changed();
        };
        /**
         * Make a complete copy of the geometry.
         * @return {!LineString} Clone.
         * @api
         */
        LineString.prototype.clone = function () {
            var lineString = new LineString(this.flatCoordinates.slice(), this.layout);
            lineString.applyProperties(this);
            return lineString;
        };
        /**
         * @param {number} x X.
         * @param {number} y Y.
         * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
         * @param {number} minSquaredDistance Minimum squared distance.
         * @return {number} Minimum squared distance.
         */
        LineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                return minSquaredDistance;
            }
            if (this.maxDeltaRevision_ != this.getRevision()) {
                this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
                this.maxDeltaRevision_ = this.getRevision();
            }
            return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
        };
        /**
         * Iterate over each segment, calling the provided callback.
         * If the callback returns a truthy value the function returns that
         * value immediately. Otherwise the function returns `false`.
         *
         * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
         *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
         * @return {T|boolean} Value.
         * @template T,S
         * @api
         */
        LineString.prototype.forEachSegment = function (callback) {
            return forEach$1(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
        };
        /**
         * Returns the coordinate at `m` using linear interpolation, or `null` if no
         * such coordinate exists.
         *
         * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
         * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
         * M will return the first coordinate and Ms greater than the last M will
         * return the last coordinate.
         *
         * @param {number} m M.
         * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
         * @return {import("../coordinate.js").Coordinate} Coordinate.
         * @api
         */
        LineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {
            if (this.layout != GeometryLayout.XYM &&
                this.layout != GeometryLayout.XYZM) {
                return null;
            }
            var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
            return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
        };
        /**
         * Return the coordinates of the linestring.
         * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
         * @api
         */
        LineString.prototype.getCoordinates = function () {
            return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        };
        /**
         * Return the coordinate at the provided fraction along the linestring.
         * The `fraction` is a number between 0 and 1, where 0 is the start of the
         * linestring and 1 is the end.
         * @param {number} fraction Fraction.
         * @param {import("../coordinate.js").Coordinate=} opt_dest Optional coordinate whose values will
         *     be modified. If not provided, a new coordinate will be returned.
         * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
         * @api
         */
        LineString.prototype.getCoordinateAt = function (fraction, opt_dest) {
            return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);
        };
        /**
         * Return the length of the linestring on projected plane.
         * @return {number} Length (on projected plane).
         * @api
         */
        LineString.prototype.getLength = function () {
            return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        };
        /**
         * @return {Array<number>} Flat midpoint.
         */
        LineString.prototype.getFlatMidpoint = function () {
            if (this.flatMidpointRevision_ != this.getRevision()) {
                this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
                this.flatMidpointRevision_ = this.getRevision();
            }
            return this.flatMidpoint_;
        };
        /**
         * @param {number} squaredTolerance Squared tolerance.
         * @return {LineString} Simplified LineString.
         * @protected
         */
        LineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
            var simplifiedFlatCoordinates = [];
            simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
            return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);
        };
        /**
         * Get the type of this geometry.
         * @return {import("./GeometryType.js").default} Geometry type.
         * @api
         */
        LineString.prototype.getType = function () {
            return GeometryType.LINE_STRING;
        };
        /**
         * Test if the geometry and the passed extent intersect.
         * @param {import("../extent.js").Extent} extent Extent.
         * @return {boolean} `true` if the geometry and the extent intersect.
         * @api
         */
        LineString.prototype.intersectsExtent = function (extent) {
            return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
        };
        /**
         * Set the coordinates of the linestring.
         * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         * @api
         */
        LineString.prototype.setCoordinates = function (coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 1);
            if (!this.flatCoordinates) {
                this.flatCoordinates = [];
            }
            this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
            this.changed();
        };
        return LineString;
    }(SimpleGeometry));

    /**
     * @module ol/geom/flat/area
     */
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @return {number} Area.
     */
    function linearRing(flatCoordinates, offset, end, stride) {
        var twiceArea = 0;
        var x1 = flatCoordinates[end - stride];
        var y1 = flatCoordinates[end - stride + 1];
        for (; offset < end; offset += stride) {
            var x2 = flatCoordinates[offset];
            var y2 = flatCoordinates[offset + 1];
            twiceArea += y1 * x2 - x1 * y2;
            x1 = x2;
            y1 = y2;
        }
        return twiceArea / 2;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @return {number} Area.
     */
    function linearRings(flatCoordinates, offset, ends, stride) {
        var area = 0;
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            area += linearRing(flatCoordinates, offset, end, stride);
            offset = end;
        }
        return area;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<Array<number>>} endss Endss.
     * @param {number} stride Stride.
     * @return {number} Area.
     */
    function linearRingss$1(flatCoordinates, offset, endss, stride) {
        var area = 0;
        for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            area += linearRings(flatCoordinates, offset, ends, stride);
            offset = ends[ends.length - 1];
        }
        return area;
    }

    var __extends$18 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Linear ring geometry. Only used as part of polygon; cannot be rendered
     * on its own.
     *
     * @api
     */
    var LinearRing = /** @class */ (function (_super) {
        __extends$18(LinearRing, _super);
        /**
         * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
         *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         */
        function LinearRing(coordinates, opt_layout) {
            var _this = _super.call(this) || this;
            /**
             * @private
             * @type {number}
             */
            _this.maxDelta_ = -1;
            /**
             * @private
             * @type {number}
             */
            _this.maxDeltaRevision_ = -1;
            if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
                _this.setFlatCoordinates(opt_layout, 
                /** @type {Array<number>} */ (coordinates));
            }
            else {
                _this.setCoordinates(
                /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
            }
            return _this;
        }
        /**
         * Make a complete copy of the geometry.
         * @return {!LinearRing} Clone.
         * @api
         */
        LinearRing.prototype.clone = function () {
            return new LinearRing(this.flatCoordinates.slice(), this.layout);
        };
        /**
         * @param {number} x X.
         * @param {number} y Y.
         * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
         * @param {number} minSquaredDistance Minimum squared distance.
         * @return {number} Minimum squared distance.
         */
        LinearRing.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                return minSquaredDistance;
            }
            if (this.maxDeltaRevision_ != this.getRevision()) {
                this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
                this.maxDeltaRevision_ = this.getRevision();
            }
            return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
        };
        /**
         * Return the area of the linear ring on projected plane.
         * @return {number} Area (on projected plane).
         * @api
         */
        LinearRing.prototype.getArea = function () {
            return linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        };
        /**
         * Return the coordinates of the linear ring.
         * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
         * @api
         */
        LinearRing.prototype.getCoordinates = function () {
            return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        };
        /**
         * @param {number} squaredTolerance Squared tolerance.
         * @return {LinearRing} Simplified LinearRing.
         * @protected
         */
        LinearRing.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
            var simplifiedFlatCoordinates = [];
            simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
            return new LinearRing(simplifiedFlatCoordinates, GeometryLayout.XY);
        };
        /**
         * Get the type of this geometry.
         * @return {import("./GeometryType.js").default} Geometry type.
         * @api
         */
        LinearRing.prototype.getType = function () {
            return GeometryType.LINEAR_RING;
        };
        /**
         * Test if the geometry and the passed extent intersect.
         * @param {import("../extent.js").Extent} extent Extent.
         * @return {boolean} `true` if the geometry and the extent intersect.
         * @api
         */
        LinearRing.prototype.intersectsExtent = function (extent) {
            return false;
        };
        /**
         * Set the coordinates of the linear ring.
         * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         * @api
         */
        LinearRing.prototype.setCoordinates = function (coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 1);
            if (!this.flatCoordinates) {
                this.flatCoordinates = [];
            }
            this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
            this.changed();
        };
        return LinearRing;
    }(SimpleGeometry));

    var __extends$17 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Multi-linestring geometry.
     *
     * @api
     */
    var MultiLineString = /** @class */ (function (_super) {
        __extends$17(MultiLineString, _super);
        /**
         * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
         *     Coordinates or LineString geometries. (For internal use, flat coordinates in
         *     combination with `opt_layout` and `opt_ends` are also accepted.)
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         * @param {Array<number>=} opt_ends Flat coordinate ends for internal use.
         */
        function MultiLineString(coordinates, opt_layout, opt_ends) {
            var _this = _super.call(this) || this;
            /**
             * @type {Array<number>}
             * @private
             */
            _this.ends_ = [];
            /**
             * @private
             * @type {number}
             */
            _this.maxDelta_ = -1;
            /**
             * @private
             * @type {number}
             */
            _this.maxDeltaRevision_ = -1;
            if (Array.isArray(coordinates[0])) {
                _this.setCoordinates(
                /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
            }
            else if (opt_layout !== undefined && opt_ends) {
                _this.setFlatCoordinates(opt_layout, 
                /** @type {Array<number>} */ (coordinates));
                _this.ends_ = opt_ends;
            }
            else {
                var layout = _this.getLayout();
                var lineStrings = /** @type {Array<LineString>} */ (coordinates);
                var flatCoordinates = [];
                var ends = [];
                for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
                    var lineString = lineStrings[i];
                    if (i === 0) {
                        layout = lineString.getLayout();
                    }
                    extend$2(flatCoordinates, lineString.getFlatCoordinates());
                    ends.push(flatCoordinates.length);
                }
                _this.setFlatCoordinates(layout, flatCoordinates);
                _this.ends_ = ends;
            }
            return _this;
        }
        /**
         * Append the passed linestring to the multilinestring.
         * @param {LineString} lineString LineString.
         * @api
         */
        MultiLineString.prototype.appendLineString = function (lineString) {
            if (!this.flatCoordinates) {
                this.flatCoordinates = lineString.getFlatCoordinates().slice();
            }
            else {
                extend$2(this.flatCoordinates, lineString.getFlatCoordinates().slice());
            }
            this.ends_.push(this.flatCoordinates.length);
            this.changed();
        };
        /**
         * Make a complete copy of the geometry.
         * @return {!MultiLineString} Clone.
         * @api
         */
        MultiLineString.prototype.clone = function () {
            var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
            multiLineString.applyProperties(this);
            return multiLineString;
        };
        /**
         * @param {number} x X.
         * @param {number} y Y.
         * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
         * @param {number} minSquaredDistance Minimum squared distance.
         * @return {number} Minimum squared distance.
         */
        MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                return minSquaredDistance;
            }
            if (this.maxDeltaRevision_ != this.getRevision()) {
                this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
                this.maxDeltaRevision_ = this.getRevision();
            }
            return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
        };
        /**
         * Returns the coordinate at `m` using linear interpolation, or `null` if no
         * such coordinate exists.
         *
         * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
         * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
         * M will return the first coordinate and Ms greater than the last M will
         * return the last coordinate.
         *
         * `opt_interpolate` controls interpolation between consecutive LineStrings
         * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
         * will be linearly interpolated between the last coordinate of one LineString
         * and the first coordinate of the next LineString.  If `opt_interpolate` is
         * `false` then the function will return `null` for Ms falling between
         * LineStrings.
         *
         * @param {number} m M.
         * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
         * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
         * @return {import("../coordinate.js").Coordinate} Coordinate.
         * @api
         */
        MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {
            if ((this.layout != GeometryLayout.XYM &&
                this.layout != GeometryLayout.XYZM) ||
                this.flatCoordinates.length === 0) {
                return null;
            }
            var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
            var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
            return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
        };
        /**
         * Return the coordinates of the multilinestring.
         * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
         * @api
         */
        MultiLineString.prototype.getCoordinates = function () {
            return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);
        };
        /**
         * @return {Array<number>} Ends.
         */
        MultiLineString.prototype.getEnds = function () {
            return this.ends_;
        };
        /**
         * Return the linestring at the specified index.
         * @param {number} index Index.
         * @return {LineString} LineString.
         * @api
         */
        MultiLineString.prototype.getLineString = function (index) {
            if (index < 0 || this.ends_.length <= index) {
                return null;
            }
            return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
        };
        /**
         * Return the linestrings of this multilinestring.
         * @return {Array<LineString>} LineStrings.
         * @api
         */
        MultiLineString.prototype.getLineStrings = function () {
            var flatCoordinates = this.flatCoordinates;
            var ends = this.ends_;
            var layout = this.layout;
            /** @type {Array<LineString>} */
            var lineStrings = [];
            var offset = 0;
            for (var i = 0, ii = ends.length; i < ii; ++i) {
                var end = ends[i];
                var lineString = new LineString(flatCoordinates.slice(offset, end), layout);
                lineStrings.push(lineString);
                offset = end;
            }
            return lineStrings;
        };
        /**
         * @return {Array<number>} Flat midpoints.
         */
        MultiLineString.prototype.getFlatMidpoints = function () {
            var midpoints = [];
            var flatCoordinates = this.flatCoordinates;
            var offset = 0;
            var ends = this.ends_;
            var stride = this.stride;
            for (var i = 0, ii = ends.length; i < ii; ++i) {
                var end = ends[i];
                var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);
                extend$2(midpoints, midpoint);
                offset = end;
            }
            return midpoints;
        };
        /**
         * @param {number} squaredTolerance Squared tolerance.
         * @return {MultiLineString} Simplified MultiLineString.
         * @protected
         */
        MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
            var simplifiedFlatCoordinates = [];
            var simplifiedEnds = [];
            simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
            return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
        };
        /**
         * Get the type of this geometry.
         * @return {import("./GeometryType.js").default} Geometry type.
         * @api
         */
        MultiLineString.prototype.getType = function () {
            return GeometryType.MULTI_LINE_STRING;
        };
        /**
         * Test if the geometry and the passed extent intersect.
         * @param {import("../extent.js").Extent} extent Extent.
         * @return {boolean} `true` if the geometry and the extent intersect.
         * @api
         */
        MultiLineString.prototype.intersectsExtent = function (extent) {
            return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);
        };
        /**
         * Set the coordinates of the multilinestring.
         * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
         * @param {GeometryLayout=} opt_layout Layout.
         * @api
         */
        MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 2);
            if (!this.flatCoordinates) {
                this.flatCoordinates = [];
            }
            var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
            this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
            this.changed();
        };
        return MultiLineString;
    }(SimpleGeometry));

    var __extends$16 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Point geometry.
     *
     * @api
     */
    var Point = /** @class */ (function (_super) {
        __extends$16(Point, _super);
        /**
         * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         */
        function Point(coordinates, opt_layout) {
            var _this = _super.call(this) || this;
            _this.setCoordinates(coordinates, opt_layout);
            return _this;
        }
        /**
         * Make a complete copy of the geometry.
         * @return {!Point} Clone.
         * @api
         */
        Point.prototype.clone = function () {
            var point = new Point(this.flatCoordinates.slice(), this.layout);
            point.applyProperties(this);
            return point;
        };
        /**
         * @param {number} x X.
         * @param {number} y Y.
         * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
         * @param {number} minSquaredDistance Minimum squared distance.
         * @return {number} Minimum squared distance.
         */
        Point.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
            var flatCoordinates = this.flatCoordinates;
            var squaredDistance$1 = squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);
            if (squaredDistance$1 < minSquaredDistance) {
                var stride = this.stride;
                for (var i = 0; i < stride; ++i) {
                    closestPoint[i] = flatCoordinates[i];
                }
                closestPoint.length = stride;
                return squaredDistance$1;
            }
            else {
                return minSquaredDistance;
            }
        };
        /**
         * Return the coordinate of the point.
         * @return {import("../coordinate.js").Coordinate} Coordinates.
         * @api
         */
        Point.prototype.getCoordinates = function () {
            return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
        };
        /**
         * @param {import("../extent.js").Extent} extent Extent.
         * @protected
         * @return {import("../extent.js").Extent} extent Extent.
         */
        Point.prototype.computeExtent = function (extent) {
            return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
        };
        /**
         * Get the type of this geometry.
         * @return {import("./GeometryType.js").default} Geometry type.
         * @api
         */
        Point.prototype.getType = function () {
            return GeometryType.POINT;
        };
        /**
         * Test if the geometry and the passed extent intersect.
         * @param {import("../extent.js").Extent} extent Extent.
         * @return {boolean} `true` if the geometry and the extent intersect.
         * @api
         */
        Point.prototype.intersectsExtent = function (extent) {
            return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
        };
        /**
         * @param {!Array<*>} coordinates Coordinates.
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         * @api
         */
        Point.prototype.setCoordinates = function (coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 0);
            if (!this.flatCoordinates) {
                this.flatCoordinates = [];
            }
            this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);
            this.changed();
        };
        return Point;
    }(SimpleGeometry));

    var __extends$15 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Multi-point geometry.
     *
     * @api
     */
    var MultiPoint = /** @class */ (function (_super) {
        __extends$15(MultiPoint, _super);
        /**
         * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
         *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         */
        function MultiPoint(coordinates, opt_layout) {
            var _this = _super.call(this) || this;
            if (opt_layout && !Array.isArray(coordinates[0])) {
                _this.setFlatCoordinates(opt_layout, 
                /** @type {Array<number>} */ (coordinates));
            }
            else {
                _this.setCoordinates(
                /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
            }
            return _this;
        }
        /**
         * Append the passed point to this multipoint.
         * @param {Point} point Point.
         * @api
         */
        MultiPoint.prototype.appendPoint = function (point) {
            if (!this.flatCoordinates) {
                this.flatCoordinates = point.getFlatCoordinates().slice();
            }
            else {
                extend$2(this.flatCoordinates, point.getFlatCoordinates());
            }
            this.changed();
        };
        /**
         * Make a complete copy of the geometry.
         * @return {!MultiPoint} Clone.
         * @api
         */
        MultiPoint.prototype.clone = function () {
            var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
            multiPoint.applyProperties(this);
            return multiPoint;
        };
        /**
         * @param {number} x X.
         * @param {number} y Y.
         * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
         * @param {number} minSquaredDistance Minimum squared distance.
         * @return {number} Minimum squared distance.
         */
        MultiPoint.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                return minSquaredDistance;
            }
            var flatCoordinates = this.flatCoordinates;
            var stride = this.stride;
            for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
                var squaredDistance$1 = squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
                if (squaredDistance$1 < minSquaredDistance) {
                    minSquaredDistance = squaredDistance$1;
                    for (var j = 0; j < stride; ++j) {
                        closestPoint[j] = flatCoordinates[i + j];
                    }
                    closestPoint.length = stride;
                }
            }
            return minSquaredDistance;
        };
        /**
         * Return the coordinates of the multipoint.
         * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
         * @api
         */
        MultiPoint.prototype.getCoordinates = function () {
            return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        };
        /**
         * Return the point at the specified index.
         * @param {number} index Index.
         * @return {Point} Point.
         * @api
         */
        MultiPoint.prototype.getPoint = function (index) {
            var n = !this.flatCoordinates
                ? 0
                : this.flatCoordinates.length / this.stride;
            if (index < 0 || n <= index) {
                return null;
            }
            return new Point(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
        };
        /**
         * Return the points of this multipoint.
         * @return {Array<Point>} Points.
         * @api
         */
        MultiPoint.prototype.getPoints = function () {
            var flatCoordinates = this.flatCoordinates;
            var layout = this.layout;
            var stride = this.stride;
            /** @type {Array<Point>} */
            var points = [];
            for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
                var point = new Point(flatCoordinates.slice(i, i + stride), layout);
                points.push(point);
            }
            return points;
        };
        /**
         * Get the type of this geometry.
         * @return {import("./GeometryType.js").default} Geometry type.
         * @api
         */
        MultiPoint.prototype.getType = function () {
            return GeometryType.MULTI_POINT;
        };
        /**
         * Test if the geometry and the passed extent intersect.
         * @param {import("../extent.js").Extent} extent Extent.
         * @return {boolean} `true` if the geometry and the extent intersect.
         * @api
         */
        MultiPoint.prototype.intersectsExtent = function (extent) {
            var flatCoordinates = this.flatCoordinates;
            var stride = this.stride;
            for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
                var x = flatCoordinates[i];
                var y = flatCoordinates[i + 1];
                if (containsXY(extent, x, y)) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Set the coordinates of the multipoint.
         * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         * @api
         */
        MultiPoint.prototype.setCoordinates = function (coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 1);
            if (!this.flatCoordinates) {
                this.flatCoordinates = [];
            }
            this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
            this.changed();
        };
        return MultiPoint;
    }(SimpleGeometry));

    /**
     * @module ol/geom/flat/interiorpoint
     */
    /**
     * Calculates a point that is likely to lie in the interior of the linear rings.
     * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Array<number>} flatCenters Flat centers.
     * @param {number} flatCentersOffset Flat center offset.
     * @param {Array<number>=} opt_dest Destination.
     * @return {Array<number>} Destination point as XYM coordinate, where M is the
     * length of the horizontal intersection that the point belongs to.
     */
    function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
        var i, ii, x, x1, x2, y1, y2;
        var y = flatCenters[flatCentersOffset + 1];
        /** @type {Array<number>} */
        var intersections = [];
        // Calculate intersections with the horizontal line
        for (var r = 0, rr = ends.length; r < rr; ++r) {
            var end = ends[r];
            x1 = flatCoordinates[end - stride];
            y1 = flatCoordinates[end - stride + 1];
            for (i = offset; i < end; i += stride) {
                x2 = flatCoordinates[i];
                y2 = flatCoordinates[i + 1];
                if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
                    x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;
                    intersections.push(x);
                }
                x1 = x2;
                y1 = y2;
            }
        }
        // Find the longest segment of the horizontal line that has its center point
        // inside the linear ring.
        var pointX = NaN;
        var maxSegmentLength = -Infinity;
        intersections.sort(numberSafeCompareFunction);
        x1 = intersections[0];
        for (i = 1, ii = intersections.length; i < ii; ++i) {
            x2 = intersections[i];
            var segmentLength = Math.abs(x2 - x1);
            if (segmentLength > maxSegmentLength) {
                x = (x1 + x2) / 2;
                if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
                    pointX = x;
                    maxSegmentLength = segmentLength;
                }
            }
            x1 = x2;
        }
        if (isNaN(pointX)) {
            // There is no horizontal line that has its center point inside the linear
            // ring.  Use the center of the the linear ring's extent.
            pointX = flatCenters[flatCentersOffset];
        }
        if (opt_dest) {
            opt_dest.push(pointX, y, maxSegmentLength);
            return opt_dest;
        }
        else {
            return [pointX, y, maxSegmentLength];
        }
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<Array<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {Array<number>} flatCenters Flat centers.
     * @return {Array<number>} Interior points as XYM coordinates, where M is the
     * length of the horizontal intersection that the point belongs to.
     */
    function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
        var interiorPoints = [];
        for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
            offset = ends[ends.length - 1];
        }
        return interiorPoints;
    }

    /**
     * @module ol/geom/flat/reverse
     */
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     */
    function coordinates(flatCoordinates, offset, end, stride) {
        while (offset < end - stride) {
            for (var i = 0; i < stride; ++i) {
                var tmp = flatCoordinates[offset + i];
                flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
                flatCoordinates[end - stride + i] = tmp;
            }
            offset += stride;
            end -= stride;
        }
    }

    /**
     * @module ol/geom/flat/orient
     */
    /**
     * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
     * coordinate origin? For a coordinate system with a top-left coordinate origin,
     * the ring's orientation is clockwise when this function returns false.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @return {boolean} Is clockwise.
     */
    function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
        // http://tinyurl.com/clockwise-method
        // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp
        var edge = 0;
        var x1 = flatCoordinates[end - stride];
        var y1 = flatCoordinates[end - stride + 1];
        for (; offset < end; offset += stride) {
            var x2 = flatCoordinates[offset];
            var y2 = flatCoordinates[offset + 1];
            edge += (x2 - x1) * (y2 + y1);
            x1 = x2;
            y1 = y2;
        }
        return edge === 0 ? undefined : edge > 0;
    }
    /**
     * Determines if linear rings are oriented.  By default, left-hand orientation
     * is tested (first ring must be clockwise, remaining rings counter-clockwise).
     * To test for right-hand orientation, use the `opt_right` argument.
     *
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Array of end indexes.
     * @param {number} stride Stride.
     * @param {boolean=} opt_right Test for right-hand orientation
     *     (counter-clockwise exterior ring and clockwise interior rings).
     * @return {boolean} Rings are correctly oriented.
     */
    function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {
        var right = opt_right !== undefined ? opt_right : false;
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
            if (i === 0) {
                if ((right && isClockwise) || (!right && !isClockwise)) {
                    return false;
                }
            }
            else {
                if ((right && !isClockwise) || (!right && isClockwise)) {
                    return false;
                }
            }
            offset = end;
        }
        return true;
    }
    /**
     * Determines if linear rings are oriented.  By default, left-hand orientation
     * is tested (first ring must be clockwise, remaining rings counter-clockwise).
     * To test for right-hand orientation, use the `opt_right` argument.
     *
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<Array<number>>} endss Array of array of end indexes.
     * @param {number} stride Stride.
     * @param {boolean=} opt_right Test for right-hand orientation
     *     (counter-clockwise exterior ring and clockwise interior rings).
     * @return {boolean} Rings are correctly oriented.
     */
    function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
        for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {
                return false;
            }
            if (ends.length) {
                offset = ends[ends.length - 1];
            }
        }
        return true;
    }
    /**
     * Orient coordinates in a flat array of linear rings.  By default, rings
     * are oriented following the left-hand rule (clockwise for exterior and
     * counter-clockwise for interior rings).  To orient according to the
     * right-hand rule, use the `opt_right` argument.
     *
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {boolean=} opt_right Follow the right-hand rule for orientation.
     * @return {number} End.
     */
    function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
        var right = opt_right !== undefined ? opt_right : false;
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
            var reverse = i === 0
                ? (right && isClockwise) || (!right && !isClockwise)
                : (right && !isClockwise) || (!right && isClockwise);
            if (reverse) {
                coordinates(flatCoordinates, offset, end, stride);
            }
            offset = end;
        }
        return offset;
    }
    /**
     * Orient coordinates in a flat array of linear rings.  By default, rings
     * are oriented following the left-hand rule (clockwise for exterior and
     * counter-clockwise for interior rings).  To orient according to the
     * right-hand rule, use the `opt_right` argument.
     *
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<Array<number>>} endss Array of array of end indexes.
     * @param {number} stride Stride.
     * @param {boolean=} opt_right Follow the right-hand rule for orientation.
     * @return {number} End.
     */
    function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
        for (var i = 0, ii = endss.length; i < ii; ++i) {
            offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
        }
        return offset;
    }

    var __extends$14 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Polygon geometry.
     *
     * @api
     */
    var Polygon = /** @class */ (function (_super) {
        __extends$14(Polygon, _super);
        /**
         * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
         *     Array of linear rings that define the polygon. The first linear ring of the
         *     array defines the outer-boundary or surface of the polygon. Each subsequent
         *     linear ring defines a hole in the surface of the polygon. A linear ring is
         *     an array of vertices' coordinates where the first coordinate and the last are
         *     equivalent. (For internal use, flat coordinates in combination with
         *     `opt_layout` and `opt_ends` are also accepted.)
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         * @param {Array<number>=} opt_ends Ends (for internal use with flat coordinates).
         */
        function Polygon(coordinates, opt_layout, opt_ends) {
            var _this = _super.call(this) || this;
            /**
             * @type {Array<number>}
             * @private
             */
            _this.ends_ = [];
            /**
             * @private
             * @type {number}
             */
            _this.flatInteriorPointRevision_ = -1;
            /**
             * @private
             * @type {import("../coordinate.js").Coordinate}
             */
            _this.flatInteriorPoint_ = null;
            /**
             * @private
             * @type {number}
             */
            _this.maxDelta_ = -1;
            /**
             * @private
             * @type {number}
             */
            _this.maxDeltaRevision_ = -1;
            /**
             * @private
             * @type {number}
             */
            _this.orientedRevision_ = -1;
            /**
             * @private
             * @type {Array<number>}
             */
            _this.orientedFlatCoordinates_ = null;
            if (opt_layout !== undefined && opt_ends) {
                _this.setFlatCoordinates(opt_layout, 
                /** @type {Array<number>} */ (coordinates));
                _this.ends_ = opt_ends;
            }
            else {
                _this.setCoordinates(
                /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
            }
            return _this;
        }
        /**
         * Append the passed linear ring to this polygon.
         * @param {LinearRing} linearRing Linear ring.
         * @api
         */
        Polygon.prototype.appendLinearRing = function (linearRing) {
            if (!this.flatCoordinates) {
                this.flatCoordinates = linearRing.getFlatCoordinates().slice();
            }
            else {
                extend$2(this.flatCoordinates, linearRing.getFlatCoordinates());
            }
            this.ends_.push(this.flatCoordinates.length);
            this.changed();
        };
        /**
         * Make a complete copy of the geometry.
         * @return {!Polygon} Clone.
         * @api
         */
        Polygon.prototype.clone = function () {
            var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
            polygon.applyProperties(this);
            return polygon;
        };
        /**
         * @param {number} x X.
         * @param {number} y Y.
         * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
         * @param {number} minSquaredDistance Minimum squared distance.
         * @return {number} Minimum squared distance.
         */
        Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                return minSquaredDistance;
            }
            if (this.maxDeltaRevision_ != this.getRevision()) {
                this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
                this.maxDeltaRevision_ = this.getRevision();
            }
            return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
        };
        /**
         * @param {number} x X.
         * @param {number} y Y.
         * @return {boolean} Contains (x, y).
         */
        Polygon.prototype.containsXY = function (x, y) {
            return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
        };
        /**
         * Return the area of the polygon on projected plane.
         * @return {number} Area (on projected plane).
         * @api
         */
        Polygon.prototype.getArea = function () {
            return linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
        };
        /**
         * Get the coordinate array for this geometry.  This array has the structure
         * of a GeoJSON coordinate array for polygons.
         *
         * @param {boolean=} opt_right Orient coordinates according to the right-hand
         *     rule (counter-clockwise for exterior and clockwise for interior rings).
         *     If `false`, coordinates will be oriented according to the left-hand rule
         *     (clockwise for exterior and counter-clockwise for interior rings).
         *     By default, coordinate orientation will depend on how the geometry was
         *     constructed.
         * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
         * @api
         */
        Polygon.prototype.getCoordinates = function (opt_right) {
            var flatCoordinates;
            if (opt_right !== undefined) {
                flatCoordinates = this.getOrientedFlatCoordinates().slice();
                orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
            }
            else {
                flatCoordinates = this.flatCoordinates;
            }
            return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
        };
        /**
         * @return {Array<number>} Ends.
         */
        Polygon.prototype.getEnds = function () {
            return this.ends_;
        };
        /**
         * @return {Array<number>} Interior point.
         */
        Polygon.prototype.getFlatInteriorPoint = function () {
            if (this.flatInteriorPointRevision_ != this.getRevision()) {
                var flatCenter = getCenter(this.getExtent());
                this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
                this.flatInteriorPointRevision_ = this.getRevision();
            }
            return this.flatInteriorPoint_;
        };
        /**
         * Return an interior point of the polygon.
         * @return {Point} Interior point as XYM coordinate, where M is the
         * length of the horizontal intersection that the point belongs to.
         * @api
         */
        Polygon.prototype.getInteriorPoint = function () {
            return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);
        };
        /**
         * Return the number of rings of the polygon,  this includes the exterior
         * ring and any interior rings.
         *
         * @return {number} Number of rings.
         * @api
         */
        Polygon.prototype.getLinearRingCount = function () {
            return this.ends_.length;
        };
        /**
         * Return the Nth linear ring of the polygon geometry. Return `null` if the
         * given index is out of range.
         * The exterior linear ring is available at index `0` and the interior rings
         * at index `1` and beyond.
         *
         * @param {number} index Index.
         * @return {LinearRing} Linear ring.
         * @api
         */
        Polygon.prototype.getLinearRing = function (index) {
            if (index < 0 || this.ends_.length <= index) {
                return null;
            }
            return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
        };
        /**
         * Return the linear rings of the polygon.
         * @return {Array<LinearRing>} Linear rings.
         * @api
         */
        Polygon.prototype.getLinearRings = function () {
            var layout = this.layout;
            var flatCoordinates = this.flatCoordinates;
            var ends = this.ends_;
            var linearRings = [];
            var offset = 0;
            for (var i = 0, ii = ends.length; i < ii; ++i) {
                var end = ends[i];
                var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);
                linearRings.push(linearRing);
                offset = end;
            }
            return linearRings;
        };
        /**
         * @return {Array<number>} Oriented flat coordinates.
         */
        Polygon.prototype.getOrientedFlatCoordinates = function () {
            if (this.orientedRevision_ != this.getRevision()) {
                var flatCoordinates = this.flatCoordinates;
                if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
                    this.orientedFlatCoordinates_ = flatCoordinates;
                }
                else {
                    this.orientedFlatCoordinates_ = flatCoordinates.slice();
                    this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
                }
                this.orientedRevision_ = this.getRevision();
            }
            return this.orientedFlatCoordinates_;
        };
        /**
         * @param {number} squaredTolerance Squared tolerance.
         * @return {Polygon} Simplified Polygon.
         * @protected
         */
        Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
            var simplifiedFlatCoordinates = [];
            var simplifiedEnds = [];
            simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
            return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
        };
        /**
         * Get the type of this geometry.
         * @return {import("./GeometryType.js").default} Geometry type.
         * @api
         */
        Polygon.prototype.getType = function () {
            return GeometryType.POLYGON;
        };
        /**
         * Test if the geometry and the passed extent intersect.
         * @param {import("../extent.js").Extent} extent Extent.
         * @return {boolean} `true` if the geometry and the extent intersect.
         * @api
         */
        Polygon.prototype.intersectsExtent = function (extent) {
            return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
        };
        /**
         * Set the coordinates of the polygon.
         * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         * @api
         */
        Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 2);
            if (!this.flatCoordinates) {
                this.flatCoordinates = [];
            }
            var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
            this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
            this.changed();
        };
        return Polygon;
    }(SimpleGeometry));
    /**
     * Create a polygon from an extent. The layout used is `XY`.
     * @param {import("../extent.js").Extent} extent The extent.
     * @return {Polygon} The polygon.
     * @api
     */
    function fromExtent(extent) {
        var minX = extent[0];
        var minY = extent[1];
        var maxX = extent[2];
        var maxY = extent[3];
        var flatCoordinates = [
            minX,
            minY,
            minX,
            maxY,
            maxX,
            maxY,
            maxX,
            minY,
            minX,
            minY,
        ];
        return new Polygon(flatCoordinates, GeometryLayout.XY, [
            flatCoordinates.length,
        ]);
    }

    /**
     * @module ol/geom/flat/center
     */
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<Array<number>>} endss Endss.
     * @param {number} stride Stride.
     * @return {Array<number>} Flat centers.
     */
    function linearRingss(flatCoordinates, offset, endss, stride) {
        var flatCenters = [];
        var extent = createEmpty();
        for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);
            flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
            offset = ends[ends.length - 1];
        }
        return flatCenters;
    }

    var __extends$13 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Multi-polygon geometry.
     *
     * @api
     */
    var MultiPolygon = /** @class */ (function (_super) {
        __extends$13(MultiPolygon, _super);
        /**
         * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
         *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         * @param {Array<Array<number>>=} opt_endss Array of ends for internal use with flat coordinates.
         */
        function MultiPolygon(coordinates, opt_layout, opt_endss) {
            var _this = _super.call(this) || this;
            /**
             * @type {Array<Array<number>>}
             * @private
             */
            _this.endss_ = [];
            /**
             * @private
             * @type {number}
             */
            _this.flatInteriorPointsRevision_ = -1;
            /**
             * @private
             * @type {Array<number>}
             */
            _this.flatInteriorPoints_ = null;
            /**
             * @private
             * @type {number}
             */
            _this.maxDelta_ = -1;
            /**
             * @private
             * @type {number}
             */
            _this.maxDeltaRevision_ = -1;
            /**
             * @private
             * @type {number}
             */
            _this.orientedRevision_ = -1;
            /**
             * @private
             * @type {Array<number>}
             */
            _this.orientedFlatCoordinates_ = null;
            if (!opt_endss && !Array.isArray(coordinates[0])) {
                var layout = _this.getLayout();
                var polygons = /** @type {Array<Polygon>} */ (coordinates);
                var flatCoordinates = [];
                var endss = [];
                for (var i = 0, ii = polygons.length; i < ii; ++i) {
                    var polygon = polygons[i];
                    if (i === 0) {
                        layout = polygon.getLayout();
                    }
                    var offset = flatCoordinates.length;
                    var ends = polygon.getEnds();
                    for (var j = 0, jj = ends.length; j < jj; ++j) {
                        ends[j] += offset;
                    }
                    extend$2(flatCoordinates, polygon.getFlatCoordinates());
                    endss.push(ends);
                }
                opt_layout = layout;
                coordinates = flatCoordinates;
                opt_endss = endss;
            }
            if (opt_layout !== undefined && opt_endss) {
                _this.setFlatCoordinates(opt_layout, 
                /** @type {Array<number>} */ (coordinates));
                _this.endss_ = opt_endss;
            }
            else {
                _this.setCoordinates(
                /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */ (coordinates), opt_layout);
            }
            return _this;
        }
        /**
         * Append the passed polygon to this multipolygon.
         * @param {Polygon} polygon Polygon.
         * @api
         */
        MultiPolygon.prototype.appendPolygon = function (polygon) {
            /** @type {Array<number>} */
            var ends;
            if (!this.flatCoordinates) {
                this.flatCoordinates = polygon.getFlatCoordinates().slice();
                ends = polygon.getEnds().slice();
                this.endss_.push();
            }
            else {
                var offset = this.flatCoordinates.length;
                extend$2(this.flatCoordinates, polygon.getFlatCoordinates());
                ends = polygon.getEnds().slice();
                for (var i = 0, ii = ends.length; i < ii; ++i) {
                    ends[i] += offset;
                }
            }
            this.endss_.push(ends);
            this.changed();
        };
        /**
         * Make a complete copy of the geometry.
         * @return {!MultiPolygon} Clone.
         * @api
         */
        MultiPolygon.prototype.clone = function () {
            var len = this.endss_.length;
            var newEndss = new Array(len);
            for (var i = 0; i < len; ++i) {
                newEndss[i] = this.endss_[i].slice();
            }
            var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
            multiPolygon.applyProperties(this);
            return multiPolygon;
        };
        /**
         * @param {number} x X.
         * @param {number} y Y.
         * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
         * @param {number} minSquaredDistance Minimum squared distance.
         * @return {number} Minimum squared distance.
         */
        MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                return minSquaredDistance;
            }
            if (this.maxDeltaRevision_ != this.getRevision()) {
                this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
                this.maxDeltaRevision_ = this.getRevision();
            }
            return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
        };
        /**
         * @param {number} x X.
         * @param {number} y Y.
         * @return {boolean} Contains (x, y).
         */
        MultiPolygon.prototype.containsXY = function (x, y) {
            return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
        };
        /**
         * Return the area of the multipolygon on projected plane.
         * @return {number} Area (on projected plane).
         * @api
         */
        MultiPolygon.prototype.getArea = function () {
            return linearRingss$1(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
        };
        /**
         * Get the coordinate array for this geometry.  This array has the structure
         * of a GeoJSON coordinate array for multi-polygons.
         *
         * @param {boolean=} opt_right Orient coordinates according to the right-hand
         *     rule (counter-clockwise for exterior and clockwise for interior rings).
         *     If `false`, coordinates will be oriented according to the left-hand rule
         *     (clockwise for exterior and counter-clockwise for interior rings).
         *     By default, coordinate orientation will depend on how the geometry was
         *     constructed.
         * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
         * @api
         */
        MultiPolygon.prototype.getCoordinates = function (opt_right) {
            var flatCoordinates;
            if (opt_right !== undefined) {
                flatCoordinates = this.getOrientedFlatCoordinates().slice();
                orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);
            }
            else {
                flatCoordinates = this.flatCoordinates;
            }
            return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);
        };
        /**
         * @return {Array<Array<number>>} Endss.
         */
        MultiPolygon.prototype.getEndss = function () {
            return this.endss_;
        };
        /**
         * @return {Array<number>} Flat interior points.
         */
        MultiPolygon.prototype.getFlatInteriorPoints = function () {
            if (this.flatInteriorPointsRevision_ != this.getRevision()) {
                var flatCenters = linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);
                this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
                this.flatInteriorPointsRevision_ = this.getRevision();
            }
            return this.flatInteriorPoints_;
        };
        /**
         * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.
         * @return {MultiPoint} Interior points as XYM coordinates, where M is
         * the length of the horizontal intersection that the point belongs to.
         * @api
         */
        MultiPolygon.prototype.getInteriorPoints = function () {
            return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);
        };
        /**
         * @return {Array<number>} Oriented flat coordinates.
         */
        MultiPolygon.prototype.getOrientedFlatCoordinates = function () {
            if (this.orientedRevision_ != this.getRevision()) {
                var flatCoordinates = this.flatCoordinates;
                if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
                    this.orientedFlatCoordinates_ = flatCoordinates;
                }
                else {
                    this.orientedFlatCoordinates_ = flatCoordinates.slice();
                    this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
                }
                this.orientedRevision_ = this.getRevision();
            }
            return this.orientedFlatCoordinates_;
        };
        /**
         * @param {number} squaredTolerance Squared tolerance.
         * @return {MultiPolygon} Simplified MultiPolygon.
         * @protected
         */
        MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
            var simplifiedFlatCoordinates = [];
            var simplifiedEndss = [];
            simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
            return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);
        };
        /**
         * Return the polygon at the specified index.
         * @param {number} index Index.
         * @return {Polygon} Polygon.
         * @api
         */
        MultiPolygon.prototype.getPolygon = function (index) {
            if (index < 0 || this.endss_.length <= index) {
                return null;
            }
            var offset;
            if (index === 0) {
                offset = 0;
            }
            else {
                var prevEnds = this.endss_[index - 1];
                offset = prevEnds[prevEnds.length - 1];
            }
            var ends = this.endss_[index].slice();
            var end = ends[ends.length - 1];
            if (offset !== 0) {
                for (var i = 0, ii = ends.length; i < ii; ++i) {
                    ends[i] -= offset;
                }
            }
            return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);
        };
        /**
         * Return the polygons of this multipolygon.
         * @return {Array<Polygon>} Polygons.
         * @api
         */
        MultiPolygon.prototype.getPolygons = function () {
            var layout = this.layout;
            var flatCoordinates = this.flatCoordinates;
            var endss = this.endss_;
            var polygons = [];
            var offset = 0;
            for (var i = 0, ii = endss.length; i < ii; ++i) {
                var ends = endss[i].slice();
                var end = ends[ends.length - 1];
                if (offset !== 0) {
                    for (var j = 0, jj = ends.length; j < jj; ++j) {
                        ends[j] -= offset;
                    }
                }
                var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);
                polygons.push(polygon);
                offset = end;
            }
            return polygons;
        };
        /**
         * Get the type of this geometry.
         * @return {import("./GeometryType.js").default} Geometry type.
         * @api
         */
        MultiPolygon.prototype.getType = function () {
            return GeometryType.MULTI_POLYGON;
        };
        /**
         * Test if the geometry and the passed extent intersect.
         * @param {import("../extent.js").Extent} extent Extent.
         * @return {boolean} `true` if the geometry and the extent intersect.
         * @api
         */
        MultiPolygon.prototype.intersectsExtent = function (extent) {
            return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
        };
        /**
         * Set the coordinates of the multipolygon.
         * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
         * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
         * @api
         */
        MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 3);
            if (!this.flatCoordinates) {
                this.flatCoordinates = [];
            }
            var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
            if (endss.length === 0) {
                this.flatCoordinates.length = 0;
            }
            else {
                var lastEnds = endss[endss.length - 1];
                this.flatCoordinates.length =
                    lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
            }
            this.changed();
        };
        return MultiPolygon;
    }(SimpleGeometry));

    var __extends$12 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * An array of {@link module:ol/geom/Geometry} objects.
     *
     * @api
     */
    var GeometryCollection = /** @class */ (function (_super) {
        __extends$12(GeometryCollection, _super);
        /**
         * @param {Array<Geometry>=} opt_geometries Geometries.
         */
        function GeometryCollection(opt_geometries) {
            var _this = _super.call(this) || this;
            /**
             * @private
             * @type {Array<Geometry>}
             */
            _this.geometries_ = opt_geometries ? opt_geometries : null;
            /**
             * @type {Array<import("../events.js").EventsKey>}
             */
            _this.changeEventsKeys_ = [];
            _this.listenGeometriesChange_();
            return _this;
        }
        /**
         * @private
         */
        GeometryCollection.prototype.unlistenGeometriesChange_ = function () {
            this.changeEventsKeys_.forEach(unlistenByKey);
            this.changeEventsKeys_.length = 0;
        };
        /**
         * @private
         */
        GeometryCollection.prototype.listenGeometriesChange_ = function () {
            if (!this.geometries_) {
                return;
            }
            for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {
                this.changeEventsKeys_.push(listen(this.geometries_[i], EventType.CHANGE, this.changed, this));
            }
        };
        /**
         * Make a complete copy of the geometry.
         * @return {!GeometryCollection} Clone.
         * @api
         */
        GeometryCollection.prototype.clone = function () {
            var geometryCollection = new GeometryCollection(null);
            geometryCollection.setGeometries(this.geometries_);
            geometryCollection.applyProperties(this);
            return geometryCollection;
        };
        /**
         * @param {number} x X.
         * @param {number} y Y.
         * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
         * @param {number} minSquaredDistance Minimum squared distance.
         * @return {number} Minimum squared distance.
         */
        GeometryCollection.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                return minSquaredDistance;
            }
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
                minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
            }
            return minSquaredDistance;
        };
        /**
         * @param {number} x X.
         * @param {number} y Y.
         * @return {boolean} Contains (x, y).
         */
        GeometryCollection.prototype.containsXY = function (x, y) {
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
                if (geometries[i].containsXY(x, y)) {
                    return true;
                }
            }
            return false;
        };
        /**
         * @param {import("../extent.js").Extent} extent Extent.
         * @protected
         * @return {import("../extent.js").Extent} extent Extent.
         */
        GeometryCollection.prototype.computeExtent = function (extent) {
            createOrUpdateEmpty(extent);
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
                extend$1(extent, geometries[i].getExtent());
            }
            return extent;
        };
        /**
         * Return the geometries that make up this geometry collection.
         * @return {Array<Geometry>} Geometries.
         * @api
         */
        GeometryCollection.prototype.getGeometries = function () {
            return cloneGeometries(this.geometries_);
        };
        /**
         * @return {Array<Geometry>} Geometries.
         */
        GeometryCollection.prototype.getGeometriesArray = function () {
            return this.geometries_;
        };
        /**
         * @return {Array<Geometry>} Geometries.
         */
        GeometryCollection.prototype.getGeometriesArrayRecursive = function () {
            /** @type {Array<Geometry>} */
            var geometriesArray = [];
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
                if (geometries[i].getType() === this.getType()) {
                    geometriesArray = geometriesArray.concat(
                    /** @type {GeometryCollection} */ (geometries[i]).getGeometriesArrayRecursive());
                }
                else {
                    geometriesArray.push(geometries[i]);
                }
            }
            return geometriesArray;
        };
        /**
         * Create a simplified version of this geometry using the Douglas Peucker algorithm.
         * @param {number} squaredTolerance Squared tolerance.
         * @return {GeometryCollection} Simplified GeometryCollection.
         */
        GeometryCollection.prototype.getSimplifiedGeometry = function (squaredTolerance) {
            if (this.simplifiedGeometryRevision !== this.getRevision()) {
                this.simplifiedGeometryMaxMinSquaredTolerance = 0;
                this.simplifiedGeometryRevision = this.getRevision();
            }
            if (squaredTolerance < 0 ||
                (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
                    squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)) {
                return this;
            }
            var simplifiedGeometries = [];
            var geometries = this.geometries_;
            var simplified = false;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
                var geometry = geometries[i];
                var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
                simplifiedGeometries.push(simplifiedGeometry);
                if (simplifiedGeometry !== geometry) {
                    simplified = true;
                }
            }
            if (simplified) {
                var simplifiedGeometryCollection = new GeometryCollection(null);
                simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
                return simplifiedGeometryCollection;
            }
            else {
                this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
                return this;
            }
        };
        /**
         * Get the type of this geometry.
         * @return {import("./GeometryType.js").default} Geometry type.
         * @api
         */
        GeometryCollection.prototype.getType = function () {
            return GeometryType.GEOMETRY_COLLECTION;
        };
        /**
         * Test if the geometry and the passed extent intersect.
         * @param {import("../extent.js").Extent} extent Extent.
         * @return {boolean} `true` if the geometry and the extent intersect.
         * @api
         */
        GeometryCollection.prototype.intersectsExtent = function (extent) {
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
                if (geometries[i].intersectsExtent(extent)) {
                    return true;
                }
            }
            return false;
        };
        /**
         * @return {boolean} Is empty.
         */
        GeometryCollection.prototype.isEmpty = function () {
            return this.geometries_.length === 0;
        };
        /**
         * Rotate the geometry around a given coordinate. This modifies the geometry
         * coordinates in place.
         * @param {number} angle Rotation angle in radians.
         * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
         * @api
         */
        GeometryCollection.prototype.rotate = function (angle, anchor) {
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
                geometries[i].rotate(angle, anchor);
            }
            this.changed();
        };
        /**
         * Scale the geometry (with an optional origin).  This modifies the geometry
         * coordinates in place.
         * @abstract
         * @param {number} sx The scaling factor in the x-direction.
         * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).
         * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
         *     of the geometry extent).
         * @api
         */
        GeometryCollection.prototype.scale = function (sx, opt_sy, opt_anchor) {
            var anchor = opt_anchor;
            if (!anchor) {
                anchor = getCenter(this.getExtent());
            }
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
                geometries[i].scale(sx, opt_sy, anchor);
            }
            this.changed();
        };
        /**
         * Set the geometries that make up this geometry collection.
         * @param {Array<Geometry>} geometries Geometries.
         * @api
         */
        GeometryCollection.prototype.setGeometries = function (geometries) {
            this.setGeometriesArray(cloneGeometries(geometries));
        };
        /**
         * @param {Array<Geometry>} geometries Geometries.
         */
        GeometryCollection.prototype.setGeometriesArray = function (geometries) {
            this.unlistenGeometriesChange_();
            this.geometries_ = geometries;
            this.listenGeometriesChange_();
            this.changed();
        };
        /**
         * Apply a transform function to the coordinates of the geometry.
         * The geometry is modified in place.
         * If you do not want the geometry modified in place, first `clone()` it and
         * then use this function on the clone.
         * @param {import("../proj.js").TransformFunction} transformFn Transform function.
         * Called with a flat array of geometry coordinates.
         * @api
         */
        GeometryCollection.prototype.applyTransform = function (transformFn) {
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
                geometries[i].applyTransform(transformFn);
            }
            this.changed();
        };
        /**
         * Translate the geometry.  This modifies the geometry coordinates in place.  If
         * instead you want a new geometry, first `clone()` this geometry.
         * @param {number} deltaX Delta X.
         * @param {number} deltaY Delta Y.
         * @api
         */
        GeometryCollection.prototype.translate = function (deltaX, deltaY) {
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
                geometries[i].translate(deltaX, deltaY);
            }
            this.changed();
        };
        /**
         * Clean up.
         */
        GeometryCollection.prototype.disposeInternal = function () {
            this.unlistenGeometriesChange_();
            _super.prototype.disposeInternal.call(this);
        };
        return GeometryCollection;
    }(Geometry));
    /**
     * @param {Array<Geometry>} geometries Geometries.
     * @return {Array<Geometry>} Cloned geometries.
     */
    function cloneGeometries(geometries) {
        var clonedGeometries = [];
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
            clonedGeometries.push(geometries[i].clone());
        }
        return clonedGeometries;
    }

    /**
     * @module ol/format/GeoJSON
     */
    var __extends$11 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {import("geojson").GeoJSON} GeoJSONObject
     * @typedef {import("geojson").Feature} GeoJSONFeature
     * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection
     * @typedef {import("geojson").Geometry} GeoJSONGeometry
     * @typedef {import("geojson").Point} GeoJSONPoint
     * @typedef {import("geojson").LineString} GeoJSONLineString
     * @typedef {import("geojson").Polygon} GeoJSONPolygon
     * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint
     * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString
     * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon
     * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection
     */
    /**
     * @typedef {Object} Options
     * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
     * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or
     * written by the format.  Options passed to read or write methods will take precedence.
     * @property {string} [geometryName] Geometry name to use when creating features.
     * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include
     * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
     * will look for that field to set the geometry name. If both this field is set to `true`
     * and a `geometryName` is provided, the `geometryName` will take precedence.
     */
    /**
     * @classdesc
     * Feature format for reading and writing data in the GeoJSON format.
     *
     * @api
     */
    var GeoJSON = /** @class */ (function (_super) {
        __extends$11(GeoJSON, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function GeoJSON(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this) || this;
            /**
             * @type {import("../proj/Projection.js").default}
             */
            _this.dataProjection = get$1(options.dataProjection ? options.dataProjection : 'EPSG:4326');
            if (options.featureProjection) {
                _this.defaultFeatureProjection = get$1(options.featureProjection);
            }
            /**
             * Name of the geometry attribute for features.
             * @type {string|undefined}
             * @private
             */
            _this.geometryName_ = options.geometryName;
            /**
             * Look for the geometry name in the feature GeoJSON
             * @type {boolean|undefined}
             * @private
             */
            _this.extractGeometryName_ = options.extractGeometryName;
            return _this;
        }
        /**
         * @param {Object} object Object.
         * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
         * @protected
         * @return {import("../Feature.js").default} Feature.
         */
        GeoJSON.prototype.readFeatureFromObject = function (object, opt_options) {
            /**
             * @type {GeoJSONFeature}
             */
            var geoJSONFeature = null;
            if (object['type'] === 'Feature') {
                geoJSONFeature = /** @type {GeoJSONFeature} */ (object);
            }
            else {
                geoJSONFeature = {
                    'type': 'Feature',
                    'geometry': /** @type {GeoJSONGeometry} */ (object),
                    'properties': null,
                };
            }
            var geometry = readGeometry(geoJSONFeature['geometry'], opt_options);
            var feature = new Feature();
            if (this.geometryName_) {
                feature.setGeometryName(this.geometryName_);
            }
            else if (this.extractGeometryName_ &&
                'geometry_name' in geoJSONFeature !== undefined) {
                feature.setGeometryName(geoJSONFeature['geometry_name']);
            }
            feature.setGeometry(geometry);
            if ('id' in geoJSONFeature) {
                feature.setId(geoJSONFeature['id']);
            }
            if (geoJSONFeature['properties']) {
                feature.setProperties(geoJSONFeature['properties'], true);
            }
            return feature;
        };
        /**
         * @param {Object} object Object.
         * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
         * @protected
         * @return {Array<Feature>} Features.
         */
        GeoJSON.prototype.readFeaturesFromObject = function (object, opt_options) {
            var geoJSONObject = /** @type {GeoJSONObject} */ (object);
            /** @type {Array<import("../Feature.js").default>} */
            var features = null;
            if (geoJSONObject['type'] === 'FeatureCollection') {
                var geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ (object);
                features = [];
                var geoJSONFeatures = geoJSONFeatureCollection['features'];
                for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
                    features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));
                }
            }
            else {
                features = [this.readFeatureFromObject(object, opt_options)];
            }
            return features;
        };
        /**
         * @param {GeoJSONGeometry} object Object.
         * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
         * @protected
         * @return {import("../geom/Geometry.js").default} Geometry.
         */
        GeoJSON.prototype.readGeometryFromObject = function (object, opt_options) {
            return readGeometry(object, opt_options);
        };
        /**
         * @param {Object} object Object.
         * @protected
         * @return {import("../proj/Projection.js").default} Projection.
         */
        GeoJSON.prototype.readProjectionFromObject = function (object) {
            var crs = object['crs'];
            var projection;
            if (crs) {
                if (crs['type'] == 'name') {
                    projection = get$1(crs['properties']['name']);
                }
                else if (crs['type'] === 'EPSG') {
                    projection = get$1('EPSG:' + crs['properties']['code']);
                }
                else {
                    assert(false, 36); // Unknown SRS type
                }
            }
            else {
                projection = this.dataProjection;
            }
            return /** @type {import("../proj/Projection.js").default} */ (projection);
        };
        /**
         * Encode a feature as a GeoJSON Feature object.
         *
         * @param {import("../Feature.js").default} feature Feature.
         * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
         * @return {GeoJSONFeature} Object.
         * @api
         */
        GeoJSON.prototype.writeFeatureObject = function (feature, opt_options) {
            opt_options = this.adaptOptions(opt_options);
            /** @type {GeoJSONFeature} */
            var object = {
                'type': 'Feature',
                geometry: null,
                properties: null,
            };
            var id = feature.getId();
            if (id !== undefined) {
                object.id = id;
            }
            if (!feature.hasProperties()) {
                return object;
            }
            var properties = feature.getProperties();
            var geometry = feature.getGeometry();
            if (geometry) {
                object.geometry = writeGeometry(geometry, opt_options);
                delete properties[feature.getGeometryName()];
            }
            if (!isEmpty$1(properties)) {
                object.properties = properties;
            }
            return object;
        };
        /**
         * Encode an array of features as a GeoJSON object.
         *
         * @param {Array<import("../Feature.js").default>} features Features.
         * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
         * @return {GeoJSONFeatureCollection} GeoJSON Object.
         * @api
         */
        GeoJSON.prototype.writeFeaturesObject = function (features, opt_options) {
            opt_options = this.adaptOptions(opt_options);
            var objects = [];
            for (var i = 0, ii = features.length; i < ii; ++i) {
                objects.push(this.writeFeatureObject(features[i], opt_options));
            }
            return {
                type: 'FeatureCollection',
                features: objects,
            };
        };
        /**
         * Encode a geometry as a GeoJSON object.
         *
         * @param {import("../geom/Geometry.js").default} geometry Geometry.
         * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
         * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
         * @api
         */
        GeoJSON.prototype.writeGeometryObject = function (geometry, opt_options) {
            return writeGeometry(geometry, this.adaptOptions(opt_options));
        };
        return GeoJSON;
    }(JSONFeature));
    /**
     * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
     * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    function readGeometry(object, opt_options) {
        if (!object) {
            return null;
        }
        /**
         * @type {import("../geom/Geometry.js").default}
         */
        var geometry;
        switch (object['type']) {
            case GeometryType.POINT: {
                geometry = readPointGeometry(/** @type {GeoJSONPoint} */ (object));
                break;
            }
            case GeometryType.LINE_STRING: {
                geometry = readLineStringGeometry(
                /** @type {GeoJSONLineString} */ (object));
                break;
            }
            case GeometryType.POLYGON: {
                geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ (object));
                break;
            }
            case GeometryType.MULTI_POINT: {
                geometry = readMultiPointGeometry(
                /** @type {GeoJSONMultiPoint} */ (object));
                break;
            }
            case GeometryType.MULTI_LINE_STRING: {
                geometry = readMultiLineStringGeometry(
                /** @type {GeoJSONMultiLineString} */ (object));
                break;
            }
            case GeometryType.MULTI_POLYGON: {
                geometry = readMultiPolygonGeometry(
                /** @type {GeoJSONMultiPolygon} */ (object));
                break;
            }
            case GeometryType.GEOMETRY_COLLECTION: {
                geometry = readGeometryCollectionGeometry(
                /** @type {GeoJSONGeometryCollection} */ (object));
                break;
            }
            default: {
                throw new Error('Unsupported GeoJSON type: ' + object.type);
            }
        }
        return transformGeometryWithOptions(geometry, false, opt_options);
    }
    /**
     * @param {GeoJSONGeometryCollection} object Object.
     * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
     * @return {GeometryCollection} Geometry collection.
     */
    function readGeometryCollectionGeometry(object, opt_options) {
        var geometries = object['geometries'].map(
        /**
         * @param {GeoJSONGeometry} geometry Geometry.
         * @return {import("../geom/Geometry.js").default} geometry Geometry.
         */
        function (geometry) {
            return readGeometry(geometry, opt_options);
        });
        return new GeometryCollection(geometries);
    }
    /**
     * @param {GeoJSONPoint} object Object.
     * @return {Point} Point.
     */
    function readPointGeometry(object) {
        return new Point(object['coordinates']);
    }
    /**
     * @param {GeoJSONLineString} object Object.
     * @return {LineString} LineString.
     */
    function readLineStringGeometry(object) {
        return new LineString(object['coordinates']);
    }
    /**
     * @param {GeoJSONMultiLineString} object Object.
     * @return {MultiLineString} MultiLineString.
     */
    function readMultiLineStringGeometry(object) {
        return new MultiLineString(object['coordinates']);
    }
    /**
     * @param {GeoJSONMultiPoint} object Object.
     * @return {MultiPoint} MultiPoint.
     */
    function readMultiPointGeometry(object) {
        return new MultiPoint(object['coordinates']);
    }
    /**
     * @param {GeoJSONMultiPolygon} object Object.
     * @return {MultiPolygon} MultiPolygon.
     */
    function readMultiPolygonGeometry(object) {
        return new MultiPolygon(object['coordinates']);
    }
    /**
     * @param {GeoJSONPolygon} object Object.
     * @return {Polygon} Polygon.
     */
    function readPolygonGeometry(object) {
        return new Polygon(object['coordinates']);
    }
    /**
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
     * @return {GeoJSONGeometry} GeoJSON geometry.
     */
    function writeGeometry(geometry, opt_options) {
        geometry = transformGeometryWithOptions(geometry, true, opt_options);
        var type = geometry.getType();
        /** @type {GeoJSONGeometry} */
        var geoJSON;
        switch (type) {
            case GeometryType.POINT: {
                geoJSON = writePointGeometry(
                /** @type {Point} */ (geometry));
                break;
            }
            case GeometryType.LINE_STRING: {
                geoJSON = writeLineStringGeometry(
                /** @type {LineString} */ (geometry));
                break;
            }
            case GeometryType.POLYGON: {
                geoJSON = writePolygonGeometry(
                /** @type {Polygon} */ (geometry), opt_options);
                break;
            }
            case GeometryType.MULTI_POINT: {
                geoJSON = writeMultiPointGeometry(
                /** @type {MultiPoint} */ (geometry));
                break;
            }
            case GeometryType.MULTI_LINE_STRING: {
                geoJSON = writeMultiLineStringGeometry(
                /** @type {MultiLineString} */ (geometry));
                break;
            }
            case GeometryType.MULTI_POLYGON: {
                geoJSON = writeMultiPolygonGeometry(
                /** @type {MultiPolygon} */ (geometry), opt_options);
                break;
            }
            case GeometryType.GEOMETRY_COLLECTION: {
                geoJSON = writeGeometryCollectionGeometry(
                /** @type {GeometryCollection} */ (geometry), opt_options);
                break;
            }
            case GeometryType.CIRCLE: {
                geoJSON = {
                    type: 'GeometryCollection',
                    geometries: [],
                };
                break;
            }
            default: {
                throw new Error('Unsupported geometry type: ' + type);
            }
        }
        return geoJSON;
    }
    /**
     * @param {GeometryCollection} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
     * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
     */
    function writeGeometryCollectionGeometry(geometry, opt_options) {
        var geometries = geometry.getGeometriesArray().map(function (geometry) {
            var options = assign({}, opt_options);
            delete options.featureProjection;
            return writeGeometry(geometry, options);
        });
        return {
            type: 'GeometryCollection',
            geometries: geometries,
        };
    }
    /**
     * @param {LineString} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
     * @return {GeoJSONGeometry} GeoJSON geometry.
     */
    function writeLineStringGeometry(geometry, opt_options) {
        return {
            type: 'LineString',
            coordinates: geometry.getCoordinates(),
        };
    }
    /**
     * @param {MultiLineString} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
     * @return {GeoJSONGeometry} GeoJSON geometry.
     */
    function writeMultiLineStringGeometry(geometry, opt_options) {
        return {
            type: 'MultiLineString',
            coordinates: geometry.getCoordinates(),
        };
    }
    /**
     * @param {MultiPoint} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
     * @return {GeoJSONGeometry} GeoJSON geometry.
     */
    function writeMultiPointGeometry(geometry, opt_options) {
        return {
            type: 'MultiPoint',
            coordinates: geometry.getCoordinates(),
        };
    }
    /**
     * @param {MultiPolygon} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
     * @return {GeoJSONGeometry} GeoJSON geometry.
     */
    function writeMultiPolygonGeometry(geometry, opt_options) {
        var right;
        if (opt_options) {
            right = opt_options.rightHanded;
        }
        return {
            type: 'MultiPolygon',
            coordinates: geometry.getCoordinates(right),
        };
    }
    /**
     * @param {Point} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
     * @return {GeoJSONGeometry} GeoJSON geometry.
     */
    function writePointGeometry(geometry, opt_options) {
        return {
            type: 'Point',
            coordinates: geometry.getCoordinates(),
        };
    }
    /**
     * @param {Polygon} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
     * @return {GeoJSONGeometry} GeoJSON geometry.
     */
    function writePolygonGeometry(geometry, opt_options) {
        var right;
        if (opt_options) {
            right = opt_options.rightHanded;
        }
        return {
            type: 'Polygon',
            coordinates: geometry.getCoordinates(right),
        };
    }

    /**
     * @module ol/style/Fill
     */
    /**
     * @typedef {Object} Options
     * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color=null] A color, gradient or pattern.
     * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
     * Default null; if null, the Canvas/renderer default black will be used.
     */
    /**
     * @classdesc
     * Set fill style for vector features.
     * @api
     */
    var Fill = /** @class */ (function () {
        /**
         * @param {Options=} opt_options Options.
         */
        function Fill(opt_options) {
            var options = opt_options || {};
            /**
             * @private
             * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
             */
            this.color_ = options.color !== undefined ? options.color : null;
        }
        /**
         * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
         * @return {Fill} The cloned style.
         * @api
         */
        Fill.prototype.clone = function () {
            var color = this.getColor();
            return new Fill({
                color: Array.isArray(color) ? color.slice() : color || undefined,
            });
        };
        /**
         * Get the fill color.
         * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
         * @api
         */
        Fill.prototype.getColor = function () {
            return this.color_;
        };
        /**
         * Set the color.
         *
         * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
         * @api
         */
        Fill.prototype.setColor = function (color) {
            this.color_ = color;
        };
        return Fill;
    }());

    /**
     * @module ol/style/IconAnchorUnits
     */
    /**
     * Icon anchor units. One of 'fraction', 'pixels'.
     * @enum {string}
     */
    var IconAnchorUnits = {
        /**
         * Anchor is a fraction
         * @api
         */
        FRACTION: 'fraction',
        /**
         * Anchor is in pixels
         * @api
         */
        PIXELS: 'pixels',
    };

    /**
     * @module ol/style/IconOrigin
     */
    /**
     * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
     * @enum {string}
     */
    var IconOrigin = {
        /**
         * Origin is at bottom left
         * @api
         */
        BOTTOM_LEFT: 'bottom-left',
        /**
         * Origin is at bottom right
         * @api
         */
        BOTTOM_RIGHT: 'bottom-right',
        /**
         * Origin is at top left
         * @api
         */
        TOP_LEFT: 'top-left',
        /**
         * Origin is at top right
         * @api
         */
        TOP_RIGHT: 'top-right',
    };

    /**
     * @module ol/ImageState
     */
    /**
     * @enum {number}
     */
    var ImageState = {
        IDLE: 0,
        LOADING: 1,
        LOADED: 2,
        ERROR: 3,
        EMPTY: 4,
    };

    /**
     * @module ol/size
     */
    /**
     * Determines if a size has a positive area.
     * @param {Size} size The size to test.
     * @return {boolean} The size has a positive area.
     */
    function hasArea(size) {
        return size[0] > 0 && size[1] > 0;
    }
    /**
     * Returns a size scaled by a ratio. The result will be an array of integers.
     * @param {Size} size Size.
     * @param {number} ratio Ratio.
     * @param {Size=} opt_size Optional reusable size array.
     * @return {Size} The scaled size.
     */
    function scale(size, ratio, opt_size) {
        if (opt_size === undefined) {
            opt_size = [0, 0];
        }
        opt_size[0] = (size[0] * ratio + 0.5) | 0;
        opt_size[1] = (size[1] * ratio + 0.5) | 0;
        return opt_size;
    }
    /**
     * Returns an `Size` array for the passed in number (meaning: square) or
     * `Size` array.
     * (meaning: non-square),
     * @param {number|Size} size Width and height.
     * @param {Size=} opt_size Optional reusable size array.
     * @return {Size} Size.
     * @api
     */
    function toSize(size, opt_size) {
        if (Array.isArray(size)) {
            return size;
        }
        else {
            if (opt_size === undefined) {
                opt_size = [size, size];
            }
            else {
                opt_size[0] = size;
                opt_size[1] = size;
            }
            return opt_size;
        }
    }

    /**
     * @module ol/style/Image
     */
    /**
     * @typedef {Object} Options
     * @property {number} opacity
     * @property {boolean} rotateWithView
     * @property {number} rotation
     * @property {number|import("../size.js").Size} scale
     * @property {Array<number>} displacement
     */
    /**
     * @classdesc
     * A base class used for creating subclasses and not instantiated in
     * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
     * {@link module:ol/style/RegularShape~RegularShape}.
     * @abstract
     * @api
     */
    var ImageStyle = /** @class */ (function () {
        /**
         * @param {Options} options Options.
         */
        function ImageStyle(options) {
            /**
             * @private
             * @type {number}
             */
            this.opacity_ = options.opacity;
            /**
             * @private
             * @type {boolean}
             */
            this.rotateWithView_ = options.rotateWithView;
            /**
             * @private
             * @type {number}
             */
            this.rotation_ = options.rotation;
            /**
             * @private
             * @type {number|import("../size.js").Size}
             */
            this.scale_ = options.scale;
            /**
             * @private
             * @type {import("../size.js").Size}
             */
            this.scaleArray_ = toSize(options.scale);
            /**
             * @private
             * @type {Array<number>}
             */
            this.displacement_ = options.displacement;
        }
        /**
         * Clones the style.
         * @return {ImageStyle} The cloned style.
         * @api
         */
        ImageStyle.prototype.clone = function () {
            var scale = this.getScale();
            return new ImageStyle({
                opacity: this.getOpacity(),
                scale: Array.isArray(scale) ? scale.slice() : scale,
                rotation: this.getRotation(),
                rotateWithView: this.getRotateWithView(),
                displacement: this.getDisplacement().slice(),
            });
        };
        /**
         * Get the symbolizer opacity.
         * @return {number} Opacity.
         * @api
         */
        ImageStyle.prototype.getOpacity = function () {
            return this.opacity_;
        };
        /**
         * Determine whether the symbolizer rotates with the map.
         * @return {boolean} Rotate with map.
         * @api
         */
        ImageStyle.prototype.getRotateWithView = function () {
            return this.rotateWithView_;
        };
        /**
         * Get the symoblizer rotation.
         * @return {number} Rotation.
         * @api
         */
        ImageStyle.prototype.getRotation = function () {
            return this.rotation_;
        };
        /**
         * Get the symbolizer scale.
         * @return {number|import("../size.js").Size} Scale.
         * @api
         */
        ImageStyle.prototype.getScale = function () {
            return this.scale_;
        };
        /**
         * Get the symbolizer scale array.
         * @return {import("../size.js").Size} Scale array.
         */
        ImageStyle.prototype.getScaleArray = function () {
            return this.scaleArray_;
        };
        /**
         * Get the displacement of the shape
         * @return {Array<number>} Shape's center displacement
         * @api
         */
        ImageStyle.prototype.getDisplacement = function () {
            return this.displacement_;
        };
        /**
         * Get the anchor point in pixels. The anchor determines the center point for the
         * symbolizer.
         * @abstract
         * @return {Array<number>} Anchor.
         */
        ImageStyle.prototype.getAnchor = function () {
            return abstract();
        };
        /**
         * Get the image element for the symbolizer.
         * @abstract
         * @param {number} pixelRatio Pixel ratio.
         * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
         */
        ImageStyle.prototype.getImage = function (pixelRatio) {
            return abstract();
        };
        /**
         * @abstract
         * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
         */
        ImageStyle.prototype.getHitDetectionImage = function () {
            return abstract();
        };
        /*
         * Get the image pixel ratio.
         * @param {number} pixelRatio Pixel ratio.
         * */
        ImageStyle.prototype.getPixelRatio = function (pixelRatio) {
            return 1;
        };
        /**
         * @abstract
         * @return {import("../ImageState.js").default} Image state.
         */
        ImageStyle.prototype.getImageState = function () {
            return abstract();
        };
        /**
         * @abstract
         * @return {import("../size.js").Size} Image size.
         */
        ImageStyle.prototype.getImageSize = function () {
            return abstract();
        };
        /**
         * @abstract
         * @return {import("../size.js").Size} Size of the hit-detection image.
         */
        ImageStyle.prototype.getHitDetectionImageSize = function () {
            return abstract();
        };
        /**
         * Get the origin of the symbolizer.
         * @abstract
         * @return {Array<number>} Origin.
         */
        ImageStyle.prototype.getOrigin = function () {
            return abstract();
        };
        /**
         * Get the size of the symbolizer (in pixels).
         * @abstract
         * @return {import("../size.js").Size} Size.
         */
        ImageStyle.prototype.getSize = function () {
            return abstract();
        };
        /**
         * Set the opacity.
         *
         * @param {number} opacity Opacity.
         * @api
         */
        ImageStyle.prototype.setOpacity = function (opacity) {
            this.opacity_ = opacity;
        };
        /**
         * Set whether to rotate the style with the view.
         *
         * @param {boolean} rotateWithView Rotate with map.
         * @api
         */
        ImageStyle.prototype.setRotateWithView = function (rotateWithView) {
            this.rotateWithView_ = rotateWithView;
        };
        /**
         * Set the rotation.
         *
         * @param {number} rotation Rotation.
         * @api
         */
        ImageStyle.prototype.setRotation = function (rotation) {
            this.rotation_ = rotation;
        };
        /**
         * Set the scale.
         *
         * @param {number|import("../size.js").Size} scale Scale.
         * @api
         */
        ImageStyle.prototype.setScale = function (scale) {
            this.scale_ = scale;
            this.scaleArray_ = toSize(scale);
        };
        /**
         * @abstract
         * @param {function(import("../events/Event.js").default): void} listener Listener function.
         */
        ImageStyle.prototype.listenImageChange = function (listener) {
            abstract();
        };
        /**
         * Load not yet loaded URI.
         * @abstract
         */
        ImageStyle.prototype.load = function () {
            abstract();
        };
        /**
         * @abstract
         * @param {function(import("../events/Event.js").default): void} listener Listener function.
         */
        ImageStyle.prototype.unlistenImageChange = function (listener) {
            abstract();
        };
        return ImageStyle;
    }());

    /**
     * @module ol/color
     */
    /**
     * A color represented as a short array [red, green, blue, alpha].
     * red, green, and blue should be integers in the range 0..255 inclusive.
     * alpha should be a float in the range 0..1 inclusive. If no alpha value is
     * given then `1` will be used.
     * @typedef {Array<number>} Color
     * @api
     */
    /**
     * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
     * @const
     * @type {RegExp}
     * @private
     */
    var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
    /**
     * Regular expression for matching potential named color style strings.
     * @const
     * @type {RegExp}
     * @private
     */
    var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
    /**
     * Return the color as an rgba string.
     * @param {Color|string} color Color.
     * @return {string} Rgba string.
     * @api
     */
    function asString(color) {
        if (typeof color === 'string') {
            return color;
        }
        else {
            return toString$1(color);
        }
    }
    /**
     * Return named color as an rgba string.
     * @param {string} color Named color.
     * @return {string} Rgb string.
     */
    function fromNamed(color) {
        var el = document.createElement('div');
        el.style.color = color;
        if (el.style.color !== '') {
            document.body.appendChild(el);
            var rgb = getComputedStyle(el).color;
            document.body.removeChild(el);
            return rgb;
        }
        else {
            return '';
        }
    }
    /**
     * @param {string} s String.
     * @return {Color} Color.
     */
    var fromString = (function () {
        // We maintain a small cache of parsed strings.  To provide cheap LRU-like
        // semantics, whenever the cache grows too large we simply delete an
        // arbitrary 25% of the entries.
        /**
         * @const
         * @type {number}
         */
        var MAX_CACHE_SIZE = 1024;
        /**
         * @type {Object<string, Color>}
         */
        var cache = {};
        /**
         * @type {number}
         */
        var cacheSize = 0;
        return (
        /**
         * @param {string} s String.
         * @return {Color} Color.
         */
        function (s) {
            var color;
            if (cache.hasOwnProperty(s)) {
                color = cache[s];
            }
            else {
                if (cacheSize >= MAX_CACHE_SIZE) {
                    var i = 0;
                    for (var key in cache) {
                        if ((i++ & 3) === 0) {
                            delete cache[key];
                            --cacheSize;
                        }
                    }
                }
                color = fromStringInternal_(s);
                cache[s] = color;
                ++cacheSize;
            }
            return color;
        });
    })();
    /**
     * Return the color as an array. This function maintains a cache of calculated
     * arrays which means the result should not be modified.
     * @param {Color|string} color Color.
     * @return {Color} Color.
     * @api
     */
    function asArray(color) {
        if (Array.isArray(color)) {
            return color;
        }
        else {
            return fromString(color);
        }
    }
    /**
     * @param {string} s String.
     * @private
     * @return {Color} Color.
     */
    function fromStringInternal_(s) {
        var r, g, b, a, color;
        if (NAMED_COLOR_RE_.exec(s)) {
            s = fromNamed(s);
        }
        if (HEX_COLOR_RE_.exec(s)) {
            // hex
            var n = s.length - 1; // number of hex digits
            var d = // number of digits per channel
             void 0; // number of digits per channel
            if (n <= 4) {
                d = 1;
            }
            else {
                d = 2;
            }
            var hasAlpha = n === 4 || n === 8;
            r = parseInt(s.substr(1 + 0 * d, d), 16);
            g = parseInt(s.substr(1 + 1 * d, d), 16);
            b = parseInt(s.substr(1 + 2 * d, d), 16);
            if (hasAlpha) {
                a = parseInt(s.substr(1 + 3 * d, d), 16);
            }
            else {
                a = 255;
            }
            if (d == 1) {
                r = (r << 4) + r;
                g = (g << 4) + g;
                b = (b << 4) + b;
                if (hasAlpha) {
                    a = (a << 4) + a;
                }
            }
            color = [r, g, b, a / 255];
        }
        else if (s.indexOf('rgba(') == 0) {
            // rgba()
            color = s.slice(5, -1).split(',').map(Number);
            normalize(color);
        }
        else if (s.indexOf('rgb(') == 0) {
            // rgb()
            color = s.slice(4, -1).split(',').map(Number);
            color.push(1);
            normalize(color);
        }
        else {
            assert(false, 14); // Invalid color
        }
        return color;
    }
    /**
     * TODO this function is only used in the test, we probably shouldn't export it
     * @param {Color} color Color.
     * @return {Color} Clamped color.
     */
    function normalize(color) {
        color[0] = clamp((color[0] + 0.5) | 0, 0, 255);
        color[1] = clamp((color[1] + 0.5) | 0, 0, 255);
        color[2] = clamp((color[2] + 0.5) | 0, 0, 255);
        color[3] = clamp(color[3], 0, 1);
        return color;
    }
    /**
     * @param {Color} color Color.
     * @return {string} String.
     */
    function toString$1(color) {
        var r = color[0];
        if (r != (r | 0)) {
            r = (r + 0.5) | 0;
        }
        var g = color[1];
        if (g != (g | 0)) {
            g = (g + 0.5) | 0;
        }
        var b = color[2];
        if (b != (b | 0)) {
            b = (b + 0.5) | 0;
        }
        var a = color[3] === undefined ? 1 : color[3];
        return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    }

    /**
     * @module ol/has
     */
    var ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'
        ? navigator.userAgent.toLowerCase()
        : '';
    /**
     * User agent string says we are dealing with Firefox as browser.
     * @type {boolean}
     */
    var FIREFOX = ua.indexOf('firefox') !== -1;
    /**
     * User agent string says we are dealing with Safari as browser.
     * @type {boolean}
     */
    ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;
    /**
     * User agent string says we are dealing with a WebKit engine.
     * @type {boolean}
     */
    var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;
    /**
     * User agent string says we are dealing with a Mac as platform.
     * @type {boolean}
     */
    var MAC = ua.indexOf('macintosh') !== -1;
    /**
     * The ratio between physical pixels and device-independent pixels
     * (dips) on the device (`window.devicePixelRatio`).
     * @const
     * @type {number}
     * @api
     */
    var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
    /**
     * The execution context is a worker with OffscreenCanvas available.
     * @const
     * @type {boolean}
     */
    var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' &&
        typeof OffscreenCanvas !== 'undefined' &&
        self instanceof WorkerGlobalScope; //eslint-disable-line
    /**
     * Image.prototype.decode() is supported.
     * @type {boolean}
     */
    var IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
    /**
     * @type {boolean}
     */
    var PASSIVE_EVENT_LISTENERS = (function () {
        var passive = false;
        try {
            var options = Object.defineProperty({}, 'passive', {
                get: function () {
                    passive = true;
                },
            });
            window.addEventListener('_', null, options);
            window.removeEventListener('_', null, options);
        }
        catch (error) {
            // passive not supported
        }
        return passive;
    })();

    /**
     * @module ol/dom
     */
    //FIXME Move this function to the canvas module
    /**
     * Create an html canvas element and returns its 2d context.
     * @param {number=} opt_width Canvas width.
     * @param {number=} opt_height Canvas height.
     * @param {Array<HTMLCanvasElement>=} opt_canvasPool Canvas pool to take existing canvas from.
     * @return {CanvasRenderingContext2D} The context.
     */
    function createCanvasContext2D(opt_width, opt_height, opt_canvasPool) {
        var canvas = opt_canvasPool && opt_canvasPool.length
            ? opt_canvasPool.shift()
            : WORKER_OFFSCREEN_CANVAS
                ? new OffscreenCanvas(opt_width || 300, opt_height || 300)
                : document.createElement('canvas');
        if (opt_width) {
            canvas.width = opt_width;
        }
        if (opt_height) {
            canvas.height = opt_height;
        }
        //FIXME Allow OffscreenCanvasRenderingContext2D as return type
        return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
    }
    /**
     * @param {Node} newNode Node to replace old node
     * @param {Node} oldNode The node to be replaced
     */
    function replaceNode(newNode, oldNode) {
        var parent = oldNode.parentNode;
        if (parent) {
            parent.replaceChild(newNode, oldNode);
        }
    }
    /**
     * @param {Node} node The node to remove.
     * @returns {Node} The node that was removed or null.
     */
    function removeNode(node) {
        return node && node.parentNode ? node.parentNode.removeChild(node) : null;
    }
    /**
     * @param {Node} node The node to remove the children from.
     */
    function removeChildren(node) {
        while (node.lastChild) {
            node.removeChild(node.lastChild);
        }
    }
    /**
     * Transform the children of a parent node so they match the
     * provided list of children.  This function aims to efficiently
     * remove, add, and reorder child nodes while maintaining a simple
     * implementation (it is not guaranteed to minimize DOM operations).
     * @param {Node} node The parent node whose children need reworking.
     * @param {Array<Node>} children The desired children.
     */
    function replaceChildren(node, children) {
        var oldChildren = node.childNodes;
        for (var i = 0; true; ++i) {
            var oldChild = oldChildren[i];
            var newChild = children[i];
            // check if our work is done
            if (!oldChild && !newChild) {
                break;
            }
            // check if children match
            if (oldChild === newChild) {
                continue;
            }
            // check if a new child needs to be added
            if (!oldChild) {
                node.appendChild(newChild);
                continue;
            }
            // check if an old child needs to be removed
            if (!newChild) {
                node.removeChild(oldChild);
                --i;
                continue;
            }
            // reorder
            node.insertBefore(newChild, oldChild);
        }
    }

    /**
     * @module ol/style/IconImageCache
     */
    /**
     * @classdesc
     * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.
     */
    var IconImageCache = /** @class */ (function () {
        function IconImageCache() {
            /**
             * @type {!Object<string, import("./IconImage.js").default>}
             * @private
             */
            this.cache_ = {};
            /**
             * @type {number}
             * @private
             */
            this.cacheSize_ = 0;
            /**
             * @type {number}
             * @private
             */
            this.maxCacheSize_ = 32;
        }
        /**
         * FIXME empty description for jsdoc
         */
        IconImageCache.prototype.clear = function () {
            this.cache_ = {};
            this.cacheSize_ = 0;
        };
        /**
         * @return {boolean} Can expire cache.
         */
        IconImageCache.prototype.canExpireCache = function () {
            return this.cacheSize_ > this.maxCacheSize_;
        };
        /**
         * FIXME empty description for jsdoc
         */
        IconImageCache.prototype.expire = function () {
            if (this.canExpireCache()) {
                var i = 0;
                for (var key in this.cache_) {
                    var iconImage = this.cache_[key];
                    if ((i++ & 3) === 0 && !iconImage.hasListener()) {
                        delete this.cache_[key];
                        --this.cacheSize_;
                    }
                }
            }
        };
        /**
         * @param {string} src Src.
         * @param {?string} crossOrigin Cross origin.
         * @param {import("../color.js").Color} color Color.
         * @return {import("./IconImage.js").default} Icon image.
         */
        IconImageCache.prototype.get = function (src, crossOrigin, color) {
            var key = getKey$1(src, crossOrigin, color);
            return key in this.cache_ ? this.cache_[key] : null;
        };
        /**
         * @param {string} src Src.
         * @param {?string} crossOrigin Cross origin.
         * @param {import("../color.js").Color} color Color.
         * @param {import("./IconImage.js").default} iconImage Icon image.
         */
        IconImageCache.prototype.set = function (src, crossOrigin, color, iconImage) {
            var key = getKey$1(src, crossOrigin, color);
            this.cache_[key] = iconImage;
            ++this.cacheSize_;
        };
        /**
         * Set the cache size of the icon cache. Default is `32`. Change this value when
         * your map uses more than 32 different icon images and you are not caching icon
         * styles on the application level.
         * @param {number} maxCacheSize Cache max size.
         * @api
         */
        IconImageCache.prototype.setSize = function (maxCacheSize) {
            this.maxCacheSize_ = maxCacheSize;
            this.expire();
        };
        return IconImageCache;
    }());
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color} color Color.
     * @return {string} Cache key.
     */
    function getKey$1(src, crossOrigin, color) {
        var colorString = color ? asString(color) : 'null';
        return crossOrigin + ':' + src + ':' + colorString;
    }
    /**
     * The {@link module:ol/style/IconImageCache~IconImageCache} for
     * {@link module:ol/style/Icon~Icon} images.
     * @api
     */
    var shared = new IconImageCache();

    var __extends$10 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @abstract
     */
    var ImageBase = /** @class */ (function (_super) {
        __extends$10(ImageBase, _super);
        /**
         * @param {import("./extent.js").Extent} extent Extent.
         * @param {number|undefined} resolution Resolution.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("./ImageState.js").default} state State.
         */
        function ImageBase(extent, resolution, pixelRatio, state) {
            var _this = _super.call(this) || this;
            /**
             * @protected
             * @type {import("./extent.js").Extent}
             */
            _this.extent = extent;
            /**
             * @private
             * @type {number}
             */
            _this.pixelRatio_ = pixelRatio;
            /**
             * @protected
             * @type {number|undefined}
             */
            _this.resolution = resolution;
            /**
             * @protected
             * @type {import("./ImageState.js").default}
             */
            _this.state = state;
            return _this;
        }
        /**
         * @protected
         */
        ImageBase.prototype.changed = function () {
            this.dispatchEvent(EventType.CHANGE);
        };
        /**
         * @return {import("./extent.js").Extent} Extent.
         */
        ImageBase.prototype.getExtent = function () {
            return this.extent;
        };
        /**
         * @abstract
         * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
         */
        ImageBase.prototype.getImage = function () {
            return abstract();
        };
        /**
         * @return {number} PixelRatio.
         */
        ImageBase.prototype.getPixelRatio = function () {
            return this.pixelRatio_;
        };
        /**
         * @return {number} Resolution.
         */
        ImageBase.prototype.getResolution = function () {
            return /** @type {number} */ (this.resolution);
        };
        /**
         * @return {import("./ImageState.js").default} State.
         */
        ImageBase.prototype.getState = function () {
            return this.state;
        };
        /**
         * Load not yet loaded URI.
         * @abstract
         */
        ImageBase.prototype.load = function () {
            abstract();
        };
        return ImageBase;
    }(Target));

    var __extends$$ = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A function that takes an {@link module:ol/Image~Image} for the image and a
     * `{string}` for the src as arguments. It is supposed to make it so the
     * underlying image {@link module:ol/Image~Image#getImage} is assigned the
     * content specified by the src. If not specified, the default is
     *
     *     function(image, src) {
     *       image.getImage().src = src;
     *     }
     *
     * Providing a custom `imageLoadFunction` can be useful to load images with
     * post requests or - in general - through XHR requests, where the src of the
     * image element would be set to a data URI when the content is loaded.
     *
     * @typedef {function(ImageWrapper, string): void} LoadFunction
     * @api
     */
    /** @class */ ((function (_super) {
        __extends$$(ImageWrapper, _super);
        /**
         * @param {import("./extent.js").Extent} extent Extent.
         * @param {number|undefined} resolution Resolution.
         * @param {number} pixelRatio Pixel ratio.
         * @param {string} src Image source URI.
         * @param {?string} crossOrigin Cross origin.
         * @param {LoadFunction} imageLoadFunction Image load function.
         */
        function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
            var _this = _super.call(this, extent, resolution, pixelRatio, ImageState.IDLE) || this;
            /**
             * @private
             * @type {string}
             */
            _this.src_ = src;
            /**
             * @private
             * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
             */
            _this.image_ = new Image();
            if (crossOrigin !== null) {
                _this.image_.crossOrigin = crossOrigin;
            }
            /**
             * @private
             * @type {?function():void}
             */
            _this.unlisten_ = null;
            /**
             * @protected
             * @type {import("./ImageState.js").default}
             */
            _this.state = ImageState.IDLE;
            /**
             * @private
             * @type {LoadFunction}
             */
            _this.imageLoadFunction_ = imageLoadFunction;
            return _this;
        }
        /**
         * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
         * @api
         */
        ImageWrapper.prototype.getImage = function () {
            return this.image_;
        };
        /**
         * Tracks loading or read errors.
         *
         * @private
         */
        ImageWrapper.prototype.handleImageError_ = function () {
            this.state = ImageState.ERROR;
            this.unlistenImage_();
            this.changed();
        };
        /**
         * Tracks successful image load.
         *
         * @private
         */
        ImageWrapper.prototype.handleImageLoad_ = function () {
            if (this.resolution === undefined) {
                this.resolution = getHeight(this.extent) / this.image_.height;
            }
            this.state = ImageState.LOADED;
            this.unlistenImage_();
            this.changed();
        };
        /**
         * Load the image or retry if loading previously failed.
         * Loading is taken care of by the tile queue, and calling this method is
         * only needed for preloading or for reloading in case of an error.
         * @api
         */
        ImageWrapper.prototype.load = function () {
            if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {
                this.state = ImageState.LOADING;
                this.changed();
                this.imageLoadFunction_(this, this.src_);
                this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
            }
        };
        /**
         * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
         */
        ImageWrapper.prototype.setImage = function (image) {
            this.image_ = image;
        };
        /**
         * Discards event handlers which listen for load completion or errors.
         *
         * @private
         */
        ImageWrapper.prototype.unlistenImage_ = function () {
            if (this.unlisten_) {
                this.unlisten_();
                this.unlisten_ = null;
            }
        };
        return ImageWrapper;
    })(ImageBase));
    /**
     * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image element.
     * @param {function():any} loadHandler Load callback function.
     * @param {function():any} errorHandler Error callback function.
     * @return {function():void} Callback to stop listening.
     */
    function listenImage(image, loadHandler, errorHandler) {
        var img = /** @type {HTMLImageElement} */ (image);
        if (img.src && IMAGE_DECODE) {
            var promise = img.decode();
            var listening_1 = true;
            var unlisten = function () {
                listening_1 = false;
            };
            promise
                .then(function () {
                if (listening_1) {
                    loadHandler();
                }
            })
                .catch(function (error) {
                if (listening_1) {
                    // FIXME: Unconditionally call errorHandler() when this bug is fixed upstream:
                    //        https://bugs.webkit.org/show_bug.cgi?id=198527
                    if (error.name === 'EncodingError' &&
                        error.message === 'Invalid image type.') {
                        loadHandler();
                    }
                    else {
                        errorHandler();
                    }
                }
            });
            return unlisten;
        }
        var listenerKeys = [
            listenOnce(img, EventType.LOAD, loadHandler),
            listenOnce(img, EventType.ERROR, errorHandler),
        ];
        return function unlisten() {
            listenerKeys.forEach(unlistenByKey);
        };
    }

    /**
     * @module ol/style/IconImage
     */
    var __extends$_ = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @type {CanvasRenderingContext2D}
     */
    var taintedTestContext = null;
    var IconImage = /** @class */ (function (_super) {
        __extends$_(IconImage, _super);
        /**
         * @param {HTMLImageElement|HTMLCanvasElement} image Image.
         * @param {string|undefined} src Src.
         * @param {import("../size.js").Size} size Size.
         * @param {?string} crossOrigin Cross origin.
         * @param {import("../ImageState.js").default} imageState Image state.
         * @param {import("../color.js").Color} color Color.
         */
        function IconImage(image, src, size, crossOrigin, imageState, color) {
            var _this = _super.call(this) || this;
            /**
             * @private
             * @type {HTMLImageElement|HTMLCanvasElement}
             */
            _this.hitDetectionImage_ = null;
            /**
             * @private
             * @type {HTMLImageElement|HTMLCanvasElement}
             */
            _this.image_ = !image ? new Image() : image;
            if (crossOrigin !== null) {
                /** @type {HTMLImageElement} */ (_this.image_).crossOrigin = crossOrigin;
            }
            /**
             * @private
             * @type {Object<number, HTMLCanvasElement>}
             */
            _this.canvas_ = {};
            /**
             * @private
             * @type {import("../color.js").Color}
             */
            _this.color_ = color;
            /**
             * @private
             * @type {?function():void}
             */
            _this.unlisten_ = null;
            /**
             * @private
             * @type {import("../ImageState.js").default}
             */
            _this.imageState_ = imageState;
            /**
             * @private
             * @type {import("../size.js").Size}
             */
            _this.size_ = size;
            /**
             * @private
             * @type {string|undefined}
             */
            _this.src_ = src;
            /**
             * @private
             */
            _this.tainted_;
            return _this;
        }
        /**
         * @private
         * @return {boolean} The image canvas is tainted.
         */
        IconImage.prototype.isTainted_ = function () {
            if (this.tainted_ === undefined && this.imageState_ === ImageState.LOADED) {
                if (!taintedTestContext) {
                    taintedTestContext = createCanvasContext2D(1, 1);
                }
                taintedTestContext.drawImage(this.image_, 0, 0);
                try {
                    taintedTestContext.getImageData(0, 0, 1, 1);
                    this.tainted_ = false;
                }
                catch (e) {
                    taintedTestContext = null;
                    this.tainted_ = true;
                }
            }
            return this.tainted_ === true;
        };
        /**
         * @private
         */
        IconImage.prototype.dispatchChangeEvent_ = function () {
            this.dispatchEvent(EventType.CHANGE);
        };
        /**
         * @private
         */
        IconImage.prototype.handleImageError_ = function () {
            this.imageState_ = ImageState.ERROR;
            this.unlistenImage_();
            this.dispatchChangeEvent_();
        };
        /**
         * @private
         */
        IconImage.prototype.handleImageLoad_ = function () {
            this.imageState_ = ImageState.LOADED;
            if (this.size_) {
                this.image_.width = this.size_[0];
                this.image_.height = this.size_[1];
            }
            else {
                this.size_ = [this.image_.width, this.image_.height];
            }
            this.unlistenImage_();
            this.dispatchChangeEvent_();
        };
        /**
         * @param {number} pixelRatio Pixel ratio.
         * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
         */
        IconImage.prototype.getImage = function (pixelRatio) {
            this.replaceColor_(pixelRatio);
            return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
        };
        /**
         * @param {number} pixelRatio Pixel ratio.
         * @return {number} Image or Canvas element.
         */
        IconImage.prototype.getPixelRatio = function (pixelRatio) {
            this.replaceColor_(pixelRatio);
            return this.canvas_[pixelRatio] ? pixelRatio : 1;
        };
        /**
         * @return {import("../ImageState.js").default} Image state.
         */
        IconImage.prototype.getImageState = function () {
            return this.imageState_;
        };
        /**
         * @return {HTMLImageElement|HTMLCanvasElement} Image element.
         */
        IconImage.prototype.getHitDetectionImage = function () {
            if (!this.hitDetectionImage_) {
                if (this.isTainted_()) {
                    var width = this.size_[0];
                    var height = this.size_[1];
                    var context = createCanvasContext2D(width, height);
                    context.fillRect(0, 0, width, height);
                    this.hitDetectionImage_ = context.canvas;
                }
                else {
                    this.hitDetectionImage_ = this.image_;
                }
            }
            return this.hitDetectionImage_;
        };
        /**
         * Get the size of the icon (in pixels).
         * @return {import("../size.js").Size} Image size.
         */
        IconImage.prototype.getSize = function () {
            return this.size_;
        };
        /**
         * @return {string|undefined} Image src.
         */
        IconImage.prototype.getSrc = function () {
            return this.src_;
        };
        /**
         * Load not yet loaded URI.
         */
        IconImage.prototype.load = function () {
            if (this.imageState_ == ImageState.IDLE) {
                this.imageState_ = ImageState.LOADING;
                try {
                    /** @type {HTMLImageElement} */ (this.image_).src = this.src_;
                }
                catch (e) {
                    this.handleImageError_();
                }
                this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
            }
        };
        /**
         * @param {number} pixelRatio Pixel ratio.
         * @private
         */
        IconImage.prototype.replaceColor_ = function (pixelRatio) {
            if (!this.color_ || this.canvas_[pixelRatio]) {
                return;
            }
            var canvas = document.createElement('canvas');
            this.canvas_[pixelRatio] = canvas;
            canvas.width = Math.ceil(this.image_.width * pixelRatio);
            canvas.height = Math.ceil(this.image_.height * pixelRatio);
            var ctx = canvas.getContext('2d');
            ctx.scale(pixelRatio, pixelRatio);
            ctx.drawImage(this.image_, 0, 0);
            ctx.globalCompositeOperation = 'multiply';
            // Internet Explorer 11 does not support the multiply operation.
            // If the canvas is tainted in Internet Explorer this still produces
            // a solid color image with the shape of the icon.
            if (ctx.globalCompositeOperation === 'multiply' || this.isTainted_()) {
                ctx.fillStyle = asString(this.color_);
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalCompositeOperation = 'destination-in';
                ctx.drawImage(this.image_, 0, 0);
            }
            else {
                var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                var data = imgData.data;
                var r = this.color_[0] / 255.0;
                var g = this.color_[1] / 255.0;
                var b = this.color_[2] / 255.0;
                var a = this.color_[3];
                for (var i = 0, ii = data.length; i < ii; i += 4) {
                    data[i] *= r;
                    data[i + 1] *= g;
                    data[i + 2] *= b;
                    data[i + 3] *= a;
                }
                ctx.putImageData(imgData, 0, 0);
            }
        };
        /**
         * Discards event handlers which listen for load completion or errors.
         *
         * @private
         */
        IconImage.prototype.unlistenImage_ = function () {
            if (this.unlisten_) {
                this.unlisten_();
                this.unlisten_ = null;
            }
        };
        return IconImage;
    }(Target));
    /**
     * @param {HTMLImageElement|HTMLCanvasElement} image Image.
     * @param {string} src Src.
     * @param {import("../size.js").Size} size Size.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../ImageState.js").default} imageState Image state.
     * @param {import("../color.js").Color} color Color.
     * @return {IconImage} Icon image.
     */
    function get(image, src, size, crossOrigin, imageState, color) {
        var iconImage = shared.get(src, crossOrigin, color);
        if (!iconImage) {
            iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);
            shared.set(src, crossOrigin, color, iconImage);
        }
        return iconImage;
    }

    var __extends$Z = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
     * @property {import("./IconOrigin.js").default} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
     * `top-left` or `top-right`.
     * @property {import("./IconAnchorUnits.js").default} [anchorXUnits='fraction'] Units in which the anchor x value is
     * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
     * the x value in pixels.
     * @property {import("./IconAnchorUnits.js").default} [anchorYUnits='fraction'] Units in which the anchor y value is
     * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
     * the y value in pixels.
     * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
     * the icon will be left as is.
     * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
     * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the
     * provided image must already be loaded. And in that case, it is required
     * to provide the size of the image, with the `imgSize` option.
     * @property {Array<number>} [offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
     * sub-rectangle to use from the original icon image.
     * @property {Array<number>} [displacement=[0,0]] Displacement the icon
     * @property {import("./IconOrigin.js").default} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
     * `top-left` or `top-right`.
     * @property {number} [opacity=1] Opacity of the icon.
     * @property {number|import("../size.js").Size} [scale=1] Scale.
     * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
     * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
     * @property {import("../size.js").Size} [size] Icon size in pixel. Can be used together with `offset` to define the
     * sub-rectangle to use from the origin (sprite) icon image.
     * @property {import("../size.js").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not, and
     * for SVG images in Internet Explorer 11. The provided `imgSize` needs to match the actual size of the image.
     * @property {string} [src] Image source URI.
     */
    /**
     * @classdesc
     * Set icon style for vector features.
     * @api
     */
    var Icon = /** @class */ (function (_super) {
        __extends$Z(Icon, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function Icon(opt_options) {
            var _this = this;
            var options = opt_options || {};
            /**
             * @type {number}
             */
            var opacity = options.opacity !== undefined ? options.opacity : 1;
            /**
             * @type {number}
             */
            var rotation = options.rotation !== undefined ? options.rotation : 0;
            /**
             * @type {number|import("../size.js").Size}
             */
            var scale = options.scale !== undefined ? options.scale : 1;
            /**
             * @type {boolean}
             */
            var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
            _this = _super.call(this, {
                opacity: opacity,
                rotation: rotation,
                scale: scale,
                displacement: options.displacement !== undefined ? options.displacement : [0, 0],
                rotateWithView: rotateWithView,
            }) || this;
            /**
             * @private
             * @type {Array<number>}
             */
            _this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];
            /**
             * @private
             * @type {Array<number>}
             */
            _this.normalizedAnchor_ = null;
            /**
             * @private
             * @type {import("./IconOrigin.js").default}
             */
            _this.anchorOrigin_ =
                options.anchorOrigin !== undefined
                    ? options.anchorOrigin
                    : IconOrigin.TOP_LEFT;
            /**
             * @private
             * @type {import("./IconAnchorUnits.js").default}
             */
            _this.anchorXUnits_ =
                options.anchorXUnits !== undefined
                    ? options.anchorXUnits
                    : IconAnchorUnits.FRACTION;
            /**
             * @private
             * @type {import("./IconAnchorUnits.js").default}
             */
            _this.anchorYUnits_ =
                options.anchorYUnits !== undefined
                    ? options.anchorYUnits
                    : IconAnchorUnits.FRACTION;
            /**
             * @private
             * @type {?string}
             */
            _this.crossOrigin_ =
                options.crossOrigin !== undefined ? options.crossOrigin : null;
            /**
             * @type {HTMLImageElement|HTMLCanvasElement}
             */
            var image = options.img !== undefined ? options.img : null;
            /**
             * @type {import("../size.js").Size}
             */
            var imgSize = options.imgSize !== undefined ? options.imgSize : null;
            /**
             * @type {string|undefined}
             */
            var src = options.src;
            assert(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time
            assert(!image || (image && imgSize), 5); // `imgSize` must be set when `image` is provided
            if ((src === undefined || src.length === 0) && image) {
                src = /** @type {HTMLImageElement} */ (image).src || getUid(image);
            }
            assert(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided
            /**
             * @type {import("../ImageState.js").default}
             */
            var imageState = options.src !== undefined ? ImageState.IDLE : ImageState.LOADED;
            /**
             * @private
             * @type {import("../color.js").Color}
             */
            _this.color_ = options.color !== undefined ? asArray(options.color) : null;
            /**
             * @private
             * @type {import("./IconImage.js").default}
             */
            _this.iconImage_ = get(image, 
            /** @type {string} */ (src), imgSize, _this.crossOrigin_, imageState, _this.color_);
            /**
             * @private
             * @type {Array<number>}
             */
            _this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
            /**
             * @private
             * @type {import("./IconOrigin.js").default}
             */
            _this.offsetOrigin_ =
                options.offsetOrigin !== undefined
                    ? options.offsetOrigin
                    : IconOrigin.TOP_LEFT;
            /**
             * @private
             * @type {Array<number>}
             */
            _this.origin_ = null;
            /**
             * @private
             * @type {import("../size.js").Size}
             */
            _this.size_ = options.size !== undefined ? options.size : null;
            return _this;
        }
        /**
         * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
         * @return {Icon} The cloned style.
         * @api
         */
        Icon.prototype.clone = function () {
            var scale = this.getScale();
            return new Icon({
                anchor: this.anchor_.slice(),
                anchorOrigin: this.anchorOrigin_,
                anchorXUnits: this.anchorXUnits_,
                anchorYUnits: this.anchorYUnits_,
                crossOrigin: this.crossOrigin_,
                color: this.color_ && this.color_.slice
                    ? this.color_.slice()
                    : this.color_ || undefined,
                src: this.getSrc(),
                offset: this.offset_.slice(),
                offsetOrigin: this.offsetOrigin_,
                size: this.size_ !== null ? this.size_.slice() : undefined,
                opacity: this.getOpacity(),
                scale: Array.isArray(scale) ? scale.slice() : scale,
                rotation: this.getRotation(),
                rotateWithView: this.getRotateWithView(),
            });
        };
        /**
         * Get the anchor point in pixels. The anchor determines the center point for the
         * symbolizer.
         * @return {Array<number>} Anchor.
         * @api
         */
        Icon.prototype.getAnchor = function () {
            if (this.normalizedAnchor_) {
                return this.normalizedAnchor_;
            }
            var anchor = this.anchor_;
            var size = this.getSize();
            if (this.anchorXUnits_ == IconAnchorUnits.FRACTION ||
                this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
                if (!size) {
                    return null;
                }
                anchor = this.anchor_.slice();
                if (this.anchorXUnits_ == IconAnchorUnits.FRACTION) {
                    anchor[0] *= size[0];
                }
                if (this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
                    anchor[1] *= size[1];
                }
            }
            if (this.anchorOrigin_ != IconOrigin.TOP_LEFT) {
                if (!size) {
                    return null;
                }
                if (anchor === this.anchor_) {
                    anchor = this.anchor_.slice();
                }
                if (this.anchorOrigin_ == IconOrigin.TOP_RIGHT ||
                    this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                    anchor[0] = -anchor[0] + size[0];
                }
                if (this.anchorOrigin_ == IconOrigin.BOTTOM_LEFT ||
                    this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                    anchor[1] = -anchor[1] + size[1];
                }
            }
            this.normalizedAnchor_ = anchor;
            return this.normalizedAnchor_;
        };
        /**
         * Set the anchor point. The anchor determines the center point for the
         * symbolizer.
         *
         * @param {Array<number>} anchor Anchor.
         * @api
         */
        Icon.prototype.setAnchor = function (anchor) {
            this.anchor_ = anchor;
            this.normalizedAnchor_ = null;
        };
        /**
         * Get the icon color.
         * @return {import("../color.js").Color} Color.
         * @api
         */
        Icon.prototype.getColor = function () {
            return this.color_;
        };
        /**
         * Get the image icon.
         * @param {number} pixelRatio Pixel ratio.
         * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
         * @api
         */
        Icon.prototype.getImage = function (pixelRatio) {
            return this.iconImage_.getImage(pixelRatio);
        };
        /**
         * Get the pixel ratio.
         * @param {number} pixelRatio Pixel ratio.
         * @return {number} The pixel ration of the image.
         * @api
         */
        Icon.prototype.getPixelRatio = function (pixelRatio) {
            return this.iconImage_.getPixelRatio(pixelRatio);
        };
        /**
         * @return {import("../size.js").Size} Image size.
         */
        Icon.prototype.getImageSize = function () {
            return this.iconImage_.getSize();
        };
        /**
         * @return {import("../size.js").Size} Size of the hit-detection image.
         */
        Icon.prototype.getHitDetectionImageSize = function () {
            return this.getImageSize();
        };
        /**
         * @return {import("../ImageState.js").default} Image state.
         */
        Icon.prototype.getImageState = function () {
            return this.iconImage_.getImageState();
        };
        /**
         * @return {HTMLImageElement|HTMLCanvasElement} Image element.
         */
        Icon.prototype.getHitDetectionImage = function () {
            return this.iconImage_.getHitDetectionImage();
        };
        /**
         * Get the origin of the symbolizer.
         * @return {Array<number>} Origin.
         * @api
         */
        Icon.prototype.getOrigin = function () {
            if (this.origin_) {
                return this.origin_;
            }
            var offset = this.offset_;
            var displacement = this.getDisplacement();
            if (this.offsetOrigin_ != IconOrigin.TOP_LEFT) {
                var size = this.getSize();
                var iconImageSize = this.iconImage_.getSize();
                if (!size || !iconImageSize) {
                    return null;
                }
                offset = offset.slice();
                if (this.offsetOrigin_ == IconOrigin.TOP_RIGHT ||
                    this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                    offset[0] = iconImageSize[0] - size[0] - offset[0];
                }
                if (this.offsetOrigin_ == IconOrigin.BOTTOM_LEFT ||
                    this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                    offset[1] = iconImageSize[1] - size[1] - offset[1];
                }
            }
            offset[0] += displacement[0];
            offset[1] += displacement[1];
            this.origin_ = offset;
            return this.origin_;
        };
        /**
         * Get the image URL.
         * @return {string|undefined} Image src.
         * @api
         */
        Icon.prototype.getSrc = function () {
            return this.iconImage_.getSrc();
        };
        /**
         * Get the size of the icon (in pixels).
         * @return {import("../size.js").Size} Image size.
         * @api
         */
        Icon.prototype.getSize = function () {
            return !this.size_ ? this.iconImage_.getSize() : this.size_;
        };
        /**
         * @param {function(import("../events/Event.js").default): void} listener Listener function.
         */
        Icon.prototype.listenImageChange = function (listener) {
            this.iconImage_.addEventListener(EventType.CHANGE, listener);
        };
        /**
         * Load not yet loaded URI.
         * When rendering a feature with an icon style, the vector renderer will
         * automatically call this method. However, you might want to call this
         * method yourself for preloading or other purposes.
         * @api
         */
        Icon.prototype.load = function () {
            this.iconImage_.load();
        };
        /**
         * @param {function(import("../events/Event.js").default): void} listener Listener function.
         */
        Icon.prototype.unlistenImageChange = function (listener) {
            this.iconImage_.removeEventListener(EventType.CHANGE, listener);
        };
        return Icon;
    }(ImageStyle));

    /**
     * @module ol/style/Stroke
     */
    /**
     * @typedef {Object} Options
     * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
     * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
     * Default null; if null, the Canvas/renderer default black will be used.
     * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
     * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
     * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
     * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
     * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
     * @property {number} [lineDashOffset=0] Line dash offset.
     * @property {number} [miterLimit=10] Miter limit.
     * @property {number} [width] Width.
     */
    /**
     * @classdesc
     * Set stroke style for vector features.
     * Note that the defaults given are the Canvas defaults, which will be used if
     * option is not defined. The `get` functions return whatever was entered in
     * the options; they will not return the default.
     * @api
     */
    var Stroke = /** @class */ (function () {
        /**
         * @param {Options=} opt_options Options.
         */
        function Stroke(opt_options) {
            var options = opt_options || {};
            /**
             * @private
             * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
             */
            this.color_ = options.color !== undefined ? options.color : null;
            /**
             * @private
             * @type {CanvasLineCap|undefined}
             */
            this.lineCap_ = options.lineCap;
            /**
             * @private
             * @type {Array<number>}
             */
            this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
            /**
             * @private
             * @type {number|undefined}
             */
            this.lineDashOffset_ = options.lineDashOffset;
            /**
             * @private
             * @type {CanvasLineJoin|undefined}
             */
            this.lineJoin_ = options.lineJoin;
            /**
             * @private
             * @type {number|undefined}
             */
            this.miterLimit_ = options.miterLimit;
            /**
             * @private
             * @type {number|undefined}
             */
            this.width_ = options.width;
        }
        /**
         * Clones the style.
         * @return {Stroke} The cloned style.
         * @api
         */
        Stroke.prototype.clone = function () {
            var color = this.getColor();
            return new Stroke({
                color: Array.isArray(color) ? color.slice() : color || undefined,
                lineCap: this.getLineCap(),
                lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
                lineDashOffset: this.getLineDashOffset(),
                lineJoin: this.getLineJoin(),
                miterLimit: this.getMiterLimit(),
                width: this.getWidth(),
            });
        };
        /**
         * Get the stroke color.
         * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
         * @api
         */
        Stroke.prototype.getColor = function () {
            return this.color_;
        };
        /**
         * Get the line cap type for the stroke.
         * @return {CanvasLineCap|undefined} Line cap.
         * @api
         */
        Stroke.prototype.getLineCap = function () {
            return this.lineCap_;
        };
        /**
         * Get the line dash style for the stroke.
         * @return {Array<number>} Line dash.
         * @api
         */
        Stroke.prototype.getLineDash = function () {
            return this.lineDash_;
        };
        /**
         * Get the line dash offset for the stroke.
         * @return {number|undefined} Line dash offset.
         * @api
         */
        Stroke.prototype.getLineDashOffset = function () {
            return this.lineDashOffset_;
        };
        /**
         * Get the line join type for the stroke.
         * @return {CanvasLineJoin|undefined} Line join.
         * @api
         */
        Stroke.prototype.getLineJoin = function () {
            return this.lineJoin_;
        };
        /**
         * Get the miter limit for the stroke.
         * @return {number|undefined} Miter limit.
         * @api
         */
        Stroke.prototype.getMiterLimit = function () {
            return this.miterLimit_;
        };
        /**
         * Get the stroke width.
         * @return {number|undefined} Width.
         * @api
         */
        Stroke.prototype.getWidth = function () {
            return this.width_;
        };
        /**
         * Set the color.
         *
         * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
         * @api
         */
        Stroke.prototype.setColor = function (color) {
            this.color_ = color;
        };
        /**
         * Set the line cap.
         *
         * @param {CanvasLineCap|undefined} lineCap Line cap.
         * @api
         */
        Stroke.prototype.setLineCap = function (lineCap) {
            this.lineCap_ = lineCap;
        };
        /**
         * Set the line dash.
         *
         * Please note that Internet Explorer 10 and lower [do not support][mdn] the
         * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
         * property will have no visual effect in these browsers.
         *
         * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
         *
         * @param {Array<number>} lineDash Line dash.
         * @api
         */
        Stroke.prototype.setLineDash = function (lineDash) {
            this.lineDash_ = lineDash;
        };
        /**
         * Set the line dash offset.
         *
         * @param {number|undefined} lineDashOffset Line dash offset.
         * @api
         */
        Stroke.prototype.setLineDashOffset = function (lineDashOffset) {
            this.lineDashOffset_ = lineDashOffset;
        };
        /**
         * Set the line join.
         *
         * @param {CanvasLineJoin|undefined} lineJoin Line join.
         * @api
         */
        Stroke.prototype.setLineJoin = function (lineJoin) {
            this.lineJoin_ = lineJoin;
        };
        /**
         * Set the miter limit.
         *
         * @param {number|undefined} miterLimit Miter limit.
         * @api
         */
        Stroke.prototype.setMiterLimit = function (miterLimit) {
            this.miterLimit_ = miterLimit;
        };
        /**
         * Set the width.
         *
         * @param {number|undefined} width Width.
         * @api
         */
        Stroke.prototype.setWidth = function (width) {
            this.width_ = width;
        };
        return Stroke;
    }());

    /**
     * @module ol/colorlike
     */
    /**
     * A type accepted by CanvasRenderingContext2D.fillStyle
     * or CanvasRenderingContext2D.strokeStyle.
     * Represents a color, pattern, or gradient. The origin for patterns and
     * gradients as fill style is an increment of 512 css pixels from map coordinate
     * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
     * must be a factor of two (2, 4, 8, ..., 512).
     *
     * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
     * @api
     */
    /**
     * @param {import("./color.js").Color|ColorLike} color Color.
     * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
     * @api
     */
    function asColorLike(color) {
        if (Array.isArray(color)) {
            return toString$1(color);
        }
        else {
            return color;
        }
    }

    /**
     * @module ol/css
     */
    /**
     * @typedef {Object} FontParameters
     * @property {string} style
     * @property {string} variant
     * @property {string} weight
     * @property {string} size
     * @property {string} lineHeight
     * @property {string} family
     * @property {Array<string>} families
     */
    /**
     * The CSS class for hidden feature.
     *
     * @const
     * @type {string}
     */
    var CLASS_HIDDEN = 'ol-hidden';
    /**
     * The CSS class that we'll give the DOM elements to have them unselectable.
     *
     * @const
     * @type {string}
     */
    var CLASS_UNSELECTABLE = 'ol-unselectable';
    /**
     * The CSS class for controls.
     *
     * @const
     * @type {string}
     */
    var CLASS_CONTROL = 'ol-control';
    /**
     * The CSS class that we'll give the DOM elements that are collapsed, i.e.
     * to those elements which usually can be expanded.
     *
     * @const
     * @type {string}
     */
    var CLASS_COLLAPSED = 'ol-collapsed';
    /**
     * From http://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
     * @type {RegExp}
     */
    var fontRegEx = new RegExp([
        '^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)',
        '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)',
        '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',
        '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?',
        '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))',
        '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))',
        '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$',
    ].join(''), 'i');
    var fontRegExMatchIndex = [
        'style',
        'variant',
        'weight',
        'size',
        'lineHeight',
        'family',
    ];
    /**
     * Get the list of font families from a font spec.  Note that this doesn't work
     * for font families that have commas in them.
     * @param {string} fontSpec The CSS font property.
     * @return {FontParameters} The font parameters (or null if the input spec is invalid).
     */
    var getFontParameters = function (fontSpec) {
        var match = fontSpec.match(fontRegEx);
        if (!match) {
            return null;
        }
        var style = /** @type {FontParameters} */ ({
            lineHeight: 'normal',
            size: '1.2em',
            style: 'normal',
            weight: 'normal',
            variant: 'normal',
        });
        for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
            var value = match[i + 1];
            if (value !== undefined) {
                style[fontRegExMatchIndex[i]] = value;
            }
        }
        style.families = style.family.split(/,\s?/);
        return style;
    };

    /**
     * @module ol/render/canvas
     */
    /**
     * @typedef {Object} FillState
     * @property {import("../colorlike.js").ColorLike} fillStyle
     */
    /**
     * @typedef Label
     * @property {number} width
     * @property {number} height
     * @property {Array<string|number>} contextInstructions
     */
    /**
     * @typedef {Object} FillStrokeState
     * @property {import("../colorlike.js").ColorLike} [currentFillStyle]
     * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle]
     * @property {CanvasLineCap} [currentLineCap]
     * @property {Array<number>} currentLineDash
     * @property {number} [currentLineDashOffset]
     * @property {CanvasLineJoin} [currentLineJoin]
     * @property {number} [currentLineWidth]
     * @property {number} [currentMiterLimit]
     * @property {number} [lastStroke]
     * @property {import("../colorlike.js").ColorLike} [fillStyle]
     * @property {import("../colorlike.js").ColorLike} [strokeStyle]
     * @property {CanvasLineCap} [lineCap]
     * @property {Array<number>} lineDash
     * @property {number} [lineDashOffset]
     * @property {CanvasLineJoin} [lineJoin]
     * @property {number} [lineWidth]
     * @property {number} [miterLimit]
     */
    /**
     * @typedef {Object} StrokeState
     * @property {CanvasLineCap} lineCap
     * @property {Array<number>} lineDash
     * @property {number} lineDashOffset
     * @property {CanvasLineJoin} lineJoin
     * @property {number} lineWidth
     * @property {number} miterLimit
     * @property {import("../colorlike.js").ColorLike} strokeStyle
     */
    /**
     * @typedef {Object} TextState
     * @property {string} font
     * @property {string} [textAlign]
     * @property {string} textBaseline
     * @property {string} [placement]
     * @property {number} [maxAngle]
     * @property {boolean} [overflow]
     * @property {import("../style/Fill.js").default} [backgroundFill]
     * @property {import("../style/Stroke.js").default} [backgroundStroke]
     * @property {import("../size.js").Size} [scale]
     * @property {Array<number>} [padding]
     */
    /**
     * @typedef {Object} SerializableInstructions
     * @property {Array<*>} instructions The rendering instructions.
     * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
     * @property {Array<number>} coordinates The array of all coordinates.
     * @property {!Object<string, TextState>} [textStates] The text states (decluttering).
     * @property {!Object<string, FillState>} [fillStates] The fill states (decluttering).
     * @property {!Object<string, StrokeState>} [strokeStates] The stroke states (decluttering).
     */
    /**
     * @typedef {Object<number, import("./canvas/Executor.js").ReplayImageOrLabelArgs>} DeclutterImageWithText
     */
    /**
     * @const
     * @type {string}
     */
    var defaultFont = '10px sans-serif';
    /**
     * @const
     * @type {import("../colorlike.js").ColorLike}
     */
    var defaultFillStyle = '#000';
    /**
     * @const
     * @type {CanvasLineCap}
     */
    var defaultLineCap = 'round';
    /**
     * @const
     * @type {Array<number>}
     */
    var defaultLineDash = [];
    /**
     * @const
     * @type {number}
     */
    var defaultLineDashOffset = 0;
    /**
     * @const
     * @type {CanvasLineJoin}
     */
    var defaultLineJoin = 'round';
    /**
     * @const
     * @type {number}
     */
    var defaultMiterLimit = 10;
    /**
     * @const
     * @type {import("../colorlike.js").ColorLike}
     */
    var defaultStrokeStyle = '#000';
    /**
     * @const
     * @type {string}
     */
    var defaultTextAlign = 'center';
    /**
     * @const
     * @type {string}
     */
    var defaultTextBaseline = 'middle';
    /**
     * @const
     * @type {Array<number>}
     */
    var defaultPadding = [0, 0, 0, 0];
    /**
     * @const
     * @type {number}
     */
    var defaultLineWidth = 1;
    /**
     * @type {BaseObject}
     */
    var checkedFonts = new BaseObject();
    /**
     * The label cache for text rendering. To change the default cache size of 2048
     * entries, use {@link module:ol/structs/LRUCache#setSize}.
     * Deprecated - there is no label cache any more.
     * @type {?}
     * @api
     * @deprecated
     */
    var labelCache = new Target();
    labelCache.setSize = function () {
        console.warn('labelCache is deprecated.'); //eslint-disable-line
    };
    /**
     * @type {CanvasRenderingContext2D}
     */
    var measureContext = null;
    /**
     * @type {string}
     */
    var measureFont;
    /**
     * @type {!Object<string, number>}
     */
    var textHeights = {};
    /**
     * Clears the label cache when a font becomes available.
     * @param {string} fontSpec CSS font spec.
     */
    var registerFont = (function () {
        var retries = 100;
        var size = '32px ';
        var referenceFonts = ['monospace', 'serif'];
        var len = referenceFonts.length;
        var text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
        var interval, referenceWidth;
        /**
         * @param {string} fontStyle Css font-style
         * @param {string} fontWeight Css font-weight
         * @param {*} fontFamily Css font-family
         * @return {boolean} Font with style and weight is available
         */
        function isAvailable(fontStyle, fontWeight, fontFamily) {
            var available = true;
            for (var i = 0; i < len; ++i) {
                var referenceFont = referenceFonts[i];
                referenceWidth = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + referenceFont, text);
                if (fontFamily != referenceFont) {
                    var width = measureTextWidth(fontStyle +
                        ' ' +
                        fontWeight +
                        ' ' +
                        size +
                        fontFamily +
                        ',' +
                        referenceFont, text);
                    // If width and referenceWidth are the same, then the fallback was used
                    // instead of the font we wanted, so the font is not available.
                    available = available && width != referenceWidth;
                }
            }
            if (available) {
                return true;
            }
            return false;
        }
        function check() {
            var done = true;
            var fonts = checkedFonts.getKeys();
            for (var i = 0, ii = fonts.length; i < ii; ++i) {
                var font = fonts[i];
                if (checkedFonts.get(font) < retries) {
                    if (isAvailable.apply(this, font.split('\n'))) {
                        clear(textHeights);
                        // Make sure that loaded fonts are picked up by Safari
                        measureContext = null;
                        measureFont = undefined;
                        checkedFonts.set(font, retries);
                    }
                    else {
                        checkedFonts.set(font, checkedFonts.get(font) + 1, true);
                        done = false;
                    }
                }
            }
            if (done) {
                clearInterval(interval);
                interval = undefined;
            }
        }
        return function (fontSpec) {
            var font = getFontParameters(fontSpec);
            if (!font) {
                return;
            }
            var families = font.families;
            for (var i = 0, ii = families.length; i < ii; ++i) {
                var family = families[i];
                var key = font.style + '\n' + font.weight + '\n' + family;
                if (checkedFonts.get(key) === undefined) {
                    checkedFonts.set(key, retries, true);
                    if (!isAvailable(font.style, font.weight, family)) {
                        checkedFonts.set(key, 0, true);
                        if (interval === undefined) {
                            interval = setInterval(check, 32);
                        }
                    }
                }
            }
        };
    })();
    /**
     * @param {string} font Font to use for measuring.
     * @return {import("../size.js").Size} Measurement.
     */
    var measureTextHeight = (function () {
        /**
         * @type {HTMLDivElement}
         */
        var div;
        return function (fontSpec) {
            var height = textHeights[fontSpec];
            if (height == undefined) {
                if (WORKER_OFFSCREEN_CANVAS) {
                    var font = getFontParameters(fontSpec);
                    var metrics = measureText(fontSpec, 'Žg');
                    var lineHeight = isNaN(Number(font.lineHeight))
                        ? 1.2
                        : Number(font.lineHeight);
                    height =
                        lineHeight *
                            (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
                }
                else {
                    if (!div) {
                        div = document.createElement('div');
                        div.innerHTML = 'M';
                        div.style.margin = '0 !important';
                        div.style.padding = '0 !important';
                        div.style.position = 'absolute !important';
                        div.style.left = '-99999px !important';
                    }
                    div.style.font = fontSpec;
                    document.body.appendChild(div);
                    height = div.offsetHeight;
                    document.body.removeChild(div);
                }
                textHeights[fontSpec] = height;
            }
            return height;
        };
    })();
    /**
     * @param {string} font Font.
     * @param {string} text Text.
     * @return {TextMetrics} Text metrics.
     */
    function measureText(font, text) {
        if (!measureContext) {
            measureContext = createCanvasContext2D(1, 1);
        }
        if (font != measureFont) {
            measureContext.font = font;
            measureFont = measureContext.font;
        }
        return measureContext.measureText(text);
    }
    /**
     * @param {string} font Font.
     * @param {string} text Text.
     * @return {number} Width.
     */
    function measureTextWidth(font, text) {
        return measureText(font, text).width;
    }
    /**
     * Measure text width using a cache.
     * @param {string} font The font.
     * @param {string} text The text to measure.
     * @param {Object<string, number>} cache A lookup of cached widths by text.
     * @returns {number} The text width.
     */
    function measureAndCacheTextWidth(font, text, cache) {
        if (text in cache) {
            return cache[text];
        }
        var width = measureTextWidth(font, text);
        cache[text] = width;
        return width;
    }
    /**
     * @param {string} font Font to use for measuring.
     * @param {Array<string>} lines Lines to measure.
     * @param {Array<number>} widths Array will be populated with the widths of
     * each line.
     * @return {number} Width of the whole text.
     */
    function measureTextWidths(font, lines, widths) {
        var numLines = lines.length;
        var width = 0;
        for (var i = 0; i < numLines; ++i) {
            var currentWidth = measureTextWidth(font, lines[i]);
            width = Math.max(width, currentWidth);
            widths.push(currentWidth);
        }
        return width;
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} rotation Rotation.
     * @param {number} offsetX X offset.
     * @param {number} offsetY Y offset.
     */
    function rotateAtOffset(context, rotation, offsetX, offsetY) {
        if (rotation !== 0) {
            context.translate(offsetX, offsetY);
            context.rotate(rotation);
            context.translate(-offsetX, -offsetY);
        }
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../transform.js").Transform|null} transform Transform.
     * @param {number} opacity Opacity.
     * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
     * @param {number} originX Origin X.
     * @param {number} originY Origin Y.
     * @param {number} w Width.
     * @param {number} h Height.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../size.js").Size} scale Scale.
     */
    function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
        context.save();
        if (opacity !== 1) {
            context.globalAlpha *= opacity;
        }
        if (transform) {
            context.setTransform.apply(context, transform);
        }
        if ( /** @type {*} */(labelOrImage).contextInstructions) {
            // label
            context.translate(x, y);
            context.scale(scale[0], scale[1]);
            executeLabelInstructions(/** @type {Label} */ (labelOrImage), context);
        }
        else if (scale[0] < 0 || scale[1] < 0) {
            // flipped image
            context.translate(x, y);
            context.scale(scale[0], scale[1]);
            context.drawImage(
            /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (labelOrImage), originX, originY, w, h, 0, 0, w, h);
        }
        else {
            // if image not flipped translate and scale can be avoided
            context.drawImage(
            /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (labelOrImage), originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
        }
        context.restore();
    }
    /**
     * @param {Label} label Label.
     * @param {CanvasRenderingContext2D} context Context.
     */
    function executeLabelInstructions(label, context) {
        var contextInstructions = label.contextInstructions;
        for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
            if (Array.isArray(contextInstructions[i + 1])) {
                context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
            }
            else {
                context[contextInstructions[i]] = contextInstructions[i + 1];
            }
        }
    }
    /**
     * @type {HTMLCanvasElement}
     * @private
     */
    var createTransformStringCanvas = null;
    /**
     * @param {import("../transform.js").Transform} transform Transform.
     * @return {string} CSS transform.
     */
    function createTransformString(transform) {
        if (WORKER_OFFSCREEN_CANVAS) {
            return toString$2(transform);
        }
        else {
            if (!createTransformStringCanvas) {
                createTransformStringCanvas = createCanvasContext2D(1, 1).canvas;
            }
            createTransformStringCanvas.style.transform = toString$2(transform);
            return createTransformStringCanvas.style.transform;
        }
    }

    /**
     * @module ol/style/RegularShape
     */
    var __extends$Y = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * Specify radius for regular polygons, or radius1 and radius2 for stars.
     * @typedef {Object} Options
     * @property {import("./Fill.js").default} [fill] Fill style.
     * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
     * is the number of sides.
     * @property {number} [radius] Radius of a regular polygon.
     * @property {number} [radius1] Outer radius of a star.
     * @property {number} [radius2] Inner radius of a star.
     * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
     * @property {Array<number>} [displacement=[0,0]] Displacement of the shape
     * @property {import("./Stroke.js").default} [stroke] Stroke style.
     * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
     * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
     * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
     * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.
     */
    /**
     * @typedef {Object} RenderOptions
     * @property {import("../colorlike.js").ColorLike} [strokeStyle]
     * @property {number} strokeWidth
     * @property {number} size
     * @property {CanvasLineCap} lineCap
     * @property {Array<number>} lineDash
     * @property {number} lineDashOffset
     * @property {CanvasLineJoin} lineJoin
     * @property {number} miterLimit
     */
    /**
     * @classdesc
     * Set regular shape style for vector features. The resulting shape will be
     * a regular polygon when `radius` is provided, or a star when `radius1` and
     * `radius2` are provided.
     * @api
     */
    var RegularShape = /** @class */ (function (_super) {
        __extends$Y(RegularShape, _super);
        /**
         * @param {Options} options Options.
         */
        function RegularShape(options) {
            var _this = this;
            /**
             * @type {boolean}
             */
            var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
            _this = _super.call(this, {
                opacity: 1,
                rotateWithView: rotateWithView,
                rotation: options.rotation !== undefined ? options.rotation : 0,
                scale: options.scale !== undefined ? options.scale : 1,
                displacement: options.displacement !== undefined ? options.displacement : [0, 0],
            }) || this;
            /**
             * @private
             * @type {Object<number, HTMLCanvasElement>}
             */
            _this.canvas_ = {};
            /**
             * @private
             * @type {HTMLCanvasElement}
             */
            _this.hitDetectionCanvas_ = null;
            /**
             * @private
             * @type {import("./Fill.js").default}
             */
            _this.fill_ = options.fill !== undefined ? options.fill : null;
            /**
             * @private
             * @type {Array<number>}
             */
            _this.origin_ = [0, 0];
            /**
             * @private
             * @type {number}
             */
            _this.points_ = options.points;
            /**
             * @protected
             * @type {number}
             */
            _this.radius_ =
                options.radius !== undefined ? options.radius : options.radius1;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.radius2_ = options.radius2;
            /**
             * @private
             * @type {number}
             */
            _this.angle_ = options.angle !== undefined ? options.angle : 0;
            /**
             * @private
             * @type {import("./Stroke.js").default}
             */
            _this.stroke_ = options.stroke !== undefined ? options.stroke : null;
            /**
             * @private
             * @type {Array<number>}
             */
            _this.anchor_ = null;
            /**
             * @private
             * @type {import("../size.js").Size}
             */
            _this.size_ = null;
            /**
             * @private
             * @type {import("../size.js").Size}
             */
            _this.imageSize_ = null;
            /**
             * @private
             * @type {import("../size.js").Size}
             */
            _this.hitDetectionImageSize_ = null;
            _this.render();
            return _this;
        }
        /**
         * Clones the style.
         * @return {RegularShape} The cloned style.
         * @api
         */
        RegularShape.prototype.clone = function () {
            var scale = this.getScale();
            var style = new RegularShape({
                fill: this.getFill() ? this.getFill().clone() : undefined,
                points: this.getPoints(),
                radius: this.getRadius(),
                radius2: this.getRadius2(),
                angle: this.getAngle(),
                stroke: this.getStroke() ? this.getStroke().clone() : undefined,
                rotation: this.getRotation(),
                rotateWithView: this.getRotateWithView(),
                scale: Array.isArray(scale) ? scale.slice() : scale,
                displacement: this.getDisplacement().slice(),
            });
            style.setOpacity(this.getOpacity());
            return style;
        };
        /**
         * Get the anchor point in pixels. The anchor determines the center point for the
         * symbolizer.
         * @return {Array<number>} Anchor.
         * @api
         */
        RegularShape.prototype.getAnchor = function () {
            return this.anchor_;
        };
        /**
         * Get the angle used in generating the shape.
         * @return {number} Shape's rotation in radians.
         * @api
         */
        RegularShape.prototype.getAngle = function () {
            return this.angle_;
        };
        /**
         * Get the fill style for the shape.
         * @return {import("./Fill.js").default} Fill style.
         * @api
         */
        RegularShape.prototype.getFill = function () {
            return this.fill_;
        };
        /**
         * @return {HTMLCanvasElement} Image element.
         */
        RegularShape.prototype.getHitDetectionImage = function () {
            if (!this.hitDetectionCanvas_) {
                var renderOptions = this.createRenderOptions();
                this.createHitDetectionCanvas_(renderOptions);
            }
            return this.hitDetectionCanvas_;
        };
        /**
         * Get the image icon.
         * @param {number} pixelRatio Pixel ratio.
         * @return {HTMLCanvasElement} Image or Canvas element.
         * @api
         */
        RegularShape.prototype.getImage = function (pixelRatio) {
            if (!this.canvas_[pixelRatio || 1]) {
                var renderOptions = this.createRenderOptions();
                var context = createCanvasContext2D(renderOptions.size * pixelRatio || 1, renderOptions.size * pixelRatio || 1);
                this.draw_(renderOptions, context, 0, 0, pixelRatio || 1);
                this.canvas_[pixelRatio || 1] = context.canvas;
            }
            return this.canvas_[pixelRatio || 1];
        };
        /*
         * Get the image pixel ratio.
         * @param {number} pixelRatio Pixel ratio.
         * */
        RegularShape.prototype.getPixelRatio = function (pixelRatio) {
            return pixelRatio;
        };
        /**
         * @return {import("../size.js").Size} Image size.
         */
        RegularShape.prototype.getImageSize = function () {
            return this.imageSize_;
        };
        /**
         * @return {import("../size.js").Size} Size of the hit-detection image.
         */
        RegularShape.prototype.getHitDetectionImageSize = function () {
            return this.hitDetectionImageSize_;
        };
        /**
         * @return {import("../ImageState.js").default} Image state.
         */
        RegularShape.prototype.getImageState = function () {
            return ImageState.LOADED;
        };
        /**
         * Get the origin of the symbolizer.
         * @return {Array<number>} Origin.
         * @api
         */
        RegularShape.prototype.getOrigin = function () {
            return this.origin_;
        };
        /**
         * Get the number of points for generating the shape.
         * @return {number} Number of points for stars and regular polygons.
         * @api
         */
        RegularShape.prototype.getPoints = function () {
            return this.points_;
        };
        /**
         * Get the (primary) radius for the shape.
         * @return {number} Radius.
         * @api
         */
        RegularShape.prototype.getRadius = function () {
            return this.radius_;
        };
        /**
         * Get the secondary radius for the shape.
         * @return {number|undefined} Radius2.
         * @api
         */
        RegularShape.prototype.getRadius2 = function () {
            return this.radius2_;
        };
        /**
         * Get the size of the symbolizer (in pixels).
         * @return {import("../size.js").Size} Size.
         * @api
         */
        RegularShape.prototype.getSize = function () {
            return this.size_;
        };
        /**
         * Get the stroke style for the shape.
         * @return {import("./Stroke.js").default} Stroke style.
         * @api
         */
        RegularShape.prototype.getStroke = function () {
            return this.stroke_;
        };
        /**
         * @param {function(import("../events/Event.js").default): void} listener Listener function.
         */
        RegularShape.prototype.listenImageChange = function (listener) { };
        /**
         * Load not yet loaded URI.
         */
        RegularShape.prototype.load = function () { };
        /**
         * @param {function(import("../events/Event.js").default): void} listener Listener function.
         */
        RegularShape.prototype.unlistenImageChange = function (listener) { };
        /**
         * @returns {RenderOptions}  The render options
         * @protected
         */
        RegularShape.prototype.createRenderOptions = function () {
            var lineCap = defaultLineCap;
            var lineJoin = defaultLineJoin;
            var miterLimit = 0;
            var lineDash = null;
            var lineDashOffset = 0;
            var strokeStyle;
            var strokeWidth = 0;
            if (this.stroke_) {
                strokeStyle = this.stroke_.getColor();
                if (strokeStyle === null) {
                    strokeStyle = defaultStrokeStyle;
                }
                strokeStyle = asColorLike(strokeStyle);
                strokeWidth = this.stroke_.getWidth();
                if (strokeWidth === undefined) {
                    strokeWidth = defaultLineWidth;
                }
                lineDash = this.stroke_.getLineDash();
                lineDashOffset = this.stroke_.getLineDashOffset();
                lineJoin = this.stroke_.getLineJoin();
                if (lineJoin === undefined) {
                    lineJoin = defaultLineJoin;
                }
                lineCap = this.stroke_.getLineCap();
                if (lineCap === undefined) {
                    lineCap = defaultLineCap;
                }
                miterLimit = this.stroke_.getMiterLimit();
                if (miterLimit === undefined) {
                    miterLimit = defaultMiterLimit;
                }
            }
            var size = 2 * (this.radius_ + strokeWidth) + 1;
            return {
                strokeStyle: strokeStyle,
                strokeWidth: strokeWidth,
                size: size,
                lineCap: lineCap,
                lineDash: lineDash,
                lineDashOffset: lineDashOffset,
                lineJoin: lineJoin,
                miterLimit: miterLimit,
            };
        };
        /**
         * @protected
         */
        RegularShape.prototype.render = function () {
            var renderOptions = this.createRenderOptions();
            var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
            this.draw_(renderOptions, context, 0, 0, 1);
            this.canvas_ = {};
            this.canvas_[1] = context.canvas;
            // canvas.width and height are rounded to the closest integer
            var size = context.canvas.width;
            var imageSize = size;
            var displacement = this.getDisplacement();
            this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
            this.createHitDetectionCanvas_(renderOptions);
            this.anchor_ = [size / 2 - displacement[0], size / 2 + displacement[1]];
            this.size_ = [size, size];
            this.imageSize_ = [imageSize, imageSize];
        };
        /**
         * @private
         * @param {RenderOptions} renderOptions Render options.
         * @param {CanvasRenderingContext2D} context The rendering context.
         * @param {number} x The origin for the symbol (x).
         * @param {number} y The origin for the symbol (y).
         * @param {number} pixelRatio The pixel ratio.
         */
        RegularShape.prototype.draw_ = function (renderOptions, context, x, y, pixelRatio) {
            var i, angle0, radiusC;
            // reset transform
            context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            // then move to (x, y)
            context.translate(x, y);
            context.beginPath();
            var points = this.points_;
            if (points === Infinity) {
                context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
            }
            else {
                var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;
                if (radius2 !== this.radius_) {
                    points = 2 * points;
                }
                for (i = 0; i <= points; i++) {
                    angle0 = (i * 2 * Math.PI) / points - Math.PI / 2 + this.angle_;
                    radiusC = i % 2 === 0 ? this.radius_ : radius2;
                    context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
                }
            }
            if (this.fill_) {
                var color = this.fill_.getColor();
                if (color === null) {
                    color = defaultFillStyle;
                }
                context.fillStyle = asColorLike(color);
                context.fill();
            }
            if (this.stroke_) {
                context.strokeStyle = renderOptions.strokeStyle;
                context.lineWidth = renderOptions.strokeWidth;
                if (context.setLineDash && renderOptions.lineDash) {
                    context.setLineDash(renderOptions.lineDash);
                    context.lineDashOffset = renderOptions.lineDashOffset;
                }
                context.lineCap = renderOptions.lineCap;
                context.lineJoin = renderOptions.lineJoin;
                context.miterLimit = renderOptions.miterLimit;
                context.stroke();
            }
            context.closePath();
        };
        /**
         * @private
         * @param {RenderOptions} renderOptions Render options.
         */
        RegularShape.prototype.createHitDetectionCanvas_ = function (renderOptions) {
            this.hitDetectionCanvas_ = this.getImage(1);
            if (this.fill_) {
                var color = this.fill_.getColor();
                // determine if fill is transparent (or pattern or gradient)
                var opacity = 0;
                if (typeof color === 'string') {
                    color = asArray(color);
                }
                if (color === null) {
                    opacity = 1;
                }
                else if (Array.isArray(color)) {
                    opacity = color.length === 4 ? color[3] : 1;
                }
                if (opacity === 0) {
                    // if a transparent fill style is set, create an extra hit-detection image
                    // with a default fill style
                    var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
                    this.hitDetectionCanvas_ = context.canvas;
                    this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
                }
            }
        };
        /**
         * @private
         * @param {RenderOptions} renderOptions Render options.
         * @param {CanvasRenderingContext2D} context The context.
         * @param {number} x The origin for the symbol (x).
         * @param {number} y The origin for the symbol (y).
         */
        RegularShape.prototype.drawHitDetectionCanvas_ = function (renderOptions, context, x, y) {
            // move to (x, y)
            context.translate(x, y);
            context.beginPath();
            var points = this.points_;
            if (points === Infinity) {
                context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
            }
            else {
                var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;
                if (radius2 !== this.radius_) {
                    points = 2 * points;
                }
                var i = void 0, radiusC = void 0, angle0 = void 0;
                for (i = 0; i <= points; i++) {
                    angle0 = (i * 2 * Math.PI) / points - Math.PI / 2 + this.angle_;
                    radiusC = i % 2 === 0 ? this.radius_ : radius2;
                    context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
                }
            }
            context.fillStyle = defaultFillStyle;
            context.fill();
            if (this.stroke_) {
                context.strokeStyle = renderOptions.strokeStyle;
                context.lineWidth = renderOptions.strokeWidth;
                if (renderOptions.lineDash) {
                    context.setLineDash(renderOptions.lineDash);
                    context.lineDashOffset = renderOptions.lineDashOffset;
                }
                context.stroke();
            }
            context.closePath();
        };
        return RegularShape;
    }(ImageStyle));

    /**
     * @module ol/style/Circle
     */
    var __extends$X = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {import("./Fill.js").default} [fill] Fill style.
     * @property {number} radius Circle radius.
     * @property {import("./Stroke.js").default} [stroke] Stroke style.
     * @property {Array<number>} [displacement=[0,0]] displacement
     * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
     * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
     * @property {number} [rotation=0] Rotation in radians
     * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
     * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
     * (meaningful only when used in conjunction with a two dimensional scale).
     */
    /**
     * @classdesc
     * Set circle style for vector features.
     * @api
     */
    var CircleStyle = /** @class */ (function (_super) {
        __extends$X(CircleStyle, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function CircleStyle(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
                points: Infinity,
                fill: options.fill,
                radius: options.radius,
                stroke: options.stroke,
                scale: options.scale !== undefined ? options.scale : 1,
                rotation: options.rotation !== undefined ? options.rotation : 0,
                rotateWithView: options.rotateWithView !== undefined ? options.rotateWithView : false,
                displacement: options.displacement !== undefined ? options.displacement : [0, 0],
            }) || this;
            return _this;
        }
        /**
         * Clones the style.
         * @return {CircleStyle} The cloned style.
         * @api
         */
        CircleStyle.prototype.clone = function () {
            var scale = this.getScale();
            var style = new CircleStyle({
                fill: this.getFill() ? this.getFill().clone() : undefined,
                stroke: this.getStroke() ? this.getStroke().clone() : undefined,
                radius: this.getRadius(),
                scale: Array.isArray(scale) ? scale.slice() : scale,
                rotation: this.getRotation(),
                rotateWithView: this.getRotateWithView(),
                displacement: this.getDisplacement().slice(),
            });
            style.setOpacity(this.getOpacity());
            return style;
        };
        /**
         * Set the circle radius.
         *
         * @param {number} radius Circle radius.
         * @api
         */
        CircleStyle.prototype.setRadius = function (radius) {
            this.radius_ = radius;
            this.render();
        };
        return CircleStyle;
    }(RegularShape));

    /**
     * @module ol/style/Style
     */
    /**
     * A function that takes an {@link module:ol/Feature} and a `{number}`
     * representing the view's resolution. The function should return a
     * {@link module:ol/style/Style} or an array of them. This way e.g. a
     * vector layer can be styled. If the function returns `undefined`, the
     * feature will not be rendered.
     *
     * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
     */
    /**
     * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
     * @typedef {Style|Array<Style>|StyleFunction} StyleLike
     */
    /**
     * A function that takes an {@link module:ol/Feature} as argument and returns an
     * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.
     *
     * @typedef {function(import("../Feature.js").FeatureLike):
     *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
     */
    /**
     * Custom renderer function. Takes two arguments:
     *
     * 1. The pixel coordinates of the geometry in GeoJSON notation.
     * 2. The {@link module:ol/render~State} of the layer renderer.
     *
     * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State): void}
     * RenderFunction
     */
    /**
     * @typedef {Object} Options
     * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
     * or function returning a geometry to render for this style.
     * @property {import("./Fill.js").default} [fill] Fill style.
     * @property {import("./Image.js").default} [image] Image style.
     * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
     * ignored, and the provided function will be called with each render frame for each geometry.
     * @property {import("./Stroke.js").default} [stroke] Stroke style.
     * @property {import("./Text.js").default} [text] Text style.
     * @property {number} [zIndex] Z index.
     */
    /**
     * @classdesc
     * Container for vector feature rendering styles. Any changes made to the style
     * or its children through `set*()` methods will not take effect until the
     * feature or layer that uses the style is re-rendered.
     *
     * ## Feature styles
     *
     * If no style is defined, the following default style is used:
     * ```js
     *  import {Fill, Stroke, Circle, Style} from 'ol/style';
     *
     *  var fill = new Fill({
     *    color: 'rgba(255,255,255,0.4)'
     *  });
     *  var stroke = new Stroke({
     *    color: '#3399CC',
     *    width: 1.25
     *  });
     *  var styles = [
     *    new Style({
     *      image: new Circle({
     *        fill: fill,
     *        stroke: stroke,
     *        radius: 5
     *      }),
     *      fill: fill,
     *      stroke: stroke
     *    })
     *  ];
     * ```
     *
     * A separate editing style has the following defaults:
     * ```js
     *  import {Fill, Stroke, Circle, Style} from 'ol/style';
     *  import GeometryType from 'ol/geom/GeometryType';
     *
     *  var white = [255, 255, 255, 1];
     *  var blue = [0, 153, 255, 1];
     *  var width = 3;
     *  styles[GeometryType.POLYGON] = [
     *    new Style({
     *      fill: new Fill({
     *        color: [255, 255, 255, 0.5]
     *      })
     *    })
     *  ];
     *  styles[GeometryType.MULTI_POLYGON] =
     *      styles[GeometryType.POLYGON];
     *  styles[GeometryType.LINE_STRING] = [
     *    new Style({
     *      stroke: new Stroke({
     *        color: white,
     *        width: width + 2
     *      })
     *    }),
     *    new Style({
     *      stroke: new Stroke({
     *        color: blue,
     *        width: width
     *      })
     *    })
     *  ];
     *  styles[GeometryType.MULTI_LINE_STRING] =
     *      styles[GeometryType.LINE_STRING];
     *  styles[GeometryType.POINT] = [
     *    new Style({
     *      image: new Circle({
     *        radius: width * 2,
     *        fill: new Fill({
     *          color: blue
     *        }),
     *        stroke: new Stroke({
     *          color: white,
     *          width: width / 2
     *        })
     *      }),
     *      zIndex: Infinity
     *    })
     *  ];
     *  styles[GeometryType.MULTI_POINT] =
     *      styles[GeometryType.POINT];
     *  styles[GeometryType.GEOMETRY_COLLECTION] =
     *      styles[GeometryType.POLYGON].concat(
     *          styles[GeometryType.LINE_STRING],
     *          styles[GeometryType.POINT]
     *      );
     * ```
     *
     * @api
     */
    var Style = /** @class */ (function () {
        /**
         * @param {Options=} opt_options Style options.
         */
        function Style(opt_options) {
            var options = opt_options || {};
            /**
             * @private
             * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
             */
            this.geometry_ = null;
            /**
             * @private
             * @type {!GeometryFunction}
             */
            this.geometryFunction_ = defaultGeometryFunction;
            if (options.geometry !== undefined) {
                this.setGeometry(options.geometry);
            }
            /**
             * @private
             * @type {import("./Fill.js").default}
             */
            this.fill_ = options.fill !== undefined ? options.fill : null;
            /**
             * @private
             * @type {import("./Image.js").default}
             */
            this.image_ = options.image !== undefined ? options.image : null;
            /**
             * @private
             * @type {RenderFunction|null}
             */
            this.renderer_ = options.renderer !== undefined ? options.renderer : null;
            /**
             * @private
             * @type {import("./Stroke.js").default}
             */
            this.stroke_ = options.stroke !== undefined ? options.stroke : null;
            /**
             * @private
             * @type {import("./Text.js").default}
             */
            this.text_ = options.text !== undefined ? options.text : null;
            /**
             * @private
             * @type {number|undefined}
             */
            this.zIndex_ = options.zIndex;
        }
        /**
         * Clones the style.
         * @return {Style} The cloned style.
         * @api
         */
        Style.prototype.clone = function () {
            var geometry = this.getGeometry();
            if (geometry && typeof geometry === 'object') {
                geometry = /** @type {import("../geom/Geometry.js").default} */ (geometry).clone();
            }
            return new Style({
                geometry: geometry,
                fill: this.getFill() ? this.getFill().clone() : undefined,
                image: this.getImage() ? this.getImage().clone() : undefined,
                stroke: this.getStroke() ? this.getStroke().clone() : undefined,
                text: this.getText() ? this.getText().clone() : undefined,
                zIndex: this.getZIndex(),
            });
        };
        /**
         * Get the custom renderer function that was configured with
         * {@link #setRenderer} or the `renderer` constructor option.
         * @return {RenderFunction|null} Custom renderer function.
         * @api
         */
        Style.prototype.getRenderer = function () {
            return this.renderer_;
        };
        /**
         * Sets a custom renderer function for this style. When set, `fill`, `stroke`
         * and `image` options of the style will be ignored.
         * @param {RenderFunction|null} renderer Custom renderer function.
         * @api
         */
        Style.prototype.setRenderer = function (renderer) {
            this.renderer_ = renderer;
        };
        /**
         * Get the geometry to be rendered.
         * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
         * Feature property or geometry or function that returns the geometry that will
         * be rendered with this style.
         * @api
         */
        Style.prototype.getGeometry = function () {
            return this.geometry_;
        };
        /**
         * Get the function used to generate a geometry for rendering.
         * @return {!GeometryFunction} Function that is called with a feature
         * and returns the geometry to render instead of the feature's geometry.
         * @api
         */
        Style.prototype.getGeometryFunction = function () {
            return this.geometryFunction_;
        };
        /**
         * Get the fill style.
         * @return {import("./Fill.js").default} Fill style.
         * @api
         */
        Style.prototype.getFill = function () {
            return this.fill_;
        };
        /**
         * Set the fill style.
         * @param {import("./Fill.js").default} fill Fill style.
         * @api
         */
        Style.prototype.setFill = function (fill) {
            this.fill_ = fill;
        };
        /**
         * Get the image style.
         * @return {import("./Image.js").default} Image style.
         * @api
         */
        Style.prototype.getImage = function () {
            return this.image_;
        };
        /**
         * Set the image style.
         * @param {import("./Image.js").default} image Image style.
         * @api
         */
        Style.prototype.setImage = function (image) {
            this.image_ = image;
        };
        /**
         * Get the stroke style.
         * @return {import("./Stroke.js").default} Stroke style.
         * @api
         */
        Style.prototype.getStroke = function () {
            return this.stroke_;
        };
        /**
         * Set the stroke style.
         * @param {import("./Stroke.js").default} stroke Stroke style.
         * @api
         */
        Style.prototype.setStroke = function (stroke) {
            this.stroke_ = stroke;
        };
        /**
         * Get the text style.
         * @return {import("./Text.js").default} Text style.
         * @api
         */
        Style.prototype.getText = function () {
            return this.text_;
        };
        /**
         * Set the text style.
         * @param {import("./Text.js").default} text Text style.
         * @api
         */
        Style.prototype.setText = function (text) {
            this.text_ = text;
        };
        /**
         * Get the z-index for the style.
         * @return {number|undefined} ZIndex.
         * @api
         */
        Style.prototype.getZIndex = function () {
            return this.zIndex_;
        };
        /**
         * Set a geometry that is rendered instead of the feature's geometry.
         *
         * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
         *     Feature property or geometry or function returning a geometry to render
         *     for this style.
         * @api
         */
        Style.prototype.setGeometry = function (geometry) {
            if (typeof geometry === 'function') {
                this.geometryFunction_ = geometry;
            }
            else if (typeof geometry === 'string') {
                this.geometryFunction_ = function (feature) {
                    return /** @type {import("../geom/Geometry.js").default} */ (feature.get(geometry));
                };
            }
            else if (!geometry) {
                this.geometryFunction_ = defaultGeometryFunction;
            }
            else if (geometry !== undefined) {
                this.geometryFunction_ = function () {
                    return /** @type {import("../geom/Geometry.js").default} */ (geometry);
                };
            }
            this.geometry_ = geometry;
        };
        /**
         * Set the z-index.
         *
         * @param {number|undefined} zIndex ZIndex.
         * @api
         */
        Style.prototype.setZIndex = function (zIndex) {
            this.zIndex_ = zIndex;
        };
        return Style;
    }());
    /**
     * Convert the provided object into a style function.  Functions passed through
     * unchanged.  Arrays of Style or single style objects wrapped in a
     * new style function.
     * @param {StyleFunction|Array<Style>|Style} obj
     *     A style function, a single style, or an array of styles.
     * @return {StyleFunction} A style function.
     */
    function toFunction(obj) {
        var styleFunction;
        if (typeof obj === 'function') {
            styleFunction = obj;
        }
        else {
            /**
             * @type {Array<Style>}
             */
            var styles_1;
            if (Array.isArray(obj)) {
                styles_1 = obj;
            }
            else {
                assert(typeof ( /** @type {?} */(obj).getZIndex) === 'function', 41); // Expected an `Style` or an array of `Style`
                var style = /** @type {Style} */ (obj);
                styles_1 = [style];
            }
            styleFunction = function () {
                return styles_1;
            };
        }
        return styleFunction;
    }
    /**
     * @type {Array<Style>}
     */
    var defaultStyles = null;
    /**
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} resolution Resolution.
     * @return {Array<Style>} Style.
     */
    function createDefaultStyle(feature, resolution) {
        // We don't use an immediately-invoked function
        // and a closure so we don't get an error at script evaluation time in
        // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
        // canvas.getContext('2d') at construction time, which will cause an.error
        // in such browsers.)
        if (!defaultStyles) {
            var fill = new Fill({
                color: 'rgba(255,255,255,0.4)',
            });
            var stroke = new Stroke({
                color: '#3399CC',
                width: 1.25,
            });
            defaultStyles = [
                new Style({
                    image: new CircleStyle({
                        fill: fill,
                        stroke: stroke,
                        radius: 5,
                    }),
                    fill: fill,
                    stroke: stroke,
                }),
            ];
        }
        return defaultStyles;
    }
    /**
     * Function that is called with a feature and returns its default geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
     * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
     */
    function defaultGeometryFunction(feature) {
        return feature.getGeometry();
    }

    /**
     * @module ol/style/TextPlacement
     */
    /**
     * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
     * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
     * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
     * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
     * @enum {string}
     */
    var TextPlacement = {
        POINT: 'point',
        LINE: 'line',
    };

    /**
     * @module ol/CollectionEventType
     */
    /**
     * @enum {string}
     */
    var CollectionEventType = {
        /**
         * Triggered when an item is added to the collection.
         * @event module:ol/Collection.CollectionEvent#add
         * @api
         */
        ADD: 'add',
        /**
         * Triggered when an item is removed from the collection.
         * @event module:ol/Collection.CollectionEvent#remove
         * @api
         */
        REMOVE: 'remove',
    };

    var __extends$W = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @enum {string}
     * @private
     */
    var Property$2 = {
        LENGTH: 'length',
    };
    /**
     * @classdesc
     * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
     * type.
     */
    var CollectionEvent = /** @class */ (function (_super) {
        __extends$W(CollectionEvent, _super);
        /**
         * @param {import("./CollectionEventType.js").default} type Type.
         * @param {*=} opt_element Element.
         * @param {number=} opt_index The index of the added or removed element.
         */
        function CollectionEvent(type, opt_element, opt_index) {
            var _this = _super.call(this, type) || this;
            /**
             * The element that is added to or removed from the collection.
             * @type {*}
             * @api
             */
            _this.element = opt_element;
            /**
             * The index of the added or removed element.
             * @type {number}
             * @api
             */
            _this.index = opt_index;
            return _this;
        }
        return CollectionEvent;
    }(BaseEvent));
    /**
     * @typedef {Object} Options
     * @property {boolean} [unique=false] Disallow the same item from being added to
     * the collection twice.
     */
    /**
     * @classdesc
     * An expanded version of standard JS Array, adding convenience methods for
     * manipulation. Add and remove changes to the Collection trigger a Collection
     * event. Note that this does not cover changes to the objects _within_ the
     * Collection; they trigger events on the appropriate object, not on the
     * Collection as a whole.
     *
     * @fires CollectionEvent
     *
     * @template T
     * @api
     */
    var Collection = /** @class */ (function (_super) {
        __extends$W(Collection, _super);
        /**
         * @param {Array<T>=} opt_array Array.
         * @param {Options=} opt_options Collection options.
         */
        function Collection(opt_array, opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options || {};
            /**
             * @private
             * @type {boolean}
             */
            _this.unique_ = !!options.unique;
            /**
             * @private
             * @type {!Array<T>}
             */
            _this.array_ = opt_array ? opt_array : [];
            if (_this.unique_) {
                for (var i = 0, ii = _this.array_.length; i < ii; ++i) {
                    _this.assertUnique_(_this.array_[i], i);
                }
            }
            _this.updateLength_();
            return _this;
        }
        /**
         * Remove all elements from the collection.
         * @api
         */
        Collection.prototype.clear = function () {
            while (this.getLength() > 0) {
                this.pop();
            }
        };
        /**
         * Add elements to the collection.  This pushes each item in the provided array
         * to the end of the collection.
         * @param {!Array<T>} arr Array.
         * @return {Collection<T>} This collection.
         * @api
         */
        Collection.prototype.extend = function (arr) {
            for (var i = 0, ii = arr.length; i < ii; ++i) {
                this.push(arr[i]);
            }
            return this;
        };
        /**
         * Iterate over each element, calling the provided callback.
         * @param {function(T, number, Array<T>): *} f The function to call
         *     for every element. This function takes 3 arguments (the element, the
         *     index and the array). The return value is ignored.
         * @api
         */
        Collection.prototype.forEach = function (f) {
            var array = this.array_;
            for (var i = 0, ii = array.length; i < ii; ++i) {
                f(array[i], i, array);
            }
        };
        /**
         * Get a reference to the underlying Array object. Warning: if the array
         * is mutated, no events will be dispatched by the collection, and the
         * collection's "length" property won't be in sync with the actual length
         * of the array.
         * @return {!Array<T>} Array.
         * @api
         */
        Collection.prototype.getArray = function () {
            return this.array_;
        };
        /**
         * Get the element at the provided index.
         * @param {number} index Index.
         * @return {T} Element.
         * @api
         */
        Collection.prototype.item = function (index) {
            return this.array_[index];
        };
        /**
         * Get the length of this collection.
         * @return {number} The length of the array.
         * @observable
         * @api
         */
        Collection.prototype.getLength = function () {
            return this.get(Property$2.LENGTH);
        };
        /**
         * Insert an element at the provided index.
         * @param {number} index Index.
         * @param {T} elem Element.
         * @api
         */
        Collection.prototype.insertAt = function (index, elem) {
            if (this.unique_) {
                this.assertUnique_(elem);
            }
            this.array_.splice(index, 0, elem);
            this.updateLength_();
            this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
        };
        /**
         * Remove the last element of the collection and return it.
         * Return `undefined` if the collection is empty.
         * @return {T|undefined} Element.
         * @api
         */
        Collection.prototype.pop = function () {
            return this.removeAt(this.getLength() - 1);
        };
        /**
         * Insert the provided element at the end of the collection.
         * @param {T} elem Element.
         * @return {number} New length of the collection.
         * @api
         */
        Collection.prototype.push = function (elem) {
            if (this.unique_) {
                this.assertUnique_(elem);
            }
            var n = this.getLength();
            this.insertAt(n, elem);
            return this.getLength();
        };
        /**
         * Remove the first occurrence of an element from the collection.
         * @param {T} elem Element.
         * @return {T|undefined} The removed element or undefined if none found.
         * @api
         */
        Collection.prototype.remove = function (elem) {
            var arr = this.array_;
            for (var i = 0, ii = arr.length; i < ii; ++i) {
                if (arr[i] === elem) {
                    return this.removeAt(i);
                }
            }
            return undefined;
        };
        /**
         * Remove the element at the provided index and return it.
         * Return `undefined` if the collection does not contain this index.
         * @param {number} index Index.
         * @return {T|undefined} Value.
         * @api
         */
        Collection.prototype.removeAt = function (index) {
            var prev = this.array_[index];
            this.array_.splice(index, 1);
            this.updateLength_();
            this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
            return prev;
        };
        /**
         * Set the element at the provided index.
         * @param {number} index Index.
         * @param {T} elem Element.
         * @api
         */
        Collection.prototype.setAt = function (index, elem) {
            var n = this.getLength();
            if (index < n) {
                if (this.unique_) {
                    this.assertUnique_(elem, index);
                }
                var prev = this.array_[index];
                this.array_[index] = elem;
                this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
                this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
            }
            else {
                for (var j = n; j < index; ++j) {
                    this.insertAt(j, undefined);
                }
                this.insertAt(index, elem);
            }
        };
        /**
         * @private
         */
        Collection.prototype.updateLength_ = function () {
            this.set(Property$2.LENGTH, this.array_.length);
        };
        /**
         * @private
         * @param {T} elem Element.
         * @param {number=} opt_except Optional index to ignore.
         */
        Collection.prototype.assertUnique_ = function (elem, opt_except) {
            for (var i = 0, ii = this.array_.length; i < ii; ++i) {
                if (this.array_[i] === elem && i !== opt_except) {
                    throw new AssertionError(58);
                }
            }
        };
        return Collection;
    }(BaseObject));

    /**
     * @module ol/render/EventType
     */
    /**
     * @enum {string}
     */
    var RenderEventType = {
        /**
         * Triggered before a layer is rendered.
         * @event module:ol/render/Event~RenderEvent#prerender
         * @api
         */
        PRERENDER: 'prerender',
        /**
         * Triggered after a layer is rendered.
         * @event module:ol/render/Event~RenderEvent#postrender
         * @api
         */
        POSTRENDER: 'postrender',
        /**
         * Triggered before layers are rendered.
         * The event object will not have a `context` set.
         * @event module:ol/render/Event~RenderEvent#precompose
         * @api
         */
        PRECOMPOSE: 'precompose',
        /**
         * Triggered after all layers are rendered.
         * The event object will not have a `context` set.
         * @event module:ol/render/Event~RenderEvent#postcompose
         * @api
         */
        POSTCOMPOSE: 'postcompose',
        /**
         * Triggered when rendering is complete, i.e. all sources and tiles have
         * finished loading for the current viewport, and all tiles are faded in.
         * The event object will not have a `context` set.
         * @event module:ol/render/Event~RenderEvent#rendercomplete
         * @api
         */
        RENDERCOMPLETE: 'rendercomplete',
    };

    /**
     * @module ol/layer/Property
     */
    /**
     * @enum {string}
     */
    var LayerProperty = {
        OPACITY: 'opacity',
        VISIBLE: 'visible',
        EXTENT: 'extent',
        Z_INDEX: 'zIndex',
        MAX_RESOLUTION: 'maxResolution',
        MIN_RESOLUTION: 'minResolution',
        MAX_ZOOM: 'maxZoom',
        MIN_ZOOM: 'minZoom',
        SOURCE: 'source',
    };

    var __extends$V = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
     * @property {number} [opacity=1] Opacity (0, 1).
     * @property {boolean} [visible=true] Visibility.
     * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
     * visible.
     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
     * be visible.
     * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in
     * the options is set as a {@link module:ol/Object} property on the layer object, so
     * is observable, and has get/set accessors.
     *
     * @api
     */
    var BaseLayer = /** @class */ (function (_super) {
        __extends$V(BaseLayer, _super);
        /**
         * @param {Options} options Layer options.
         */
        function BaseLayer(options) {
            var _this = _super.call(this) || this;
            /**
             * @type {Object<string, *>}
             */
            var properties = assign({}, options);
            properties[LayerProperty.OPACITY] =
                options.opacity !== undefined ? options.opacity : 1;
            assert(typeof properties[LayerProperty.OPACITY] === 'number', 64); // Layer opacity must be a number
            properties[LayerProperty.VISIBLE] =
                options.visible !== undefined ? options.visible : true;
            properties[LayerProperty.Z_INDEX] = options.zIndex;
            properties[LayerProperty.MAX_RESOLUTION] =
                options.maxResolution !== undefined ? options.maxResolution : Infinity;
            properties[LayerProperty.MIN_RESOLUTION] =
                options.minResolution !== undefined ? options.minResolution : 0;
            properties[LayerProperty.MIN_ZOOM] =
                options.minZoom !== undefined ? options.minZoom : -Infinity;
            properties[LayerProperty.MAX_ZOOM] =
                options.maxZoom !== undefined ? options.maxZoom : Infinity;
            /**
             * @type {string}
             * @private
             */
            _this.className_ =
                properties.className !== undefined ? options.className : 'ol-layer';
            delete properties.className;
            _this.setProperties(properties);
            /**
             * @type {import("./Layer.js").State}
             * @private
             */
            _this.state_ = null;
            return _this;
        }
        /**
         * @return {string} CSS class name.
         */
        BaseLayer.prototype.getClassName = function () {
            return this.className_;
        };
        /**
         * This method is not meant to be called by layers or layer renderers because the state
         * is incorrect if the layer is included in a layer group.
         *
         * @param {boolean=} opt_managed Layer is managed.
         * @return {import("./Layer.js").State} Layer state.
         */
        BaseLayer.prototype.getLayerState = function (opt_managed) {
            /** @type {import("./Layer.js").State} */
            var state = this.state_ ||
                /** @type {?} */ ({
                    layer: this,
                    managed: opt_managed === undefined ? true : opt_managed,
                });
            var zIndex = this.getZIndex();
            state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
            state.sourceState = this.getSourceState();
            state.visible = this.getVisible();
            state.extent = this.getExtent();
            state.zIndex =
                zIndex !== undefined ? zIndex : state.managed === false ? Infinity : 0;
            state.maxResolution = this.getMaxResolution();
            state.minResolution = Math.max(this.getMinResolution(), 0);
            state.minZoom = this.getMinZoom();
            state.maxZoom = this.getMaxZoom();
            this.state_ = state;
            return state;
        };
        /**
         * @abstract
         * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be
         *     modified in place).
         * @return {Array<import("./Layer.js").default>} Array of layers.
         */
        BaseLayer.prototype.getLayersArray = function (opt_array) {
            return abstract();
        };
        /**
         * @abstract
         * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer
         *     states (to be modified in place).
         * @return {Array<import("./Layer.js").State>} List of layer states.
         */
        BaseLayer.prototype.getLayerStatesArray = function (opt_states) {
            return abstract();
        };
        /**
         * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
         * will be visible regardless of extent.
         * @return {import("../extent.js").Extent|undefined} The layer extent.
         * @observable
         * @api
         */
        BaseLayer.prototype.getExtent = function () {
            return /** @type {import("../extent.js").Extent|undefined} */ (this.get(LayerProperty.EXTENT));
        };
        /**
         * Return the maximum resolution of the layer.
         * @return {number} The maximum resolution of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.getMaxResolution = function () {
            return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));
        };
        /**
         * Return the minimum resolution of the layer.
         * @return {number} The minimum resolution of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.getMinResolution = function () {
            return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));
        };
        /**
         * Return the minimum zoom level of the layer.
         * @return {number} The minimum zoom level of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.getMinZoom = function () {
            return /** @type {number} */ (this.get(LayerProperty.MIN_ZOOM));
        };
        /**
         * Return the maximum zoom level of the layer.
         * @return {number} The maximum zoom level of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.getMaxZoom = function () {
            return /** @type {number} */ (this.get(LayerProperty.MAX_ZOOM));
        };
        /**
         * Return the opacity of the layer (between 0 and 1).
         * @return {number} The opacity of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.getOpacity = function () {
            return /** @type {number} */ (this.get(LayerProperty.OPACITY));
        };
        /**
         * @abstract
         * @return {import("../source/State.js").default} Source state.
         */
        BaseLayer.prototype.getSourceState = function () {
            return abstract();
        };
        /**
         * Return the visibility of the layer (`true` or `false`).
         * @return {boolean} The visibility of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.getVisible = function () {
            return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));
        };
        /**
         * Return the Z-index of the layer, which is used to order layers before
         * rendering. The default Z-index is 0.
         * @return {number} The Z-index of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.getZIndex = function () {
            return /** @type {number} */ (this.get(LayerProperty.Z_INDEX));
        };
        /**
         * Set the extent at which the layer is visible.  If `undefined`, the layer
         * will be visible at all extents.
         * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.setExtent = function (extent) {
            this.set(LayerProperty.EXTENT, extent);
        };
        /**
         * Set the maximum resolution at which the layer is visible.
         * @param {number} maxResolution The maximum resolution of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.setMaxResolution = function (maxResolution) {
            this.set(LayerProperty.MAX_RESOLUTION, maxResolution);
        };
        /**
         * Set the minimum resolution at which the layer is visible.
         * @param {number} minResolution The minimum resolution of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.setMinResolution = function (minResolution) {
            this.set(LayerProperty.MIN_RESOLUTION, minResolution);
        };
        /**
         * Set the maximum zoom (exclusive) at which the layer is visible.
         * Note that the zoom levels for layer visibility are based on the
         * view zoom level, which may be different from a tile source zoom level.
         * @param {number} maxZoom The maximum zoom of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.setMaxZoom = function (maxZoom) {
            this.set(LayerProperty.MAX_ZOOM, maxZoom);
        };
        /**
         * Set the minimum zoom (inclusive) at which the layer is visible.
         * Note that the zoom levels for layer visibility are based on the
         * view zoom level, which may be different from a tile source zoom level.
         * @param {number} minZoom The minimum zoom of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.setMinZoom = function (minZoom) {
            this.set(LayerProperty.MIN_ZOOM, minZoom);
        };
        /**
         * Set the opacity of the layer, allowed values range from 0 to 1.
         * @param {number} opacity The opacity of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.setOpacity = function (opacity) {
            assert(typeof opacity === 'number', 64); // Layer opacity must be a number
            this.set(LayerProperty.OPACITY, opacity);
        };
        /**
         * Set the visibility of the layer (`true` or `false`).
         * @param {boolean} visible The visibility of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.setVisible = function (visible) {
            this.set(LayerProperty.VISIBLE, visible);
        };
        /**
         * Set Z-index of the layer, which is used to order layers before rendering.
         * The default Z-index is 0.
         * @param {number} zindex The z-index of the layer.
         * @observable
         * @api
         */
        BaseLayer.prototype.setZIndex = function (zindex) {
            this.set(LayerProperty.Z_INDEX, zindex);
        };
        /**
         * Clean up.
         */
        BaseLayer.prototype.disposeInternal = function () {
            if (this.state_) {
                this.state_.layer = null;
                this.state_ = null;
            }
            _super.prototype.disposeInternal.call(this);
        };
        return BaseLayer;
    }(BaseObject));

    /**
     * @module ol/source/State
     */
    /**
     * @enum {string}
     * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
     */
    var SourceState = {
        UNDEFINED: 'undefined',
        LOADING: 'loading',
        READY: 'ready',
        ERROR: 'error',
    };

    var __extends$U = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {function(import("../PluggableMap.js").FrameState):HTMLElement} RenderFunction
     */
    /**
     * @typedef {Object} Options
     * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
     * @property {number} [opacity=1] Opacity (0, 1).
     * @property {boolean} [visible=true] Visibility.
     * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
     * visible.
     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
     * be visible.
     * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     * @property {import("../source/Source.js").default} [source] Source for this layer.  If not provided to the constructor,
     * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after
     * construction.
     * @property {import("../PluggableMap.js").default} [map] Map.
     * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
     * HTML element. Will overwrite the default rendering for the layer.
     */
    /**
     * @typedef {Object} State
     * @property {import("./Layer.js").default} layer
     * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
     * @property {import("../source/State.js").default} sourceState
     * @property {boolean} visible
     * @property {boolean} managed
     * @property {import("../extent.js").Extent} [extent]
     * @property {number} zIndex
     * @property {number} maxResolution
     * @property {number} minResolution
     * @property {number} minZoom
     * @property {number} maxZoom
     */
    /**
     * @classdesc
     * Base class from which all layer types are derived. This should only be instantiated
     * in the case where a custom layer is be added to the map with a custom `render` function.
     * Such a function can be specified in the `options` object, and is expected to return an HTML element.
     *
     * A visual representation of raster or vector map data.
     * Layers group together those properties that pertain to how the data is to be
     * displayed, irrespective of the source of that data.
     *
     * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components
     * like {@link module:ol/interaction/Select~Select} use unmanaged layers
     * internally. These unmanaged layers are associated with the map using
     * {@link module:ol/layer/Layer~Layer#setMap} instead.
     *
     * A generic `change` event is fired when the state of the source changes.
     *
     * Please note that for performance reasons several layers might get rendered to
     * the same HTML element, which will cause {@link module:ol/Map~Map#forEachLayerAtPixel} to
     * give false positives. To avoid this, apply different `className` properties to the
     * layers at creation time.
     *
     * @fires import("../render/Event.js").RenderEvent#prerender
     * @fires import("../render/Event.js").RenderEvent#postrender
     *
     * @template {import("../source/Source.js").default} SourceType
     * @api
     */
    var Layer = /** @class */ (function (_super) {
        __extends$U(Layer, _super);
        /**
         * @param {Options} options Layer options.
         */
        function Layer(options) {
            var _this = this;
            var baseOptions = assign({}, options);
            delete baseOptions.source;
            _this = _super.call(this, baseOptions) || this;
            /**
             * @private
             * @type {?import("../events.js").EventsKey}
             */
            _this.mapPrecomposeKey_ = null;
            /**
             * @private
             * @type {?import("../events.js").EventsKey}
             */
            _this.mapRenderKey_ = null;
            /**
             * @private
             * @type {?import("../events.js").EventsKey}
             */
            _this.sourceChangeKey_ = null;
            /**
             * @private
             * @type {import("../renderer/Layer.js").default}
             */
            _this.renderer_ = null;
            // Overwrite default render method with a custom one
            if (options.render) {
                _this.render = options.render;
            }
            if (options.map) {
                _this.setMap(options.map);
            }
            _this.addEventListener(getChangeEventType(LayerProperty.SOURCE), _this.handleSourcePropertyChange_);
            var source = options.source
                ? /** @type {SourceType} */ (options.source)
                : null;
            _this.setSource(source);
            return _this;
        }
        /**
         * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be modified in place).
         * @return {Array<import("./Layer.js").default>} Array of layers.
         */
        Layer.prototype.getLayersArray = function (opt_array) {
            var array = opt_array ? opt_array : [];
            array.push(this);
            return array;
        };
        /**
         * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer states (to be modified in place).
         * @return {Array<import("./Layer.js").State>} List of layer states.
         */
        Layer.prototype.getLayerStatesArray = function (opt_states) {
            var states = opt_states ? opt_states : [];
            states.push(this.getLayerState());
            return states;
        };
        /**
         * Get the layer source.
         * @return {SourceType} The layer source (or `null` if not yet set).
         * @observable
         * @api
         */
        Layer.prototype.getSource = function () {
            return /** @type {SourceType} */ (this.get(LayerProperty.SOURCE)) || null;
        };
        /**
         * @return {import("../source/State.js").default} Source state.
         */
        Layer.prototype.getSourceState = function () {
            var source = this.getSource();
            return !source ? SourceState.UNDEFINED : source.getState();
        };
        /**
         * @private
         */
        Layer.prototype.handleSourceChange_ = function () {
            this.changed();
        };
        /**
         * @private
         */
        Layer.prototype.handleSourcePropertyChange_ = function () {
            if (this.sourceChangeKey_) {
                unlistenByKey(this.sourceChangeKey_);
                this.sourceChangeKey_ = null;
            }
            var source = this.getSource();
            if (source) {
                this.sourceChangeKey_ = listen(source, EventType.CHANGE, this.handleSourceChange_, this);
            }
            this.changed();
        };
        /**
         * @param {import("../pixel").Pixel} pixel Pixel.
         * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
         * an array of features.
         */
        Layer.prototype.getFeatures = function (pixel) {
            return this.renderer_.getFeatures(pixel);
        };
        /**
         * In charge to manage the rendering of the layer. One layer type is
         * bounded with one layer renderer.
         * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
         * @param {HTMLElement} target Target which the renderer may (but need not) use
         * for rendering its content.
         * @return {HTMLElement} The rendered element.
         */
        Layer.prototype.render = function (frameState, target) {
            var layerRenderer = this.getRenderer();
            if (layerRenderer.prepareFrame(frameState)) {
                return layerRenderer.renderFrame(frameState, target);
            }
        };
        /**
         * Sets the layer to be rendered on top of other layers on a map. The map will
         * not manage this layer in its layers collection, and the callback in
         * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This
         * is useful for temporary layers. To remove an unmanaged layer from the map,
         * use `#setMap(null)`.
         *
         * To add the layer to a map and have it managed by the map, use
         * {@link module:ol/Map#addLayer} instead.
         * @param {import("../PluggableMap.js").default} map Map.
         * @api
         */
        Layer.prototype.setMap = function (map) {
            if (this.mapPrecomposeKey_) {
                unlistenByKey(this.mapPrecomposeKey_);
                this.mapPrecomposeKey_ = null;
            }
            if (!map) {
                this.changed();
            }
            if (this.mapRenderKey_) {
                unlistenByKey(this.mapRenderKey_);
                this.mapRenderKey_ = null;
            }
            if (map) {
                this.mapPrecomposeKey_ = listen(map, RenderEventType.PRECOMPOSE, function (evt) {
                    var renderEvent = /** @type {import("../render/Event.js").default} */ (evt);
                    var layerStatesArray = renderEvent.frameState.layerStatesArray;
                    var layerState = this.getLayerState(false);
                    // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.
                    assert(!layerStatesArray.some(function (arrayLayerState) {
                        return arrayLayerState.layer === layerState.layer;
                    }), 67);
                    layerStatesArray.push(layerState);
                }, this);
                this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);
                this.changed();
            }
        };
        /**
         * Set the layer source.
         * @param {SourceType} source The layer source.
         * @observable
         * @api
         */
        Layer.prototype.setSource = function (source) {
            this.set(LayerProperty.SOURCE, source);
        };
        /**
         * Get the renderer for this layer.
         * @return {import("../renderer/Layer.js").default} The layer renderer.
         */
        Layer.prototype.getRenderer = function () {
            if (!this.renderer_) {
                this.renderer_ = this.createRenderer();
            }
            return this.renderer_;
        };
        /**
         * @return {boolean} The layer has a renderer.
         */
        Layer.prototype.hasRenderer = function () {
            return !!this.renderer_;
        };
        /**
         * Create a renderer for this layer.
         * @return {import("../renderer/Layer.js").default} A layer renderer.
         * @protected
         */
        Layer.prototype.createRenderer = function () {
            return null;
        };
        /**
         * Clean up.
         */
        Layer.prototype.disposeInternal = function () {
            this.setSource(null);
            _super.prototype.disposeInternal.call(this);
        };
        return Layer;
    }(BaseLayer));
    /**
     * Return `true` if the layer is visible and if the provided view state
     * has resolution and zoom levels that are in range of the layer's min/max.
     * @param {State} layerState Layer state.
     * @param {import("../View.js").State} viewState View state.
     * @return {boolean} The layer is visible at the given view state.
     */
    function inView(layerState, viewState) {
        if (!layerState.visible) {
            return false;
        }
        var resolution = viewState.resolution;
        if (resolution < layerState.minResolution ||
            resolution >= layerState.maxResolution) {
            return false;
        }
        var zoom = viewState.zoom;
        return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var rbush_min = createCommonjsModule(function (module, exports) {
    !function(t,i){module.exports=i();}(commonjsGlobal,function(){function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h);}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--;}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1);}}(t,r,e||0,a||t.length-1,h||n);}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r;}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear();};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return -1}function a(t,i){h(t,0,t.children.length,i,t);}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h);}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return (t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return {children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r);}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h));}i=e.pop();}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return !1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return !0;n.push(e);}}i=n.pop();}return !1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else {if(this.data.height<n.height){var r=this.data;this.data=n,n=r;}this._insert(n,this.data.height-n.height-1,!0);}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0]);}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1));}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s);}i=h||i.children[0];}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i);},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o);},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox);},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p);}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r);},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a);}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s);}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t);},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox);},r});
    });

    var __extends$T = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
     * @property {number} [opacity=1] Opacity (0, 1).
     * @property {boolean} [visible=true] Visibility.
     * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
     * visible.
     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
     * be visible.
     * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
     * features before rendering. By default features are drawn in the order that they are created. Use
     * `null` to avoid the sort, but get an undefined draw order.
     * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
     * renderer when getting features from the vector source for the rendering or hit-detection.
     * Recommended value: the size of the largest symbol, line width or label.
     * @property {import("../source/Vector.js").default} [source] Source.
     * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
     * this layer in its layers collection, and the layer will be rendered on top. This is useful for
     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
     * use {@link module:ol/Map#addLayer}.
     * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
     * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
     * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
     * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
     * higher priority.
     * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
     * features that have their own style will be rendered. See {@link module:ol/style} for default style
     * which will be used if this is not set.
     * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
     * be recreated during animations. This means that no vectors will be shown clipped, but the
     * setting will have a performance impact for large amounts of vector data. When set to `false`,
     * batches will be recreated when no animation is active.
     * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
     * be recreated during interactions. See also `updateWhileAnimating`.
     */
    /**
     * @enum {string}
     * @private
     */
    var Property$1 = {
        RENDER_ORDER: 'renderOrder',
    };
    /**
     * @classdesc
     * Vector data that is rendered client-side.
     * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
     * property on the layer object; for example, setting `title: 'My Title'` in the
     * options means that `title` is observable, and has get/set accessors.
     *
     * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
     * @extends {Layer<VectorSourceType>}
     * @api
     */
    var BaseVectorLayer = /** @class */ (function (_super) {
        __extends$T(BaseVectorLayer, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function BaseVectorLayer(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var baseOptions = assign({}, options);
            delete baseOptions.style;
            delete baseOptions.renderBuffer;
            delete baseOptions.updateWhileAnimating;
            delete baseOptions.updateWhileInteracting;
            _this = _super.call(this, baseOptions) || this;
            /**
             * @private
             * @type {boolean}
             */
            _this.declutter_ =
                options.declutter !== undefined ? options.declutter : false;
            /**
             * @type {number}
             * @private
             */
            _this.renderBuffer_ =
                options.renderBuffer !== undefined ? options.renderBuffer : 100;
            /**
             * User provided style.
             * @type {import("../style/Style.js").StyleLike}
             * @private
             */
            _this.style_ = null;
            /**
             * Style function for use within the library.
             * @type {import("../style/Style.js").StyleFunction|undefined}
             * @private
             */
            _this.styleFunction_ = undefined;
            _this.setStyle(options.style);
            /**
             * @type {boolean}
             * @private
             */
            _this.updateWhileAnimating_ =
                options.updateWhileAnimating !== undefined
                    ? options.updateWhileAnimating
                    : false;
            /**
             * @type {boolean}
             * @private
             */
            _this.updateWhileInteracting_ =
                options.updateWhileInteracting !== undefined
                    ? options.updateWhileInteracting
                    : false;
            return _this;
        }
        /**
         * @return {boolean} Declutter.
         */
        BaseVectorLayer.prototype.getDeclutter = function () {
            return this.declutter_;
        };
        /**
         * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
         * that resolves with an array of features. The array will either contain the topmost feature
         * when a hit was detected, or it will be empty.
         *
         * The hit detection algorithm used for this method is optimized for performance, but is less
         * accurate than the one used in {@link import("../PluggableMap.js").default#getFeaturesAtPixel}: Text
         * is not considered, and icons are only represented by their bounding box instead of the exact
         * image.
         *
         * @param {import("../pixel.js").Pixel} pixel Pixel.
         * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
         * @api
         */
        BaseVectorLayer.prototype.getFeatures = function (pixel) {
            return _super.prototype.getFeatures.call(this, pixel);
        };
        /**
         * @return {number|undefined} Render buffer.
         */
        BaseVectorLayer.prototype.getRenderBuffer = function () {
            return this.renderBuffer_;
        };
        /**
         * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
         *     order.
         */
        BaseVectorLayer.prototype.getRenderOrder = function () {
            return /** @type {import("../render.js").OrderFunction|null|undefined} */ (this.get(Property$1.RENDER_ORDER));
        };
        /**
         * Get the style for features.  This returns whatever was passed to the `style`
         * option at construction or to the `setStyle` method.
         * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
         * @api
         */
        BaseVectorLayer.prototype.getStyle = function () {
            return this.style_;
        };
        /**
         * Get the style function.
         * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
         * @api
         */
        BaseVectorLayer.prototype.getStyleFunction = function () {
            return this.styleFunction_;
        };
        /**
         * @return {boolean} Whether the rendered layer should be updated while
         *     animating.
         */
        BaseVectorLayer.prototype.getUpdateWhileAnimating = function () {
            return this.updateWhileAnimating_;
        };
        /**
         * @return {boolean} Whether the rendered layer should be updated while
         *     interacting.
         */
        BaseVectorLayer.prototype.getUpdateWhileInteracting = function () {
            return this.updateWhileInteracting_;
        };
        /**
         * Render declutter items for this layer
         * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
         */
        BaseVectorLayer.prototype.renderDeclutter = function (frameState) {
            if (!frameState.declutterTree) {
                frameState.declutterTree = new rbush_min(9);
            }
            /** @type {*} */ (this.getRenderer()).renderDeclutter(frameState);
        };
        /**
         * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
         *     Render order.
         */
        BaseVectorLayer.prototype.setRenderOrder = function (renderOrder) {
            this.set(Property$1.RENDER_ORDER, renderOrder);
        };
        /**
         * Set the style for features.  This can be a single style object, an array
         * of styles, or a function that takes a feature and resolution and returns
         * an array of styles. If set to `null`, the layer has no style (a `null` style),
         * so only features that have their own styles will be rendered in the layer. Call
         * `setStyle()` without arguments to reset to the default style. See
         * {@link module:ol/style} for information on the default style.
         * @param {(import("../style/Style.js").StyleLike|null)=} opt_style Layer style.
         * @api
         */
        BaseVectorLayer.prototype.setStyle = function (opt_style) {
            this.style_ = opt_style !== undefined ? opt_style : createDefaultStyle;
            this.styleFunction_ =
                opt_style === null ? undefined : toFunction(this.style_);
            this.changed();
        };
        return BaseVectorLayer;
    }(Layer));

    /**
     * @module ol/render/canvas/Instruction
     */
    /**
     * @enum {number}
     */
    var Instruction = {
        BEGIN_GEOMETRY: 0,
        BEGIN_PATH: 1,
        CIRCLE: 2,
        CLOSE_PATH: 3,
        CUSTOM: 4,
        DRAW_CHARS: 5,
        DRAW_IMAGE: 6,
        END_GEOMETRY: 7,
        FILL: 8,
        MOVE_TO_LINE_TO: 9,
        SET_FILL_STYLE: 10,
        SET_STROKE_STYLE: 11,
        STROKE: 12,
    };
    /**
     * @type {Array<Instruction>}
     */
    var fillInstruction = [Instruction.FILL];
    /**
     * @type {Array<Instruction>}
     */
    var strokeInstruction = [Instruction.STROKE];
    /**
     * @type {Array<Instruction>}
     */
    var beginPathInstruction = [Instruction.BEGIN_PATH];
    /**
     * @type {Array<Instruction>}
     */
    var closePathInstruction = [Instruction.CLOSE_PATH];

    /**
     * @module ol/render/VectorContext
     */
    /**
     * @classdesc
     * Context for drawing geometries.  A vector context is available on render
     * events and does not need to be constructed directly.
     * @api
     */
    var VectorContext = /** @class */ (function () {
        function VectorContext() {
        }
        /**
         * Render a geometry with a custom renderer.
         *
         * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {Function} renderer Renderer.
         */
        VectorContext.prototype.drawCustom = function (geometry, feature, renderer) { };
        /**
         * Render a geometry.
         *
         * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
         */
        VectorContext.prototype.drawGeometry = function (geometry) { };
        /**
         * Set the rendering style.
         *
         * @param {import("../style/Style.js").default} style The rendering style.
         */
        VectorContext.prototype.setStyle = function (style) { };
        /**
         * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
         * @param {import("../Feature.js").default} feature Feature.
         */
        VectorContext.prototype.drawCircle = function (circleGeometry, feature) { };
        /**
         * @param {import("../Feature.js").default} feature Feature.
         * @param {import("../style/Style.js").default} style Style.
         */
        VectorContext.prototype.drawFeature = function (feature, style) { };
        /**
         * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
         * @param {import("../Feature.js").default} feature Feature.
         */
        VectorContext.prototype.drawGeometryCollection = function (geometryCollectionGeometry, feature) { };
        /**
         * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         */
        VectorContext.prototype.drawLineString = function (lineStringGeometry, feature) { };
        /**
         * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         */
        VectorContext.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) { };
        /**
         * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         */
        VectorContext.prototype.drawMultiPoint = function (multiPointGeometry, feature) { };
        /**
         * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         */
        VectorContext.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) { };
        /**
         * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         */
        VectorContext.prototype.drawPoint = function (pointGeometry, feature) { };
        /**
         * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         */
        VectorContext.prototype.drawPolygon = function (polygonGeometry, feature) { };
        /**
         * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         */
        VectorContext.prototype.drawText = function (geometry, feature) { };
        /**
         * @param {import("../style/Fill.js").default} fillStyle Fill style.
         * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
         */
        VectorContext.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) { };
        /**
         * @param {import("../style/Image.js").default} imageStyle Image style.
         * @param {import("../render/canvas.js").DeclutterImageWithText=} opt_declutterImageWithText Shared data for combined decluttering with a text style.
         */
        VectorContext.prototype.setImageStyle = function (imageStyle, opt_declutterImageWithText) { };
        /**
         * @param {import("../style/Text.js").default} textStyle Text style.
         * @param {import("../render/canvas.js").DeclutterImageWithText=} opt_declutterImageWithText Shared data for combined decluttering with an image style.
         */
        VectorContext.prototype.setTextStyle = function (textStyle, opt_declutterImageWithText) { };
        return VectorContext;
    }());

    var __extends$S = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var CanvasBuilder = /** @class */ (function (_super) {
        __extends$S(CanvasBuilder, _super);
        /**
         * @param {number} tolerance Tolerance.
         * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
         * @param {number} resolution Resolution.
         * @param {number} pixelRatio Pixel ratio.
         */
        function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {
            var _this = _super.call(this) || this;
            /**
             * @protected
             * @type {number}
             */
            _this.tolerance = tolerance;
            /**
             * @protected
             * @const
             * @type {import("../../extent.js").Extent}
             */
            _this.maxExtent = maxExtent;
            /**
             * @protected
             * @type {number}
             */
            _this.pixelRatio = pixelRatio;
            /**
             * @protected
             * @type {number}
             */
            _this.maxLineWidth = 0;
            /**
             * @protected
             * @const
             * @type {number}
             */
            _this.resolution = resolution;
            /**
             * @private
             * @type {Array<*>}
             */
            _this.beginGeometryInstruction1_ = null;
            /**
             * @private
             * @type {Array<*>}
             */
            _this.beginGeometryInstruction2_ = null;
            /**
             * @private
             * @type {import("../../extent.js").Extent}
             */
            _this.bufferedMaxExtent_ = null;
            /**
             * @protected
             * @type {Array<*>}
             */
            _this.instructions = [];
            /**
             * @protected
             * @type {Array<number>}
             */
            _this.coordinates = [];
            /**
             * @private
             * @type {import("../../coordinate.js").Coordinate}
             */
            _this.tmpCoordinate_ = [];
            /**
             * @protected
             * @type {Array<*>}
             */
            _this.hitDetectionInstructions = [];
            /**
             * @protected
             * @type {import("../canvas.js").FillStrokeState}
             */
            _this.state = /** @type {import("../canvas.js").FillStrokeState} */ ({});
            return _this;
        }
        /**
         * @protected
         * @param {Array<number>} dashArray Dash array.
         * @return {Array<number>} Dash array with pixel ratio applied
         */
        CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {
            var pixelRatio = this.pixelRatio;
            return pixelRatio == 1
                ? dashArray
                : dashArray.map(function (dash) {
                    return dash * pixelRatio;
                });
        };
        /**
         * @param {Array<number>} flatCoordinates Flat coordinates.
         * @param {number} stride Stride.
         * @protected
         * @return {number} My end
         */
        CanvasBuilder.prototype.appendFlatPointCoordinates = function (flatCoordinates, stride) {
            var extent = this.getBufferedMaxExtent();
            var tmpCoord = this.tmpCoordinate_;
            var coordinates = this.coordinates;
            var myEnd = coordinates.length;
            for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
                tmpCoord[0] = flatCoordinates[i];
                tmpCoord[1] = flatCoordinates[i + 1];
                if (containsCoordinate(extent, tmpCoord)) {
                    coordinates[myEnd++] = tmpCoord[0];
                    coordinates[myEnd++] = tmpCoord[1];
                }
            }
            return myEnd;
        };
        /**
         * @param {Array<number>} flatCoordinates Flat coordinates.
         * @param {number} offset Offset.
         * @param {number} end End.
         * @param {number} stride Stride.
         * @param {boolean} closed Last input coordinate equals first.
         * @param {boolean} skipFirst Skip first coordinate.
         * @protected
         * @return {number} My end.
         */
        CanvasBuilder.prototype.appendFlatLineCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {
            var coordinates = this.coordinates;
            var myEnd = coordinates.length;
            var extent = this.getBufferedMaxExtent();
            if (skipFirst) {
                offset += stride;
            }
            var lastXCoord = flatCoordinates[offset];
            var lastYCoord = flatCoordinates[offset + 1];
            var nextCoord = this.tmpCoordinate_;
            var skipped = true;
            var i, lastRel, nextRel;
            for (i = offset + stride; i < end; i += stride) {
                nextCoord[0] = flatCoordinates[i];
                nextCoord[1] = flatCoordinates[i + 1];
                nextRel = coordinateRelationship(extent, nextCoord);
                if (nextRel !== lastRel) {
                    if (skipped) {
                        coordinates[myEnd++] = lastXCoord;
                        coordinates[myEnd++] = lastYCoord;
                        skipped = false;
                    }
                    coordinates[myEnd++] = nextCoord[0];
                    coordinates[myEnd++] = nextCoord[1];
                }
                else if (nextRel === Relationship.INTERSECTING) {
                    coordinates[myEnd++] = nextCoord[0];
                    coordinates[myEnd++] = nextCoord[1];
                    skipped = false;
                }
                else {
                    skipped = true;
                }
                lastXCoord = nextCoord[0];
                lastYCoord = nextCoord[1];
                lastRel = nextRel;
            }
            // Last coordinate equals first or only one point to append:
            if ((closed && skipped) || i === offset + stride) {
                coordinates[myEnd++] = lastXCoord;
                coordinates[myEnd++] = lastYCoord;
            }
            return myEnd;
        };
        /**
         * @param {Array<number>} flatCoordinates Flat coordinates.
         * @param {number} offset Offset.
         * @param {Array<number>} ends Ends.
         * @param {number} stride Stride.
         * @param {Array<number>} builderEnds Builder ends.
         * @return {number} Offset.
         */
        CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {
            for (var i = 0, ii = ends.length; i < ii; ++i) {
                var end = ends[i];
                var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
                builderEnds.push(builderEnd);
                offset = end;
            }
            return offset;
        };
        /**
         * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         * @param {Function} renderer Renderer.
         */
        CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer) {
            this.beginGeometry(geometry, feature);
            var type = geometry.getType();
            var stride = geometry.getStride();
            var builderBegin = this.coordinates.length;
            var flatCoordinates, builderEnd, builderEnds, builderEndss;
            var offset;
            if (type == GeometryType.MULTI_POLYGON) {
                flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getOrientedFlatCoordinates();
                builderEndss = [];
                var endss = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getEndss();
                offset = 0;
                for (var i = 0, ii = endss.length; i < ii; ++i) {
                    var myEnds = [];
                    offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
                    builderEndss.push(myEnds);
                }
                this.instructions.push([
                    Instruction.CUSTOM,
                    builderBegin,
                    builderEndss,
                    geometry,
                    renderer,
                    inflateMultiCoordinatesArray,
                ]);
            }
            else if (type == GeometryType.POLYGON ||
                type == GeometryType.MULTI_LINE_STRING) {
                builderEnds = [];
                flatCoordinates =
                    type == GeometryType.POLYGON
                        ? /** @type {import("../../geom/Polygon.js").default} */ (geometry).getOrientedFlatCoordinates()
                        : geometry.getFlatCoordinates();
                offset = this.drawCustomCoordinates_(flatCoordinates, 0, 
                /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */ (geometry).getEnds(), stride, builderEnds);
                this.instructions.push([
                    Instruction.CUSTOM,
                    builderBegin,
                    builderEnds,
                    geometry,
                    renderer,
                    inflateCoordinatesArray,
                ]);
            }
            else if (type == GeometryType.LINE_STRING ||
                type == GeometryType.CIRCLE) {
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
                this.instructions.push([
                    Instruction.CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer,
                    inflateCoordinates,
                ]);
            }
            else if (type == GeometryType.MULTI_POINT) {
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
                if (builderEnd > builderBegin) {
                    this.instructions.push([
                        Instruction.CUSTOM,
                        builderBegin,
                        builderEnd,
                        geometry,
                        renderer,
                        inflateCoordinates,
                    ]);
                }
            }
            else if (type == GeometryType.POINT) {
                flatCoordinates = geometry.getFlatCoordinates();
                this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
                builderEnd = this.coordinates.length;
                this.instructions.push([
                    Instruction.CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer,
                ]);
            }
            this.endGeometry(feature);
        };
        /**
         * @protected
         * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         */
        CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {
            this.beginGeometryInstruction1_ = [
                Instruction.BEGIN_GEOMETRY,
                feature,
                0,
                geometry,
            ];
            this.instructions.push(this.beginGeometryInstruction1_);
            this.beginGeometryInstruction2_ = [
                Instruction.BEGIN_GEOMETRY,
                feature,
                0,
                geometry,
            ];
            this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
        };
        /**
         * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
         */
        CanvasBuilder.prototype.finish = function () {
            return {
                instructions: this.instructions,
                hitDetectionInstructions: this.hitDetectionInstructions,
                coordinates: this.coordinates,
            };
        };
        /**
         * Reverse the hit detection instructions.
         */
        CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {
            var hitDetectionInstructions = this.hitDetectionInstructions;
            // step 1 - reverse array
            hitDetectionInstructions.reverse();
            // step 2 - reverse instructions within geometry blocks
            var i;
            var n = hitDetectionInstructions.length;
            var instruction;
            var type;
            var begin = -1;
            for (i = 0; i < n; ++i) {
                instruction = hitDetectionInstructions[i];
                type = /** @type {import("./Instruction.js").default} */ (instruction[0]);
                if (type == Instruction.END_GEOMETRY) {
                    begin = i;
                }
                else if (type == Instruction.BEGIN_GEOMETRY) {
                    instruction[2] = i;
                    reverseSubArray(this.hitDetectionInstructions, begin, i);
                    begin = -1;
                }
            }
        };
        /**
         * @param {import("../../style/Fill.js").default} fillStyle Fill style.
         * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
         */
        CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
            var state = this.state;
            if (fillStyle) {
                var fillStyleColor = fillStyle.getColor();
                state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);
            }
            else {
                state.fillStyle = undefined;
            }
            if (strokeStyle) {
                var strokeStyleColor = strokeStyle.getColor();
                state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);
                var strokeStyleLineCap = strokeStyle.getLineCap();
                state.lineCap =
                    strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;
                var strokeStyleLineDash = strokeStyle.getLineDash();
                state.lineDash = strokeStyleLineDash
                    ? strokeStyleLineDash.slice()
                    : defaultLineDash;
                var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
                state.lineDashOffset = strokeStyleLineDashOffset
                    ? strokeStyleLineDashOffset
                    : defaultLineDashOffset;
                var strokeStyleLineJoin = strokeStyle.getLineJoin();
                state.lineJoin =
                    strokeStyleLineJoin !== undefined
                        ? strokeStyleLineJoin
                        : defaultLineJoin;
                var strokeStyleWidth = strokeStyle.getWidth();
                state.lineWidth =
                    strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;
                var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
                state.miterLimit =
                    strokeStyleMiterLimit !== undefined
                        ? strokeStyleMiterLimit
                        : defaultMiterLimit;
                if (state.lineWidth > this.maxLineWidth) {
                    this.maxLineWidth = state.lineWidth;
                    // invalidate the buffered max extent cache
                    this.bufferedMaxExtent_ = null;
                }
            }
            else {
                state.strokeStyle = undefined;
                state.lineCap = undefined;
                state.lineDash = null;
                state.lineDashOffset = undefined;
                state.lineJoin = undefined;
                state.lineWidth = undefined;
                state.miterLimit = undefined;
            }
        };
        /**
         * @param {import("../canvas.js").FillStrokeState} state State.
         * @return {Array<*>} Fill instruction.
         */
        CanvasBuilder.prototype.createFill = function (state) {
            var fillStyle = state.fillStyle;
            /** @type {Array<*>} */
            var fillInstruction = [Instruction.SET_FILL_STYLE, fillStyle];
            if (typeof fillStyle !== 'string') {
                // Fill is a pattern or gradient - align it!
                fillInstruction.push(true);
            }
            return fillInstruction;
        };
        /**
         * @param {import("../canvas.js").FillStrokeState} state State.
         */
        CanvasBuilder.prototype.applyStroke = function (state) {
            this.instructions.push(this.createStroke(state));
        };
        /**
         * @param {import("../canvas.js").FillStrokeState} state State.
         * @return {Array<*>} Stroke instruction.
         */
        CanvasBuilder.prototype.createStroke = function (state) {
            return [
                Instruction.SET_STROKE_STYLE,
                state.strokeStyle,
                state.lineWidth * this.pixelRatio,
                state.lineCap,
                state.lineJoin,
                state.miterLimit,
                this.applyPixelRatio(state.lineDash),
                state.lineDashOffset * this.pixelRatio,
            ];
        };
        /**
         * @param {import("../canvas.js").FillStrokeState} state State.
         * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
         */
        CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {
            var fillStyle = state.fillStyle;
            if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
                if (fillStyle !== undefined) {
                    this.instructions.push(createFill.call(this, state));
                }
                state.currentFillStyle = fillStyle;
            }
        };
        /**
         * @param {import("../canvas.js").FillStrokeState} state State.
         * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
         */
        CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {
            var strokeStyle = state.strokeStyle;
            var lineCap = state.lineCap;
            var lineDash = state.lineDash;
            var lineDashOffset = state.lineDashOffset;
            var lineJoin = state.lineJoin;
            var lineWidth = state.lineWidth;
            var miterLimit = state.miterLimit;
            if (state.currentStrokeStyle != strokeStyle ||
                state.currentLineCap != lineCap ||
                (lineDash != state.currentLineDash &&
                    !equals$2(state.currentLineDash, lineDash)) ||
                state.currentLineDashOffset != lineDashOffset ||
                state.currentLineJoin != lineJoin ||
                state.currentLineWidth != lineWidth ||
                state.currentMiterLimit != miterLimit) {
                if (strokeStyle !== undefined) {
                    applyStroke.call(this, state);
                }
                state.currentStrokeStyle = strokeStyle;
                state.currentLineCap = lineCap;
                state.currentLineDash = lineDash;
                state.currentLineDashOffset = lineDashOffset;
                state.currentLineJoin = lineJoin;
                state.currentLineWidth = lineWidth;
                state.currentMiterLimit = miterLimit;
            }
        };
        /**
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         */
        CanvasBuilder.prototype.endGeometry = function (feature) {
            this.beginGeometryInstruction1_[2] = this.instructions.length;
            this.beginGeometryInstruction1_ = null;
            this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
            this.beginGeometryInstruction2_ = null;
            var endGeometryInstruction = [Instruction.END_GEOMETRY, feature];
            this.instructions.push(endGeometryInstruction);
            this.hitDetectionInstructions.push(endGeometryInstruction);
        };
        /**
         * Get the buffered rendering extent.  Rendering will be clipped to the extent
         * provided to the constructor.  To account for symbolizers that may intersect
         * this extent, we calculate a buffered extent (e.g. based on stroke width).
         * @return {import("../../extent.js").Extent} The buffered rendering extent.
         * @protected
         */
        CanvasBuilder.prototype.getBufferedMaxExtent = function () {
            if (!this.bufferedMaxExtent_) {
                this.bufferedMaxExtent_ = clone(this.maxExtent);
                if (this.maxLineWidth > 0) {
                    var width = (this.resolution * (this.maxLineWidth + 1)) / 2;
                    buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
                }
            }
            return this.bufferedMaxExtent_;
        };
        return CanvasBuilder;
    }(VectorContext));

    var __extends$R = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var CanvasImageBuilder = /** @class */ (function (_super) {
        __extends$R(CanvasImageBuilder, _super);
        /**
         * @param {number} tolerance Tolerance.
         * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
         * @param {number} resolution Resolution.
         * @param {number} pixelRatio Pixel ratio.
         */
        function CanvasImageBuilder(tolerance, maxExtent, resolution, pixelRatio) {
            var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
            /**
             * @private
             * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
             */
            _this.hitDetectionImage_ = null;
            /**
             * @private
             * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
             */
            _this.image_ = null;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.imagePixelRatio_ = undefined;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.anchorX_ = undefined;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.anchorY_ = undefined;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.height_ = undefined;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.opacity_ = undefined;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.originX_ = undefined;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.originY_ = undefined;
            /**
             * @private
             * @type {boolean|undefined}
             */
            _this.rotateWithView_ = undefined;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.rotation_ = undefined;
            /**
             * @private
             * @type {import("../../size.js").Size|undefined}
             */
            _this.scale_ = undefined;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.width_ = undefined;
            /**
             * Data shared with a text builder for combined decluttering.
             * @private
             * @type {import("../canvas.js").DeclutterImageWithText}
             */
            _this.declutterImageWithText_ = undefined;
            return _this;
        }
        /**
         * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         */
        CanvasImageBuilder.prototype.drawPoint = function (pointGeometry, feature) {
            if (!this.image_) {
                return;
            }
            this.beginGeometry(pointGeometry, feature);
            var flatCoordinates = pointGeometry.getFlatCoordinates();
            var stride = pointGeometry.getStride();
            var myBegin = this.coordinates.length;
            var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
            this.instructions.push([
                Instruction.DRAW_IMAGE,
                myBegin,
                myEnd,
                this.image_,
                // Remaining arguments to DRAW_IMAGE are in alphabetical order
                this.anchorX_ * this.imagePixelRatio_,
                this.anchorY_ * this.imagePixelRatio_,
                Math.ceil(this.height_ * this.imagePixelRatio_),
                this.opacity_,
                this.originX_,
                this.originY_,
                this.rotateWithView_,
                this.rotation_,
                [
                    (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
                    (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
                ],
                Math.ceil(this.width_ * this.imagePixelRatio_),
                this.declutterImageWithText_,
            ]);
            this.hitDetectionInstructions.push([
                Instruction.DRAW_IMAGE,
                myBegin,
                myEnd,
                this.hitDetectionImage_,
                // Remaining arguments to DRAW_IMAGE are in alphabetical order
                this.anchorX_,
                this.anchorY_,
                this.height_,
                this.opacity_,
                this.originX_,
                this.originY_,
                this.rotateWithView_,
                this.rotation_,
                this.scale_,
                this.width_,
                this.declutterImageWithText_,
            ]);
            this.endGeometry(feature);
        };
        /**
         * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         */
        CanvasImageBuilder.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
            if (!this.image_) {
                return;
            }
            this.beginGeometry(multiPointGeometry, feature);
            var flatCoordinates = multiPointGeometry.getFlatCoordinates();
            var stride = multiPointGeometry.getStride();
            var myBegin = this.coordinates.length;
            var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
            this.instructions.push([
                Instruction.DRAW_IMAGE,
                myBegin,
                myEnd,
                this.image_,
                // Remaining arguments to DRAW_IMAGE are in alphabetical order
                this.anchorX_ * this.imagePixelRatio_,
                this.anchorY_ * this.imagePixelRatio_,
                Math.ceil(this.height_ * this.imagePixelRatio_),
                this.opacity_,
                this.originX_,
                this.originY_,
                this.rotateWithView_,
                this.rotation_,
                [
                    (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
                    (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
                ],
                Math.ceil(this.width_ * this.imagePixelRatio_),
                this.declutterImageWithText_,
            ]);
            this.hitDetectionInstructions.push([
                Instruction.DRAW_IMAGE,
                myBegin,
                myEnd,
                this.hitDetectionImage_,
                // Remaining arguments to DRAW_IMAGE are in alphabetical order
                this.anchorX_,
                this.anchorY_,
                this.height_,
                this.opacity_,
                this.originX_,
                this.originY_,
                this.rotateWithView_,
                this.rotation_,
                this.scale_,
                this.width_,
                this.declutterImageWithText_,
            ]);
            this.endGeometry(feature);
        };
        /**
         * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
         */
        CanvasImageBuilder.prototype.finish = function () {
            this.reverseHitDetectionInstructions();
            // FIXME this doesn't really protect us against further calls to draw*Geometry
            this.anchorX_ = undefined;
            this.anchorY_ = undefined;
            this.hitDetectionImage_ = null;
            this.image_ = null;
            this.imagePixelRatio_ = undefined;
            this.height_ = undefined;
            this.scale_ = undefined;
            this.opacity_ = undefined;
            this.originX_ = undefined;
            this.originY_ = undefined;
            this.rotateWithView_ = undefined;
            this.rotation_ = undefined;
            this.width_ = undefined;
            return _super.prototype.finish.call(this);
        };
        /**
         * @param {import("../../style/Image.js").default} imageStyle Image style.
         * @param {Object=} opt_sharedData Shared data.
         */
        CanvasImageBuilder.prototype.setImageStyle = function (imageStyle, opt_sharedData) {
            var anchor = imageStyle.getAnchor();
            var size = imageStyle.getSize();
            var hitDetectionImage = imageStyle.getHitDetectionImage();
            var image = imageStyle.getImage(this.pixelRatio);
            var origin = imageStyle.getOrigin();
            this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
            this.anchorX_ = anchor[0];
            this.anchorY_ = anchor[1];
            this.hitDetectionImage_ = hitDetectionImage;
            this.image_ = image;
            this.height_ = size[1];
            this.opacity_ = imageStyle.getOpacity();
            this.originX_ = origin[0];
            this.originY_ = origin[1];
            this.rotateWithView_ = imageStyle.getRotateWithView();
            this.rotation_ = imageStyle.getRotation();
            this.scale_ = imageStyle.getScaleArray();
            this.width_ = size[0];
            this.declutterImageWithText_ = opt_sharedData;
        };
        return CanvasImageBuilder;
    }(CanvasBuilder));

    var __extends$Q = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var CanvasLineStringBuilder = /** @class */ (function (_super) {
        __extends$Q(CanvasLineStringBuilder, _super);
        /**
         * @param {number} tolerance Tolerance.
         * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
         * @param {number} resolution Resolution.
         * @param {number} pixelRatio Pixel ratio.
         */
        function CanvasLineStringBuilder(tolerance, maxExtent, resolution, pixelRatio) {
            return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
        }
        /**
         * @param {Array<number>} flatCoordinates Flat coordinates.
         * @param {number} offset Offset.
         * @param {number} end End.
         * @param {number} stride Stride.
         * @private
         * @return {number} end.
         */
        CanvasLineStringBuilder.prototype.drawFlatCoordinates_ = function (flatCoordinates, offset, end, stride) {
            var myBegin = this.coordinates.length;
            var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
            var moveToLineToInstruction = [
                Instruction.MOVE_TO_LINE_TO,
                myBegin,
                myEnd,
            ];
            this.instructions.push(moveToLineToInstruction);
            this.hitDetectionInstructions.push(moveToLineToInstruction);
            return end;
        };
        /**
         * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         */
        CanvasLineStringBuilder.prototype.drawLineString = function (lineStringGeometry, feature) {
            var state = this.state;
            var strokeStyle = state.strokeStyle;
            var lineWidth = state.lineWidth;
            if (strokeStyle === undefined || lineWidth === undefined) {
                return;
            }
            this.updateStrokeStyle(state, this.applyStroke);
            this.beginGeometry(lineStringGeometry, feature);
            this.hitDetectionInstructions.push([
                Instruction.SET_STROKE_STYLE,
                state.strokeStyle,
                state.lineWidth,
                state.lineCap,
                state.lineJoin,
                state.miterLimit,
                state.lineDash,
                state.lineDashOffset,
            ], beginPathInstruction);
            var flatCoordinates = lineStringGeometry.getFlatCoordinates();
            var stride = lineStringGeometry.getStride();
            this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
            this.hitDetectionInstructions.push(strokeInstruction);
            this.endGeometry(feature);
        };
        /**
         * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         */
        CanvasLineStringBuilder.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
            var state = this.state;
            var strokeStyle = state.strokeStyle;
            var lineWidth = state.lineWidth;
            if (strokeStyle === undefined || lineWidth === undefined) {
                return;
            }
            this.updateStrokeStyle(state, this.applyStroke);
            this.beginGeometry(multiLineStringGeometry, feature);
            this.hitDetectionInstructions.push([
                Instruction.SET_STROKE_STYLE,
                state.strokeStyle,
                state.lineWidth,
                state.lineCap,
                state.lineJoin,
                state.miterLimit,
                state.lineDash,
                state.lineDashOffset,
            ], beginPathInstruction);
            var ends = multiLineStringGeometry.getEnds();
            var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
            var stride = multiLineStringGeometry.getStride();
            var offset = 0;
            for (var i = 0, ii = ends.length; i < ii; ++i) {
                offset = this.drawFlatCoordinates_(flatCoordinates, offset, 
                /** @type {number} */ (ends[i]), stride);
            }
            this.hitDetectionInstructions.push(strokeInstruction);
            this.endGeometry(feature);
        };
        /**
         * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
         */
        CanvasLineStringBuilder.prototype.finish = function () {
            var state = this.state;
            if (state.lastStroke != undefined &&
                state.lastStroke != this.coordinates.length) {
                this.instructions.push(strokeInstruction);
            }
            this.reverseHitDetectionInstructions();
            this.state = null;
            return _super.prototype.finish.call(this);
        };
        /**
         * @param {import("../canvas.js").FillStrokeState} state State.
         */
        CanvasLineStringBuilder.prototype.applyStroke = function (state) {
            if (state.lastStroke != undefined &&
                state.lastStroke != this.coordinates.length) {
                this.instructions.push(strokeInstruction);
                state.lastStroke = this.coordinates.length;
            }
            state.lastStroke = 0;
            _super.prototype.applyStroke.call(this, state);
            this.instructions.push(beginPathInstruction);
        };
        return CanvasLineStringBuilder;
    }(CanvasBuilder));

    var __extends$P = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var CanvasPolygonBuilder = /** @class */ (function (_super) {
        __extends$P(CanvasPolygonBuilder, _super);
        /**
         * @param {number} tolerance Tolerance.
         * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
         * @param {number} resolution Resolution.
         * @param {number} pixelRatio Pixel ratio.
         */
        function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {
            return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
        }
        /**
         * @param {Array<number>} flatCoordinates Flat coordinates.
         * @param {number} offset Offset.
         * @param {Array<number>} ends Ends.
         * @param {number} stride Stride.
         * @private
         * @return {number} End.
         */
        CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {
            var state = this.state;
            var fill = state.fillStyle !== undefined;
            var stroke = state.strokeStyle !== undefined;
            var numEnds = ends.length;
            this.instructions.push(beginPathInstruction);
            this.hitDetectionInstructions.push(beginPathInstruction);
            for (var i = 0; i < numEnds; ++i) {
                var end = ends[i];
                var myBegin = this.coordinates.length;
                var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
                var moveToLineToInstruction = [
                    Instruction.MOVE_TO_LINE_TO,
                    myBegin,
                    myEnd,
                ];
                this.instructions.push(moveToLineToInstruction);
                this.hitDetectionInstructions.push(moveToLineToInstruction);
                if (stroke) {
                    // Performance optimization: only call closePath() when we have a stroke.
                    // Otherwise the ring is closed already (see appendFlatLineCoordinates above).
                    this.instructions.push(closePathInstruction);
                    this.hitDetectionInstructions.push(closePathInstruction);
                }
                offset = end;
            }
            if (fill) {
                this.instructions.push(fillInstruction);
                this.hitDetectionInstructions.push(fillInstruction);
            }
            if (stroke) {
                this.instructions.push(strokeInstruction);
                this.hitDetectionInstructions.push(strokeInstruction);
            }
            return offset;
        };
        /**
         * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
         * @param {import("../../Feature.js").default} feature Feature.
         */
        CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {
            var state = this.state;
            var fillStyle = state.fillStyle;
            var strokeStyle = state.strokeStyle;
            if (fillStyle === undefined && strokeStyle === undefined) {
                return;
            }
            this.setFillStrokeStyles_();
            this.beginGeometry(circleGeometry, feature);
            if (state.fillStyle !== undefined) {
                this.hitDetectionInstructions.push([
                    Instruction.SET_FILL_STYLE,
                    defaultFillStyle,
                ]);
            }
            if (state.strokeStyle !== undefined) {
                this.hitDetectionInstructions.push([
                    Instruction.SET_STROKE_STYLE,
                    state.strokeStyle,
                    state.lineWidth,
                    state.lineCap,
                    state.lineJoin,
                    state.miterLimit,
                    state.lineDash,
                    state.lineDashOffset,
                ]);
            }
            var flatCoordinates = circleGeometry.getFlatCoordinates();
            var stride = circleGeometry.getStride();
            var myBegin = this.coordinates.length;
            this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
            var circleInstruction = [Instruction.CIRCLE, myBegin];
            this.instructions.push(beginPathInstruction, circleInstruction);
            this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
            if (state.fillStyle !== undefined) {
                this.instructions.push(fillInstruction);
                this.hitDetectionInstructions.push(fillInstruction);
            }
            if (state.strokeStyle !== undefined) {
                this.instructions.push(strokeInstruction);
                this.hitDetectionInstructions.push(strokeInstruction);
            }
            this.endGeometry(feature);
        };
        /**
         * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         */
        CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {
            var state = this.state;
            var fillStyle = state.fillStyle;
            var strokeStyle = state.strokeStyle;
            if (fillStyle === undefined && strokeStyle === undefined) {
                return;
            }
            this.setFillStrokeStyles_();
            this.beginGeometry(polygonGeometry, feature);
            if (state.fillStyle !== undefined) {
                this.hitDetectionInstructions.push([
                    Instruction.SET_FILL_STYLE,
                    defaultFillStyle,
                ]);
            }
            if (state.strokeStyle !== undefined) {
                this.hitDetectionInstructions.push([
                    Instruction.SET_STROKE_STYLE,
                    state.strokeStyle,
                    state.lineWidth,
                    state.lineCap,
                    state.lineJoin,
                    state.miterLimit,
                    state.lineDash,
                    state.lineDashOffset,
                ]);
            }
            var ends = polygonGeometry.getEnds();
            var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
            var stride = polygonGeometry.getStride();
            this.drawFlatCoordinatess_(flatCoordinates, 0, 
            /** @type {Array<number>} */ (ends), stride);
            this.endGeometry(feature);
        };
        /**
         * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         */
        CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
            var state = this.state;
            var fillStyle = state.fillStyle;
            var strokeStyle = state.strokeStyle;
            if (fillStyle === undefined && strokeStyle === undefined) {
                return;
            }
            this.setFillStrokeStyles_();
            this.beginGeometry(multiPolygonGeometry, feature);
            if (state.fillStyle !== undefined) {
                this.hitDetectionInstructions.push([
                    Instruction.SET_FILL_STYLE,
                    defaultFillStyle,
                ]);
            }
            if (state.strokeStyle !== undefined) {
                this.hitDetectionInstructions.push([
                    Instruction.SET_STROKE_STYLE,
                    state.strokeStyle,
                    state.lineWidth,
                    state.lineCap,
                    state.lineJoin,
                    state.miterLimit,
                    state.lineDash,
                    state.lineDashOffset,
                ]);
            }
            var endss = multiPolygonGeometry.getEndss();
            var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
            var stride = multiPolygonGeometry.getStride();
            var offset = 0;
            for (var i = 0, ii = endss.length; i < ii; ++i) {
                offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
            }
            this.endGeometry(feature);
        };
        /**
         * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
         */
        CanvasPolygonBuilder.prototype.finish = function () {
            this.reverseHitDetectionInstructions();
            this.state = null;
            // We want to preserve topology when drawing polygons.  Polygons are
            // simplified using quantization and point elimination. However, we might
            // have received a mix of quantized and non-quantized geometries, so ensure
            // that all are quantized by quantizing all coordinates in the batch.
            var tolerance = this.tolerance;
            if (tolerance !== 0) {
                var coordinates = this.coordinates;
                for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                    coordinates[i] = snap(coordinates[i], tolerance);
                }
            }
            return _super.prototype.finish.call(this);
        };
        /**
         * @private
         */
        CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {
            var state = this.state;
            var fillStyle = state.fillStyle;
            if (fillStyle !== undefined) {
                this.updateFillStyle(state, this.createFill);
            }
            if (state.strokeStyle !== undefined) {
                this.updateStrokeStyle(state, this.applyStroke);
            }
        };
        return CanvasPolygonBuilder;
    }(CanvasBuilder));

    /**
     * @module ol/geom/flat/straightchunk
     */
    /**
     * @param {number} maxAngle Maximum acceptable angle delta between segments.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @return {Array<number>} Start and end of the first suitable chunk of the
     * given `flatCoordinates`.
     */
    function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
        var chunkStart = offset;
        var chunkEnd = offset;
        var chunkM = 0;
        var m = 0;
        var start = offset;
        var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
        for (i = offset; i < end; i += stride) {
            var x2 = flatCoordinates[i];
            var y2 = flatCoordinates[i + 1];
            if (x1 !== undefined) {
                x23 = x2 - x1;
                y23 = y2 - y1;
                m23 = Math.sqrt(x23 * x23 + y23 * y23);
                if (x12 !== undefined) {
                    m += m12;
                    acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
                    if (acos > maxAngle) {
                        if (m > chunkM) {
                            chunkM = m;
                            chunkStart = start;
                            chunkEnd = i;
                        }
                        m = 0;
                        start = i - stride;
                    }
                }
                m12 = m23;
                x12 = x23;
                y12 = y23;
            }
            x1 = x2;
            y1 = y2;
        }
        m += m23;
        return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
    }

    var __extends$O = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @const
     * @enum {number}
     */
    var TEXT_ALIGN = {
        'left': 0,
        'end': 0,
        'center': 0.5,
        'right': 1,
        'start': 1,
        'top': 0,
        'middle': 0.5,
        'hanging': 0.2,
        'alphabetic': 0.8,
        'ideographic': 0.8,
        'bottom': 1,
    };
    var CanvasTextBuilder = /** @class */ (function (_super) {
        __extends$O(CanvasTextBuilder, _super);
        /**
         * @param {number} tolerance Tolerance.
         * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
         * @param {number} resolution Resolution.
         * @param {number} pixelRatio Pixel ratio.
         */
        function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {
            var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
            /**
             * @private
             * @type {Array<HTMLCanvasElement>}
             */
            _this.labels_ = null;
            /**
             * @private
             * @type {string}
             */
            _this.text_ = '';
            /**
             * @private
             * @type {number}
             */
            _this.textOffsetX_ = 0;
            /**
             * @private
             * @type {number}
             */
            _this.textOffsetY_ = 0;
            /**
             * @private
             * @type {boolean|undefined}
             */
            _this.textRotateWithView_ = undefined;
            /**
             * @private
             * @type {number}
             */
            _this.textRotation_ = 0;
            /**
             * @private
             * @type {?import("../canvas.js").FillState}
             */
            _this.textFillState_ = null;
            /**
             * @type {!Object<string, import("../canvas.js").FillState>}
             */
            _this.fillStates = {};
            /**
             * @private
             * @type {?import("../canvas.js").StrokeState}
             */
            _this.textStrokeState_ = null;
            /**
             * @type {!Object<string, import("../canvas.js").StrokeState>}
             */
            _this.strokeStates = {};
            /**
             * @private
             * @type {import("../canvas.js").TextState}
             */
            _this.textState_ = /** @type {import("../canvas.js").TextState} */ ({});
            /**
             * @type {!Object<string, import("../canvas.js").TextState>}
             */
            _this.textStates = {};
            /**
             * @private
             * @type {string}
             */
            _this.textKey_ = '';
            /**
             * @private
             * @type {string}
             */
            _this.fillKey_ = '';
            /**
             * @private
             * @type {string}
             */
            _this.strokeKey_ = '';
            /**
             * Data shared with an image builder for combined decluttering.
             * @private
             * @type {import("../canvas.js").DeclutterImageWithText}
             */
            _this.declutterImageWithText_ = undefined;
            return _this;
        }
        /**
         * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
         */
        CanvasTextBuilder.prototype.finish = function () {
            var instructions = _super.prototype.finish.call(this);
            instructions.textStates = this.textStates;
            instructions.fillStates = this.fillStates;
            instructions.strokeStates = this.strokeStates;
            return instructions;
        };
        /**
         * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         */
        CanvasTextBuilder.prototype.drawText = function (geometry, feature) {
            var fillState = this.textFillState_;
            var strokeState = this.textStrokeState_;
            var textState = this.textState_;
            if (this.text_ === '' || !textState || (!fillState && !strokeState)) {
                return;
            }
            var coordinates = this.coordinates;
            var begin = coordinates.length;
            var geometryType = geometry.getType();
            var flatCoordinates = null;
            var stride = geometry.getStride();
            if (textState.placement === TextPlacement.LINE &&
                (geometryType == GeometryType.LINE_STRING ||
                    geometryType == GeometryType.MULTI_LINE_STRING ||
                    geometryType == GeometryType.POLYGON ||
                    geometryType == GeometryType.MULTI_POLYGON)) {
                if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
                    return;
                }
                var ends = void 0;
                flatCoordinates = geometry.getFlatCoordinates();
                if (geometryType == GeometryType.LINE_STRING) {
                    ends = [flatCoordinates.length];
                }
                else if (geometryType == GeometryType.MULTI_LINE_STRING) {
                    ends = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry).getEnds();
                }
                else if (geometryType == GeometryType.POLYGON) {
                    ends = /** @type {import("../../geom/Polygon.js").default} */ (geometry)
                        .getEnds()
                        .slice(0, 1);
                }
                else if (geometryType == GeometryType.MULTI_POLYGON) {
                    var endss = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getEndss();
                    ends = [];
                    for (var i = 0, ii = endss.length; i < ii; ++i) {
                        ends.push(endss[i][0]);
                    }
                }
                this.beginGeometry(geometry, feature);
                var textAlign = textState.textAlign;
                var flatOffset = 0;
                var flatEnd = void 0;
                for (var o = 0, oo = ends.length; o < oo; ++o) {
                    if (textAlign == undefined) {
                        var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
                        flatOffset = range[0];
                        flatEnd = range[1];
                    }
                    else {
                        flatEnd = ends[o];
                    }
                    for (var i = flatOffset; i < flatEnd; i += stride) {
                        coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
                    }
                    var end = coordinates.length;
                    flatOffset = ends[o];
                    this.drawChars_(begin, end);
                    begin = end;
                }
                this.endGeometry(feature);
            }
            else {
                var geometryWidths = textState.overflow ? null : [];
                switch (geometryType) {
                    case GeometryType.POINT:
                    case GeometryType.MULTI_POINT:
                        flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */ (geometry).getFlatCoordinates();
                        break;
                    case GeometryType.LINE_STRING:
                        flatCoordinates = /** @type {import("../../geom/LineString.js").default} */ (geometry).getFlatMidpoint();
                        break;
                    case GeometryType.CIRCLE:
                        flatCoordinates = /** @type {import("../../geom/Circle.js").default} */ (geometry).getCenter();
                        break;
                    case GeometryType.MULTI_LINE_STRING:
                        flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry).getFlatMidpoints();
                        stride = 2;
                        break;
                    case GeometryType.POLYGON:
                        flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */ (geometry).getFlatInteriorPoint();
                        if (!textState.overflow) {
                            geometryWidths.push(flatCoordinates[2] / this.resolution);
                        }
                        stride = 3;
                        break;
                    case GeometryType.MULTI_POLYGON:
                        var interiorPoints = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getFlatInteriorPoints();
                        flatCoordinates = [];
                        for (var i = 0, ii = interiorPoints.length; i < ii; i += 3) {
                            if (!textState.overflow) {
                                geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                            }
                            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
                        }
                        if (flatCoordinates.length === 0) {
                            return;
                        }
                        stride = 2;
                        break;
                }
                var end = this.appendFlatPointCoordinates(flatCoordinates, stride);
                if (end === begin) {
                    return;
                }
                this.saveTextStates_();
                if (textState.backgroundFill || textState.backgroundStroke) {
                    this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
                    if (textState.backgroundFill) {
                        this.updateFillStyle(this.state, this.createFill);
                        this.hitDetectionInstructions.push(this.createFill(this.state));
                    }
                    if (textState.backgroundStroke) {
                        this.updateStrokeStyle(this.state, this.applyStroke);
                        this.hitDetectionInstructions.push(this.createStroke(this.state));
                    }
                }
                this.beginGeometry(geometry, feature);
                // adjust padding for negative scale
                var padding = textState.padding;
                if (padding != defaultPadding &&
                    (textState.scale[0] < 0 || textState.scale[1] < 0)) {
                    var p0 = textState.padding[0];
                    var p1 = textState.padding[1];
                    var p2 = textState.padding[2];
                    var p3 = textState.padding[3];
                    if (textState.scale[0] < 0) {
                        p1 = -p1;
                        p3 = -p3;
                    }
                    if (textState.scale[1] < 0) {
                        p0 = -p0;
                        p2 = -p2;
                    }
                    padding = [p0, p1, p2, p3];
                }
                // The image is unknown at this stage so we pass null; it will be computed at render time.
                // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
                // render time.
                var pixelRatio_1 = this.pixelRatio;
                this.instructions.push([
                    Instruction.DRAW_IMAGE,
                    begin,
                    end,
                    null,
                    NaN,
                    NaN,
                    NaN,
                    1,
                    0,
                    0,
                    this.textRotateWithView_,
                    this.textRotation_,
                    [1, 1],
                    NaN,
                    this.declutterImageWithText_,
                    padding == defaultPadding
                        ? defaultPadding
                        : padding.map(function (p) {
                            return p * pixelRatio_1;
                        }),
                    !!textState.backgroundFill,
                    !!textState.backgroundStroke,
                    this.text_,
                    this.textKey_,
                    this.strokeKey_,
                    this.fillKey_,
                    this.textOffsetX_,
                    this.textOffsetY_,
                    geometryWidths,
                ]);
                var scale = 1 / pixelRatio_1;
                this.hitDetectionInstructions.push([
                    Instruction.DRAW_IMAGE,
                    begin,
                    end,
                    null,
                    NaN,
                    NaN,
                    NaN,
                    1,
                    0,
                    0,
                    this.textRotateWithView_,
                    this.textRotation_,
                    [scale, scale],
                    NaN,
                    this.declutterImageWithText_,
                    padding,
                    !!textState.backgroundFill,
                    !!textState.backgroundStroke,
                    this.text_,
                    this.textKey_,
                    this.strokeKey_,
                    this.fillKey_,
                    this.textOffsetX_,
                    this.textOffsetY_,
                    geometryWidths,
                ]);
                this.endGeometry(feature);
            }
        };
        /**
         * @private
         */
        CanvasTextBuilder.prototype.saveTextStates_ = function () {
            var strokeState = this.textStrokeState_;
            var textState = this.textState_;
            var fillState = this.textFillState_;
            var strokeKey = this.strokeKey_;
            if (strokeState) {
                if (!(strokeKey in this.strokeStates)) {
                    this.strokeStates[strokeKey] = {
                        strokeStyle: strokeState.strokeStyle,
                        lineCap: strokeState.lineCap,
                        lineDashOffset: strokeState.lineDashOffset,
                        lineWidth: strokeState.lineWidth,
                        lineJoin: strokeState.lineJoin,
                        miterLimit: strokeState.miterLimit,
                        lineDash: strokeState.lineDash,
                    };
                }
            }
            var textKey = this.textKey_;
            if (!(textKey in this.textStates)) {
                this.textStates[textKey] = {
                    font: textState.font,
                    textAlign: textState.textAlign || defaultTextAlign,
                    textBaseline: textState.textBaseline || defaultTextBaseline,
                    scale: textState.scale,
                };
            }
            var fillKey = this.fillKey_;
            if (fillState) {
                if (!(fillKey in this.fillStates)) {
                    this.fillStates[fillKey] = {
                        fillStyle: fillState.fillStyle,
                    };
                }
            }
        };
        /**
         * @private
         * @param {number} begin Begin.
         * @param {number} end End.
         */
        CanvasTextBuilder.prototype.drawChars_ = function (begin, end) {
            var strokeState = this.textStrokeState_;
            var textState = this.textState_;
            var strokeKey = this.strokeKey_;
            var textKey = this.textKey_;
            var fillKey = this.fillKey_;
            this.saveTextStates_();
            var pixelRatio = this.pixelRatio;
            var baseline = TEXT_ALIGN[textState.textBaseline];
            var offsetY = this.textOffsetY_ * pixelRatio;
            var text = this.text_;
            var strokeWidth = strokeState
                ? (strokeState.lineWidth * Math.abs(textState.scale[0])) / 2
                : 0;
            this.instructions.push([
                Instruction.DRAW_CHARS,
                begin,
                end,
                baseline,
                textState.overflow,
                fillKey,
                textState.maxAngle,
                pixelRatio,
                offsetY,
                strokeKey,
                strokeWidth * pixelRatio,
                text,
                textKey,
                1,
            ]);
            this.hitDetectionInstructions.push([
                Instruction.DRAW_CHARS,
                begin,
                end,
                baseline,
                textState.overflow,
                fillKey,
                textState.maxAngle,
                1,
                offsetY,
                strokeKey,
                strokeWidth,
                text,
                textKey,
                1 / pixelRatio,
            ]);
        };
        /**
         * @param {import("../../style/Text.js").default} textStyle Text style.
         * @param {Object=} opt_sharedData Shared data.
         */
        CanvasTextBuilder.prototype.setTextStyle = function (textStyle, opt_sharedData) {
            var textState, fillState, strokeState;
            if (!textStyle) {
                this.text_ = '';
            }
            else {
                var textFillStyle = textStyle.getFill();
                if (!textFillStyle) {
                    fillState = null;
                    this.textFillState_ = fillState;
                }
                else {
                    fillState = this.textFillState_;
                    if (!fillState) {
                        fillState = /** @type {import("../canvas.js").FillState} */ ({});
                        this.textFillState_ = fillState;
                    }
                    fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);
                }
                var textStrokeStyle = textStyle.getStroke();
                if (!textStrokeStyle) {
                    strokeState = null;
                    this.textStrokeState_ = strokeState;
                }
                else {
                    strokeState = this.textStrokeState_;
                    if (!strokeState) {
                        strokeState = /** @type {import("../canvas.js").StrokeState} */ ({});
                        this.textStrokeState_ = strokeState;
                    }
                    var lineDash = textStrokeStyle.getLineDash();
                    var lineDashOffset = textStrokeStyle.getLineDashOffset();
                    var lineWidth = textStrokeStyle.getWidth();
                    var miterLimit = textStrokeStyle.getMiterLimit();
                    strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
                    strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
                    strokeState.lineDashOffset =
                        lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;
                    strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
                    strokeState.lineWidth =
                        lineWidth === undefined ? defaultLineWidth : lineWidth;
                    strokeState.miterLimit =
                        miterLimit === undefined ? defaultMiterLimit : miterLimit;
                    strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);
                }
                textState = this.textState_;
                var font = textStyle.getFont() || defaultFont;
                registerFont(font);
                var textScale = textStyle.getScaleArray();
                textState.overflow = textStyle.getOverflow();
                textState.font = font;
                textState.maxAngle = textStyle.getMaxAngle();
                textState.placement = textStyle.getPlacement();
                textState.textAlign = textStyle.getTextAlign();
                textState.textBaseline =
                    textStyle.getTextBaseline() || defaultTextBaseline;
                textState.backgroundFill = textStyle.getBackgroundFill();
                textState.backgroundStroke = textStyle.getBackgroundStroke();
                textState.padding = textStyle.getPadding() || defaultPadding;
                textState.scale = textScale === undefined ? [1, 1] : textScale;
                var textOffsetX = textStyle.getOffsetX();
                var textOffsetY = textStyle.getOffsetY();
                var textRotateWithView = textStyle.getRotateWithView();
                var textRotation = textStyle.getRotation();
                this.text_ = textStyle.getText() || '';
                this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
                this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
                this.textRotateWithView_ =
                    textRotateWithView === undefined ? false : textRotateWithView;
                this.textRotation_ = textRotation === undefined ? 0 : textRotation;
                this.strokeKey_ = strokeState
                    ? (typeof strokeState.strokeStyle == 'string'
                        ? strokeState.strokeStyle
                        : getUid(strokeState.strokeStyle)) +
                        strokeState.lineCap +
                        strokeState.lineDashOffset +
                        '|' +
                        strokeState.lineWidth +
                        strokeState.lineJoin +
                        strokeState.miterLimit +
                        '[' +
                        strokeState.lineDash.join() +
                        ']'
                    : '';
                this.textKey_ =
                    textState.font +
                        textState.scale +
                        (textState.textAlign || '?') +
                        (textState.textBaseline || '?');
                this.fillKey_ = fillState
                    ? typeof fillState.fillStyle == 'string'
                        ? fillState.fillStyle
                        : '|' + getUid(fillState.fillStyle)
                    : '';
            }
            this.declutterImageWithText_ = opt_sharedData;
        };
        return CanvasTextBuilder;
    }(CanvasBuilder));

    /**
     * @module ol/render/canvas/BuilderGroup
     */
    /**
     * @type {Object<import("./BuilderType").default, typeof Builder>}
     */
    var BATCH_CONSTRUCTORS = {
        'Circle': CanvasPolygonBuilder,
        'Default': CanvasBuilder,
        'Image': CanvasImageBuilder,
        'LineString': CanvasLineStringBuilder,
        'Polygon': CanvasPolygonBuilder,
        'Text': CanvasTextBuilder,
    };
    var BuilderGroup = /** @class */ (function () {
        /**
         * @param {number} tolerance Tolerance.
         * @param {import("../../extent.js").Extent} maxExtent Max extent.
         * @param {number} resolution Resolution.
         * @param {number} pixelRatio Pixel ratio.
         */
        function BuilderGroup(tolerance, maxExtent, resolution, pixelRatio) {
            /**
             * @private
             * @type {number}
             */
            this.tolerance_ = tolerance;
            /**
             * @private
             * @type {import("../../extent.js").Extent}
             */
            this.maxExtent_ = maxExtent;
            /**
             * @private
             * @type {number}
             */
            this.pixelRatio_ = pixelRatio;
            /**
             * @private
             * @type {number}
             */
            this.resolution_ = resolution;
            /**
             * @private
             * @type {!Object<string, !Object<import("./BuilderType").default, Builder>>}
             */
            this.buildersByZIndex_ = {};
        }
        /**
         * @return {!Object<string, !Object<import("./BuilderType").default, import("./Builder.js").SerializableInstructions>>} The serializable instructions
         */
        BuilderGroup.prototype.finish = function () {
            var builderInstructions = {};
            for (var zKey in this.buildersByZIndex_) {
                builderInstructions[zKey] = builderInstructions[zKey] || {};
                var builders = this.buildersByZIndex_[zKey];
                for (var builderKey in builders) {
                    var builderInstruction = builders[builderKey].finish();
                    builderInstructions[zKey][builderKey] = builderInstruction;
                }
            }
            return builderInstructions;
        };
        /**
         * @param {number|undefined} zIndex Z index.
         * @param {import("./BuilderType.js").default} builderType Replay type.
         * @return {import("../VectorContext.js").default} Replay.
         */
        BuilderGroup.prototype.getBuilder = function (zIndex, builderType) {
            var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
            var replays = this.buildersByZIndex_[zIndexKey];
            if (replays === undefined) {
                replays = {};
                this.buildersByZIndex_[zIndexKey] = replays;
            }
            var replay = replays[builderType];
            if (replay === undefined) {
                var Constructor = BATCH_CONSTRUCTORS[builderType];
                replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
                replays[builderType] = replay;
            }
            return replay;
        };
        return BuilderGroup;
    }());

    var __extends$N = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @template {import("../layer/Layer.js").default} LayerType
     */
    var LayerRenderer = /** @class */ (function (_super) {
        __extends$N(LayerRenderer, _super);
        /**
         * @param {LayerType} layer Layer.
         */
        function LayerRenderer(layer) {
            var _this = _super.call(this) || this;
            /** @private */
            _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);
            /**
             * @protected
             * @type {LayerType}
             */
            _this.layer_ = layer;
            /**
             * @type {import("../render/canvas/ExecutorGroup").default}
             */
            _this.declutterExecutorGroup = null;
            return _this;
        }
        /**
         * Asynchronous layer level hit detection.
         * @param {import("../pixel.js").Pixel} pixel Pixel.
         * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
         * an array of features.
         */
        LayerRenderer.prototype.getFeatures = function (pixel) {
            return abstract();
        };
        /**
         * Determine whether render should be called.
         * @abstract
         * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
         * @return {boolean} Layer is ready to be rendered.
         */
        LayerRenderer.prototype.prepareFrame = function (frameState) {
            return abstract();
        };
        /**
         * Render the layer.
         * @abstract
         * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
         * @param {HTMLElement} target Target that may be used to render content to.
         * @return {HTMLElement} The rendered element.
         */
        LayerRenderer.prototype.renderFrame = function (frameState, target) {
            return abstract();
        };
        /**
         * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
         * @param {number} zoom Zoom level.
         * @param {import("../Tile.js").default} tile Tile.
         * @return {boolean|void} If `false`, the tile will not be considered loaded.
         */
        LayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
            if (!tiles[zoom]) {
                tiles[zoom] = {};
            }
            tiles[zoom][tile.tileCoord.toString()] = tile;
            return undefined;
        };
        /**
         * Create a function that adds loaded tiles to the tile lookup.
         * @param {import("../source/Tile.js").default} source Tile source.
         * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
         * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
         * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
         *     called with a zoom level and a tile range to add loaded tiles to the lookup.
         * @protected
         */
        LayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {
            return (
            /**
             * @param {number} zoom Zoom level.
             * @param {import("../TileRange.js").default} tileRange Tile range.
             * @return {boolean} The tile range is fully loaded.
             * @this {LayerRenderer}
             */
            function (zoom, tileRange) {
                var callback = this.loadedTileCallback.bind(this, tiles, zoom);
                return source.forEachLoadedTile(projection, zoom, tileRange, callback);
            }.bind(this));
        };
        /**
         * @abstract
         * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
         * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
         * @param {number} hitTolerance Hit tolerance in pixels.
         * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
         * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
         * @return {T|undefined} Callback result.
         * @template T
         */
        LayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {
            return undefined;
        };
        /**
         * @abstract
         * @param {import("../pixel.js").Pixel} pixel Pixel.
         * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
         * @param {number} hitTolerance Hit tolerance in pixels.
         * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
         *    location, null will be returned.  If there is data, but pixel values cannot be
         *    returned, and empty array will be returned.
         */
        LayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
            return abstract();
        };
        /**
         * @return {LayerType} Layer.
         */
        LayerRenderer.prototype.getLayer = function () {
            return this.layer_;
        };
        /**
         * Perform action necessary to get the layer rendered after new fonts have loaded
         * @abstract
         */
        LayerRenderer.prototype.handleFontsChanged = function () { };
        /**
         * Handle changes in image state.
         * @param {import("../events/Event.js").default} event Image change event.
         * @private
         */
        LayerRenderer.prototype.handleImageChange_ = function (event) {
            var image = /** @type {import("../Image.js").default} */ (event.target);
            if (image.getState() === ImageState.LOADED) {
                this.renderIfReadyAndVisible();
            }
        };
        /**
         * Load the image if not already loaded, and register the image change
         * listener if needed.
         * @param {import("../ImageBase.js").default} image Image.
         * @return {boolean} `true` if the image is already loaded, `false` otherwise.
         * @protected
         */
        LayerRenderer.prototype.loadImage = function (image) {
            var imageState = image.getState();
            if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {
                image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);
            }
            if (imageState == ImageState.IDLE) {
                image.load();
                imageState = image.getState();
            }
            return imageState == ImageState.LOADED;
        };
        /**
         * @protected
         */
        LayerRenderer.prototype.renderIfReadyAndVisible = function () {
            var layer = this.getLayer();
            if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {
                layer.changed();
            }
        };
        return LayerRenderer;
    }(Observable));

    /**
     * @module ol/render/Event
     */
    var __extends$M = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var RenderEvent = /** @class */ (function (_super) {
        __extends$M(RenderEvent, _super);
        /**
         * @param {import("./EventType.js").default} type Type.
         * @param {import("../transform.js").Transform=} opt_inversePixelTransform Transform for
         *     CSS pixels to rendered pixels.
         * @param {import("../PluggableMap.js").FrameState=} opt_frameState Frame state.
         * @param {?CanvasRenderingContext2D=} opt_context Context.
         */
        function RenderEvent(type, opt_inversePixelTransform, opt_frameState, opt_context) {
            var _this = _super.call(this, type) || this;
            /**
             * Transform from CSS pixels (relative to the top-left corner of the map viewport)
             * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
             * @type {import("../transform.js").Transform|undefined}
             * @api
             */
            _this.inversePixelTransform = opt_inversePixelTransform;
            /**
             * An object representing the current render frame state.
             * @type {import("../PluggableMap.js").FrameState|undefined}
             * @api
             */
            _this.frameState = opt_frameState;
            /**
             * Canvas context. Not available when the event is dispatched by the map. Only available
             * when a Canvas renderer is used, null otherwise.
             * @type {CanvasRenderingContext2D|null|undefined}
             * @api
             */
            _this.context = opt_context;
            return _this;
        }
        return RenderEvent;
    }(BaseEvent));

    var __extends$L = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @abstract
     * @template {import("../../layer/Layer.js").default} LayerType
     */
    var CanvasLayerRenderer = /** @class */ (function (_super) {
        __extends$L(CanvasLayerRenderer, _super);
        /**
         * @param {LayerType} layer Layer.
         */
        function CanvasLayerRenderer(layer) {
            var _this = _super.call(this, layer) || this;
            /**
             * @protected
             * @type {HTMLElement}
             */
            _this.container = null;
            /**
             * @protected
             * @type {number}
             */
            _this.renderedResolution;
            /**
             * A temporary transform.  The values in this transform should only be used in a
             * function that sets the values.
             * @protected
             * @type {import("../../transform.js").Transform}
             */
            _this.tempTransform = create();
            /**
             * The transform for rendered pixels to viewport CSS pixels.  This transform must
             * be set when rendering a frame and may be used by other functions after rendering.
             * @protected
             * @type {import("../../transform.js").Transform}
             */
            _this.pixelTransform = create();
            /**
             * The transform for viewport CSS pixels to rendered pixels.  This transform must
             * be set when rendering a frame and may be used by other functions after rendering.
             * @protected
             * @type {import("../../transform.js").Transform}
             */
            _this.inversePixelTransform = create();
            /**
             * @type {CanvasRenderingContext2D}
             */
            _this.context = null;
            /**
             * @type {boolean}
             */
            _this.containerReused = false;
            return _this;
        }
        /**
         * Get a rendering container from an existing target, if compatible.
         * @param {HTMLElement} target Potential render target.
         * @param {string} transform CSS Transform.
         * @param {number} opacity Opacity.
         */
        CanvasLayerRenderer.prototype.useContainer = function (target, transform, opacity) {
            var layerClassName = this.getLayer().getClassName();
            var container, context;
            if (target &&
                target.style.opacity === '' &&
                target.className === layerClassName) {
                var canvas = target.firstElementChild;
                if (canvas instanceof HTMLCanvasElement) {
                    context = canvas.getContext('2d');
                }
            }
            if (context &&
                (context.canvas.width === 0 ||
                    context.canvas.style.transform === transform)) {
                // Container of the previous layer renderer can be used.
                this.container = target;
                this.context = context;
                this.containerReused = true;
            }
            else if (this.containerReused) {
                // Previously reused container cannot be used any more.
                this.container = null;
                this.context = null;
                this.containerReused = false;
            }
            if (!this.container) {
                container = document.createElement('div');
                container.className = layerClassName;
                var style = container.style;
                style.position = 'absolute';
                style.width = '100%';
                style.height = '100%';
                context = createCanvasContext2D();
                var canvas = context.canvas;
                container.appendChild(canvas);
                style = canvas.style;
                style.position = 'absolute';
                style.left = '0';
                style.transformOrigin = 'top left';
                this.container = container;
                this.context = context;
            }
        };
        /**
         * @param {CanvasRenderingContext2D} context Context.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @param {import("../../extent.js").Extent} extent Clip extent.
         * @protected
         */
        CanvasLayerRenderer.prototype.clip = function (context, frameState, extent) {
            var pixelRatio = frameState.pixelRatio;
            var halfWidth = (frameState.size[0] * pixelRatio) / 2;
            var halfHeight = (frameState.size[1] * pixelRatio) / 2;
            var rotation = frameState.viewState.rotation;
            var topLeft = getTopLeft(extent);
            var topRight = getTopRight(extent);
            var bottomRight = getBottomRight(extent);
            var bottomLeft = getBottomLeft(extent);
            apply(frameState.coordinateToPixelTransform, topLeft);
            apply(frameState.coordinateToPixelTransform, topRight);
            apply(frameState.coordinateToPixelTransform, bottomRight);
            apply(frameState.coordinateToPixelTransform, bottomLeft);
            context.save();
            rotateAtOffset(context, -rotation, halfWidth, halfHeight);
            context.beginPath();
            context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
            context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
            context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
            context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
            context.clip();
            rotateAtOffset(context, rotation, halfWidth, halfHeight);
        };
        /**
         * @param {CanvasRenderingContext2D} context Context.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @param {import("../../extent.js").Extent} extent Clip extent.
         * @protected
         */
        CanvasLayerRenderer.prototype.clipUnrotated = function (context, frameState, extent) {
            var topLeft = getTopLeft(extent);
            var topRight = getTopRight(extent);
            var bottomRight = getBottomRight(extent);
            var bottomLeft = getBottomLeft(extent);
            apply(frameState.coordinateToPixelTransform, topLeft);
            apply(frameState.coordinateToPixelTransform, topRight);
            apply(frameState.coordinateToPixelTransform, bottomRight);
            apply(frameState.coordinateToPixelTransform, bottomLeft);
            var inverted = this.inversePixelTransform;
            apply(inverted, topLeft);
            apply(inverted, topRight);
            apply(inverted, bottomRight);
            apply(inverted, bottomLeft);
            context.save();
            context.beginPath();
            context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
            context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
            context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
            context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
            context.clip();
        };
        /**
         * @param {import("../../render/EventType.js").default} type Event type.
         * @param {CanvasRenderingContext2D} context Context.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @private
         */
        CanvasLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {
            var layer = this.getLayer();
            if (layer.hasListener(type)) {
                var event_1 = new RenderEvent(type, this.inversePixelTransform, frameState, context);
                layer.dispatchEvent(event_1);
            }
        };
        /**
         * @param {CanvasRenderingContext2D} context Context.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @protected
         */
        CanvasLayerRenderer.prototype.preRender = function (context, frameState) {
            this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);
        };
        /**
         * @param {CanvasRenderingContext2D} context Context.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @protected
         */
        CanvasLayerRenderer.prototype.postRender = function (context, frameState) {
            this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);
        };
        /**
         * Creates a transform for rendering to an element that will be rotated after rendering.
         * @param {import("../../coordinate.js").Coordinate} center Center.
         * @param {number} resolution Resolution.
         * @param {number} rotation Rotation.
         * @param {number} pixelRatio Pixel ratio.
         * @param {number} width Width of the rendered element (in pixels).
         * @param {number} height Height of the rendered element (in pixels).
         * @param {number} offsetX Offset on the x-axis in view coordinates.
         * @protected
         * @return {!import("../../transform.js").Transform} Transform.
         */
        CanvasLayerRenderer.prototype.getRenderTransform = function (center, resolution, rotation, pixelRatio, width, height, offsetX) {
            var dx1 = width / 2;
            var dy1 = height / 2;
            var sx = pixelRatio / resolution;
            var sy = -sx;
            var dx2 = -center[0] + offsetX;
            var dy2 = -center[1];
            return compose(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
        };
        /**
         * @param {import("../../pixel.js").Pixel} pixel Pixel.
         * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.
         * @param {number} hitTolerance Hit tolerance in pixels.
         * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
         *    location, null will be returned.  If there is data, but pixel values cannot be
         *    returned, and empty array will be returned.
         */
        CanvasLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
            var renderPixel = apply(this.inversePixelTransform, pixel.slice());
            var context = this.context;
            var layer = this.getLayer();
            var layerExtent = layer.getExtent();
            if (layerExtent) {
                var renderCoordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());
                /** get only data inside of the layer extent */
                if (!containsCoordinate(layerExtent, renderCoordinate)) {
                    return null;
                }
            }
            var data;
            try {
                var x = Math.round(renderPixel[0]);
                var y = Math.round(renderPixel[1]);
                var newCanvas = document.createElement('canvas');
                var newContext = newCanvas.getContext('2d');
                newCanvas.width = 1;
                newCanvas.height = 1;
                newContext.clearRect(0, 0, 1, 1);
                newContext.drawImage(context.canvas, x, y, 1, 1, 0, 0, 1, 1);
                data = newContext.getImageData(0, 0, 1, 1).data;
            }
            catch (err) {
                if (err.name === 'SecurityError') {
                    // tainted canvas, we assume there is data at the given pixel (although there might not be)
                    return new Uint8Array();
                }
                return data;
            }
            if (data[3] === 0) {
                return null;
            }
            return data;
        };
        return CanvasLayerRenderer;
    }(LayerRenderer));

    /**
     * @module ol/render/canvas/BuilderType
     */
    /**
     * @enum {string}
     */
    var ReplayType = {
        CIRCLE: 'Circle',
        DEFAULT: 'Default',
        IMAGE: 'Image',
        LINE_STRING: 'LineString',
        POLYGON: 'Polygon',
        TEXT: 'Text',
    };

    /**
     * @module ol/geom/flat/textpath
     */
    /**
     * @param {Array<number>} flatCoordinates Path to put text on.
     * @param {number} offset Start offset of the `flatCoordinates`.
     * @param {number} end End offset of the `flatCoordinates`.
     * @param {number} stride Stride.
     * @param {string} text Text to place on the path.
     * @param {number} startM m along the path where the text starts.
     * @param {number} maxAngle Max angle between adjacent chars in radians.
     * @param {number} scale The product of the text scale and the device pixel ratio.
     * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
     * @param {string} font The font.
     * @param {Object<string, number>} cache A cache of measured widths.
     * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
     * @return {Array<Array<*>>} The result array (or null if `maxAngle` was
     * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
     */
    function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        var x1 = 0;
        var y1 = 0;
        var segmentLength = 0;
        var segmentM = 0;
        function advance() {
            x1 = x2;
            y1 = y2;
            offset += stride;
            x2 = flatCoordinates[offset];
            y2 = flatCoordinates[offset + 1];
            segmentM += segmentLength;
            segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        }
        do {
            advance();
        } while (offset < end - stride && segmentM + segmentLength < startM);
        var interpolate = (startM - segmentM) / segmentLength;
        var beginX = lerp(x1, x2, interpolate);
        var beginY = lerp(y1, y2, interpolate);
        var startOffset = offset - stride;
        var startLength = segmentM;
        var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);
        while (offset < end - stride && segmentM + segmentLength < endM) {
            advance();
        }
        interpolate = (endM - segmentM) / segmentLength;
        var endX = lerp(x1, x2, interpolate);
        var endY = lerp(y1, y2, interpolate);
        // Keep text upright
        var reverse;
        if (rotation) {
            var flat = [beginX, beginY, endX, endY];
            rotate(flat, 0, 4, 2, rotation, flat, flat);
            reverse = flat[0] > flat[2];
        }
        else {
            reverse = beginX > endX;
        }
        var PI = Math.PI;
        var result = [];
        var singleSegment = startOffset + stride === offset;
        offset = startOffset;
        segmentLength = 0;
        segmentM = startLength;
        x2 = flatCoordinates[offset];
        y2 = flatCoordinates[offset + 1];
        // All on the same segment
        if (singleSegment) {
            advance();
            var previousAngle_1 = Math.atan2(y2 - y1, x2 - x1);
            if (reverse) {
                previousAngle_1 += previousAngle_1 > 0 ? -PI : PI;
            }
            var x = (endX + beginX) / 2;
            var y = (endY + beginY) / 2;
            result[0] = [x, y, (endM - startM) / 2, previousAngle_1, text];
            return result;
        }
        var previousAngle;
        for (var i = 0, ii = text.length; i < ii;) {
            advance();
            var angle = Math.atan2(y2 - y1, x2 - x1);
            if (reverse) {
                angle += angle > 0 ? -PI : PI;
            }
            if (previousAngle !== undefined) {
                var delta = angle - previousAngle;
                delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
                if (Math.abs(delta) > maxAngle) {
                    return null;
                }
            }
            previousAngle = angle;
            var iStart = i;
            var charLength = 0;
            for (; i < ii; ++i) {
                var index = reverse ? ii - i - 1 : i;
                var len = scale * measureAndCacheTextWidth(font, text[index], cache);
                if (offset + stride < end &&
                    segmentM + segmentLength < startM + charLength + len / 2) {
                    break;
                }
                charLength += len;
            }
            if (i === iStart) {
                continue;
            }
            var chars = reverse
                ? text.substring(ii - iStart, ii - i)
                : text.substring(iStart, i);
            interpolate = (startM + charLength / 2 - segmentM) / segmentLength;
            var x = lerp(x1, x2, interpolate);
            var y = lerp(y1, y2, interpolate);
            result.push([x, y, charLength / 2, angle, chars]);
            startM += charLength;
        }
        return result;
    }

    /**
     * @module ol/render/canvas/Executor
     */
    /**
     * @typedef {Object} BBox
     * @property {number} minX
     * @property {number} minY
     * @property {number} maxX
     * @property {number} maxY
     * @property {*} value
     */
    /**
     * @typedef {Object} ImageOrLabelDimensions
     * @property {number} drawImageX
     * @property {number} drawImageY
     * @property {number} drawImageW
     * @property {number} drawImageH
     * @property {number} originX
     * @property {number} originY
     * @property {Array<number>} scale
     * @property {BBox} declutterBox
     * @property {import("../../transform.js").Transform} canvasTransform
     */
    /**
     * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs
     */
    /**
     * @template T
     * @typedef {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default): T} FeatureCallback
     */
    /**
     * @type {import("../../extent.js").Extent}
     */
    var tmpExtent = createEmpty();
    /** @type {import("../../coordinate.js").Coordinate} */
    var p1 = [];
    /** @type {import("../../coordinate.js").Coordinate} */
    var p2 = [];
    /** @type {import("../../coordinate.js").Coordinate} */
    var p3 = [];
    /** @type {import("../../coordinate.js").Coordinate} */
    var p4 = [];
    /**
     * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
     * @return {BBox} Declutter bbox.
     */
    function getDeclutterBox(replayImageOrLabelArgs) {
        return replayImageOrLabelArgs[3].declutterBox;
    }
    var rtlRegEx = new RegExp(
    /* eslint-disable prettier/prettier */
    '[' +
        String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) +
        String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) +
        String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) +
        String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) +
        String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) +
        ']'
    /* eslint-enable prettier/prettier */
    );
    /**
     * @param {string} text Text.
     * @param {string} align Alignment.
     * @return {number} Text alignment.
     */
    function horizontalTextAlign(text, align) {
        if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {
            align = align === 'start' ? 'left' : 'right';
        }
        return TEXT_ALIGN[align];
    }
    var Executor = /** @class */ (function () {
        /**
         * @param {number} resolution Resolution.
         * @param {number} pixelRatio Pixel ratio.
         * @param {boolean} overlaps The replay can have overlapping geometries.
         * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
         * @param {import("../../size.js").Size} renderBuffer Render buffer (width/height) in pixels.
         */
        function Executor(resolution, pixelRatio, overlaps, instructions, renderBuffer) {
            /**
             * @protected
             * @type {boolean}
             */
            this.overlaps = overlaps;
            /**
             * @protected
             * @type {number}
             */
            this.pixelRatio = pixelRatio;
            /**
             * @protected
             * @const
             * @type {number}
             */
            this.resolution = resolution;
            /**
             * @private
             * @type {boolean}
             */
            this.alignFill_;
            /**
             * @protected
             * @type {Array<*>}
             */
            this.instructions = instructions.instructions;
            /**
             * @protected
             * @type {Array<number>}
             */
            this.coordinates = instructions.coordinates;
            /**
             * @private
             * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
             */
            this.coordinateCache_ = {};
            /**
             * @private
             * @type {import("../../size.js").Size}
             */
            this.renderBuffer_ = renderBuffer;
            /**
             * @private
             * @type {!import("../../transform.js").Transform}
             */
            this.renderedTransform_ = create();
            /**
             * @protected
             * @type {Array<*>}
             */
            this.hitDetectionInstructions = instructions.hitDetectionInstructions;
            /**
             * @private
             * @type {Array<number>}
             */
            this.pixelCoordinates_ = null;
            /**
             * @private
             * @type {number}
             */
            this.viewRotation_ = 0;
            /**
             * @type {!Object<string, import("../canvas.js").FillState>}
             */
            this.fillStates = instructions.fillStates || {};
            /**
             * @type {!Object<string, import("../canvas.js").StrokeState>}
             */
            this.strokeStates = instructions.strokeStates || {};
            /**
             * @type {!Object<string, import("../canvas.js").TextState>}
             */
            this.textStates = instructions.textStates || {};
            /**
             * @private
             * @type {Object<string, Object<string, number>>}
             */
            this.widths_ = {};
            /**
             * @private
             * @type {Object<string, import("../canvas.js").Label>}
             */
            this.labels_ = {};
        }
        /**
         * @param {string} text Text.
         * @param {string} textKey Text style key.
         * @param {string} fillKey Fill style key.
         * @param {string} strokeKey Stroke style key.
         * @return {import("../canvas.js").Label} Label.
         */
        Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {
            var key = text + textKey + fillKey + strokeKey;
            if (this.labels_[key]) {
                return this.labels_[key];
            }
            var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
            var fillState = fillKey ? this.fillStates[fillKey] : null;
            var textState = this.textStates[textKey];
            var pixelRatio = this.pixelRatio;
            var scale = [
                textState.scale[0] * pixelRatio,
                textState.scale[1] * pixelRatio,
            ];
            var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);
            var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
            var lines = text.split('\n');
            var numLines = lines.length;
            var widths = [];
            var width = measureTextWidths(textState.font, lines, widths);
            var lineHeight = measureTextHeight(textState.font);
            var height = lineHeight * numLines;
            var renderWidth = width + strokeWidth;
            var contextInstructions = [];
            // make canvas 2 pixels wider to account for italic text width measurement errors
            var w = (renderWidth + 2) * scale[0];
            var h = (height + strokeWidth) * scale[1];
            /** @type {import("../canvas.js").Label} */
            var label = {
                width: w < 0 ? Math.floor(w) : Math.ceil(w),
                height: h < 0 ? Math.floor(h) : Math.ceil(h),
                contextInstructions: contextInstructions,
            };
            if (scale[0] != 1 || scale[1] != 1) {
                contextInstructions.push('scale', scale);
            }
            contextInstructions.push('font', textState.font);
            if (strokeKey) {
                contextInstructions.push('strokeStyle', strokeState.strokeStyle);
                contextInstructions.push('lineWidth', strokeWidth);
                contextInstructions.push('lineCap', strokeState.lineCap);
                contextInstructions.push('lineJoin', strokeState.lineJoin);
                contextInstructions.push('miterLimit', strokeState.miterLimit);
                // eslint-disable-next-line
                var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;
                if (Context.prototype.setLineDash) {
                    contextInstructions.push('setLineDash', [strokeState.lineDash]);
                    contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
                }
            }
            if (fillKey) {
                contextInstructions.push('fillStyle', fillState.fillStyle);
            }
            contextInstructions.push('textBaseline', 'middle');
            contextInstructions.push('textAlign', 'center');
            var leftRight = 0.5 - align;
            var x = align * renderWidth + leftRight * strokeWidth;
            var i;
            if (strokeKey) {
                for (i = 0; i < numLines; ++i) {
                    contextInstructions.push('strokeText', [
                        lines[i],
                        x + leftRight * widths[i],
                        0.5 * (strokeWidth + lineHeight) + i * lineHeight,
                    ]);
                }
            }
            if (fillKey) {
                for (i = 0; i < numLines; ++i) {
                    contextInstructions.push('fillText', [
                        lines[i],
                        x + leftRight * widths[i],
                        0.5 * (strokeWidth + lineHeight) + i * lineHeight,
                    ]);
                }
            }
            this.labels_[key] = label;
            return label;
        };
        /**
         * @param {CanvasRenderingContext2D} context Context.
         * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
         * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
         * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
         * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
         * @param {Array<*>} fillInstruction Fill instruction.
         * @param {Array<*>} strokeInstruction Stroke instruction.
         */
        Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
            context.beginPath();
            context.moveTo.apply(context, p1);
            context.lineTo.apply(context, p2);
            context.lineTo.apply(context, p3);
            context.lineTo.apply(context, p4);
            context.lineTo.apply(context, p1);
            if (fillInstruction) {
                this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);
                this.fill_(context);
            }
            if (strokeInstruction) {
                this.setStrokeStyle_(context, 
                /** @type {Array<*>} */ (strokeInstruction));
                context.stroke();
            }
        };
        /**
         * @private
         * @param {number} sheetWidth Width of the sprite sheet.
         * @param {number} sheetHeight Height of the sprite sheet.
         * @param {number} centerX X.
         * @param {number} centerY Y.
         * @param {number} width Width.
         * @param {number} height Height.
         * @param {number} anchorX Anchor X.
         * @param {number} anchorY Anchor Y.
         * @param {number} originX Origin X.
         * @param {number} originY Origin Y.
         * @param {number} rotation Rotation.
         * @param {import("../../size.js").Size} scale Scale.
         * @param {boolean} snapToPixel Snap to pixel.
         * @param {Array<number>} padding Padding.
         * @param {boolean} fillStroke Background fill or stroke.
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
         */
        Executor.prototype.calculateImageOrLabelDimensions_ = function (sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {
            anchorX *= scale[0];
            anchorY *= scale[1];
            var x = centerX - anchorX;
            var y = centerY - anchorY;
            var w = width + originX > sheetWidth ? sheetWidth - originX : width;
            var h = height + originY > sheetHeight ? sheetHeight - originY : height;
            var boxW = padding[3] + w * scale[0] + padding[1];
            var boxH = padding[0] + h * scale[1] + padding[2];
            var boxX = x - padding[3];
            var boxY = y - padding[0];
            if (fillStroke || rotation !== 0) {
                p1[0] = boxX;
                p4[0] = boxX;
                p1[1] = boxY;
                p2[1] = boxY;
                p2[0] = boxX + boxW;
                p3[0] = p2[0];
                p3[1] = boxY + boxH;
                p4[1] = p3[1];
            }
            var transform;
            if (rotation !== 0) {
                transform = compose(create(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                apply(transform, p1);
                apply(transform, p2);
                apply(transform, p3);
                apply(transform, p4);
                createOrUpdate$2(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
            }
            else {
                createOrUpdate$2(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
            }
            if (snapToPixel) {
                x = Math.round(x);
                y = Math.round(y);
            }
            return {
                drawImageX: x,
                drawImageY: y,
                drawImageW: w,
                drawImageH: h,
                originX: originX,
                originY: originY,
                declutterBox: {
                    minX: tmpExtent[0],
                    minY: tmpExtent[1],
                    maxX: tmpExtent[2],
                    maxY: tmpExtent[3],
                    value: feature,
                },
                canvasTransform: transform,
                scale: scale,
            };
        };
        /**
         * @private
         * @param {CanvasRenderingContext2D} context Context.
         * @param {number} contextScale Scale of the context.
         * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
         * @param {ImageOrLabelDimensions} dimensions Dimensions.
         * @param {number} opacity Opacity.
         * @param {Array<*>} fillInstruction Fill instruction.
         * @param {Array<*>} strokeInstruction Stroke instruction.
         * @return {boolean} The image or label was rendered.
         */
        Executor.prototype.replayImageOrLabel_ = function (context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {
            var fillStroke = !!(fillInstruction || strokeInstruction);
            var box = dimensions.declutterBox;
            var canvas = context.canvas;
            var strokePadding = strokeInstruction
                ? (strokeInstruction[2] * dimensions.scale[0]) / 2
                : 0;
            var intersects = box.minX - strokePadding <= canvas.width / contextScale &&
                box.maxX + strokePadding >= 0 &&
                box.minY - strokePadding <= canvas.height / contextScale &&
                box.maxY + strokePadding >= 0;
            if (intersects) {
                if (fillStroke) {
                    this.replayTextBackground_(context, p1, p2, p3, p4, 
                    /** @type {Array<*>} */ (fillInstruction), 
                    /** @type {Array<*>} */ (strokeInstruction));
                }
                drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
            }
            return true;
        };
        /**
         * @private
         * @param {CanvasRenderingContext2D} context Context.
         */
        Executor.prototype.fill_ = function (context) {
            if (this.alignFill_) {
                var origin_1 = apply(this.renderedTransform_, [0, 0]);
                var repeatSize = 512 * this.pixelRatio;
                context.save();
                context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
                context.rotate(this.viewRotation_);
            }
            context.fill();
            if (this.alignFill_) {
                context.restore();
            }
        };
        /**
         * @private
         * @param {CanvasRenderingContext2D} context Context.
         * @param {Array<*>} instruction Instruction.
         */
        Executor.prototype.setStrokeStyle_ = function (context, instruction) {
            context['strokeStyle'] = /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
            context.lineWidth = /** @type {number} */ (instruction[2]);
            context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);
            context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);
            context.miterLimit = /** @type {number} */ (instruction[5]);
            if (context.setLineDash) {
                context.lineDashOffset = /** @type {number} */ (instruction[7]);
                context.setLineDash(/** @type {Array<number>} */ (instruction[6]));
            }
        };
        /**
         * @private
         * @param {string} text The text to draw.
         * @param {string} textKey The key of the text state.
         * @param {string} strokeKey The key for the stroke state.
         * @param {string} fillKey The key for the fill state.
         * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
         */
        Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {
            var textState = this.textStates[textKey];
            var label = this.createLabel(text, textKey, fillKey, strokeKey);
            var strokeState = this.strokeStates[strokeKey];
            var pixelRatio = this.pixelRatio;
            var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);
            var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
            var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
            // Remove the 2 pixels we added in createLabel() for the anchor
            var width = label.width / pixelRatio - 2 * textState.scale[0];
            var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
            var anchorY = (baseline * label.height) / pixelRatio +
                2 * (0.5 - baseline) * strokeWidth;
            return {
                label: label,
                anchorX: anchorX,
                anchorY: anchorY,
            };
        };
        /**
         * @private
         * @param {CanvasRenderingContext2D} context Context.
         * @param {number} contextScale Scale of the context.
         * @param {import("../../transform.js").Transform} transform Transform.
         * @param {Array<*>} instructions Instructions array.
         * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
         * @param {FeatureCallback<T>=} opt_featureCallback Feature callback.
         * @param {import("../../extent.js").Extent=} opt_hitExtent Only check
         *     features that intersect this extent.
         * @param {import("rbush").default=} opt_declutterTree Declutter tree.
         * @return {T|undefined} Callback result.
         * @template T
         */
        Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {
            /** @type {Array<number>} */
            var pixelCoordinates;
            if (this.pixelCoordinates_ && equals$2(transform, this.renderedTransform_)) {
                pixelCoordinates = this.pixelCoordinates_;
            }
            else {
                if (!this.pixelCoordinates_) {
                    this.pixelCoordinates_ = [];
                }
                pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
                setFromArray(this.renderedTransform_, transform);
            }
            var i = 0; // instruction index
            var ii = instructions.length; // end of instructions
            var d = 0; // data index
            var dd; // end of per-instruction data
            var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
            var pendingFill = 0;
            var pendingStroke = 0;
            var lastFillInstruction = null;
            var lastStrokeInstruction = null;
            var coordinateCache = this.coordinateCache_;
            var viewRotation = this.viewRotation_;
            var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;
            var state = /** @type {import("../../render.js").State} */ ({
                context: context,
                pixelRatio: this.pixelRatio,
                resolution: this.resolution,
                rotation: viewRotation,
            });
            // When the batch size gets too big, performance decreases. 200 is a good
            // balance between batch size and number of fill/stroke instructions.
            var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
            var /** @type {import("../../Feature.js").FeatureLike} */ feature;
            var x, y, currentGeometry;
            while (i < ii) {
                var instruction = instructions[i];
                var type = /** @type {import("./Instruction.js").default} */ (instruction[0]);
                switch (type) {
                    case Instruction.BEGIN_GEOMETRY:
                        feature = /** @type {import("../../Feature.js").FeatureLike} */ (instruction[1]);
                        currentGeometry = instruction[3];
                        if (!feature.getGeometry()) {
                            i = /** @type {number} */ (instruction[2]);
                        }
                        else if (opt_hitExtent !== undefined &&
                            !intersects(opt_hitExtent, currentGeometry.getExtent())) {
                            i = /** @type {number} */ (instruction[2]) + 1;
                        }
                        else {
                            ++i;
                        }
                        break;
                    case Instruction.BEGIN_PATH:
                        if (pendingFill > batchSize) {
                            this.fill_(context);
                            pendingFill = 0;
                        }
                        if (pendingStroke > batchSize) {
                            context.stroke();
                            pendingStroke = 0;
                        }
                        if (!pendingFill && !pendingStroke) {
                            context.beginPath();
                            prevX = NaN;
                            prevY = NaN;
                        }
                        ++i;
                        break;
                    case Instruction.CIRCLE:
                        d = /** @type {number} */ (instruction[1]);
                        var x1 = pixelCoordinates[d];
                        var y1 = pixelCoordinates[d + 1];
                        var x2 = pixelCoordinates[d + 2];
                        var y2 = pixelCoordinates[d + 3];
                        var dx = x2 - x1;
                        var dy = y2 - y1;
                        var r = Math.sqrt(dx * dx + dy * dy);
                        context.moveTo(x1 + r, y1);
                        context.arc(x1, y1, r, 0, 2 * Math.PI, true);
                        ++i;
                        break;
                    case Instruction.CLOSE_PATH:
                        context.closePath();
                        ++i;
                        break;
                    case Instruction.CUSTOM:
                        d = /** @type {number} */ (instruction[1]);
                        dd = instruction[2];
                        var geometry = /** @type {import("../../geom/SimpleGeometry.js").default} */ (instruction[3]);
                        var renderer = instruction[4];
                        var fn = instruction.length == 6 ? instruction[5] : undefined;
                        state.geometry = geometry;
                        state.feature = feature;
                        if (!(i in coordinateCache)) {
                            coordinateCache[i] = [];
                        }
                        var coords = coordinateCache[i];
                        if (fn) {
                            fn(pixelCoordinates, d, dd, 2, coords);
                        }
                        else {
                            coords[0] = pixelCoordinates[d];
                            coords[1] = pixelCoordinates[d + 1];
                            coords.length = 2;
                        }
                        renderer(coords, state);
                        ++i;
                        break;
                    case Instruction.DRAW_IMAGE:
                        d = /** @type {number} */ (instruction[1]);
                        dd = /** @type {number} */ (instruction[2]);
                        image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (instruction[3]);
                        // Remaining arguments in DRAW_IMAGE are in alphabetical order
                        anchorX = /** @type {number} */ (instruction[4]);
                        anchorY = /** @type {number} */ (instruction[5]);
                        var height = /** @type {number} */ (instruction[6]);
                        var opacity = /** @type {number} */ (instruction[7]);
                        var originX = /** @type {number} */ (instruction[8]);
                        var originY = /** @type {number} */ (instruction[9]);
                        var rotateWithView = /** @type {boolean} */ (instruction[10]);
                        var rotation = /** @type {number} */ (instruction[11]);
                        var scale = /** @type {import("../../size.js").Size} */ (instruction[12]);
                        var width = /** @type {number} */ (instruction[13]);
                        var declutterImageWithText = /** @type {import("../canvas.js").DeclutterImageWithText} */ (instruction[14]);
                        if (!image && instruction.length >= 19) {
                            // create label images
                            text = /** @type {string} */ (instruction[18]);
                            textKey = /** @type {string} */ (instruction[19]);
                            strokeKey = /** @type {string} */ (instruction[20]);
                            fillKey = /** @type {string} */ (instruction[21]);
                            var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
                            image = labelWithAnchor.label;
                            instruction[3] = image;
                            var textOffsetX = /** @type {number} */ (instruction[22]);
                            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                            instruction[4] = anchorX;
                            var textOffsetY = /** @type {number} */ (instruction[23]);
                            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                            instruction[5] = anchorY;
                            height = image.height;
                            instruction[6] = height;
                            width = image.width;
                            instruction[13] = width;
                        }
                        var geometryWidths = void 0;
                        if (instruction.length > 24) {
                            geometryWidths = /** @type {number} */ (instruction[24]);
                        }
                        var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;
                        if (instruction.length > 16) {
                            padding = /** @type {Array<number>} */ (instruction[15]);
                            backgroundFill = /** @type {boolean} */ (instruction[16]);
                            backgroundStroke = /** @type {boolean} */ (instruction[17]);
                        }
                        else {
                            padding = defaultPadding;
                            backgroundFill = false;
                            backgroundStroke = false;
                        }
                        if (rotateWithView && viewRotationFromTransform) {
                            // Canvas is expected to be rotated to reverse view rotation.
                            rotation += viewRotation;
                        }
                        else if (!rotateWithView && !viewRotationFromTransform) {
                            // Canvas is not rotated, images need to be rotated back to be north-up.
                            rotation -= viewRotation;
                        }
                        var widthIndex = 0;
                        for (; d < dd; d += 2) {
                            if (geometryWidths &&
                                geometryWidths[widthIndex++] < width / this.pixelRatio) {
                                continue;
                            }
                            var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
                            /** @type {ReplayImageOrLabelArgs} */
                            var args = [
                                context,
                                contextScale,
                                image,
                                dimensions,
                                opacity,
                                backgroundFill
                                    ? /** @type {Array<*>} */ (lastFillInstruction)
                                    : null,
                                backgroundStroke
                                    ? /** @type {Array<*>} */ (lastStrokeInstruction)
                                    : null,
                            ];
                            var imageArgs = void 0;
                            var imageDeclutterBox = void 0;
                            if (opt_declutterTree && declutterImageWithText) {
                                if (!declutterImageWithText[d]) {
                                    // We now have the image for an image+text combination.
                                    declutterImageWithText[d] = args;
                                    // Don't render anything for now, wait for the text.
                                    continue;
                                }
                                imageArgs = declutterImageWithText[d];
                                delete declutterImageWithText[d];
                                imageDeclutterBox = getDeclutterBox(imageArgs);
                                if (opt_declutterTree.collides(imageDeclutterBox)) {
                                    continue;
                                }
                            }
                            if (opt_declutterTree &&
                                opt_declutterTree.collides(dimensions.declutterBox)) {
                                continue;
                            }
                            if (imageArgs) {
                                // We now have image and text for an image+text combination.
                                if (opt_declutterTree) {
                                    opt_declutterTree.insert(imageDeclutterBox);
                                }
                                // Render the image before we render the text.
                                this.replayImageOrLabel_.apply(this, imageArgs);
                            }
                            if (opt_declutterTree) {
                                opt_declutterTree.insert(dimensions.declutterBox);
                            }
                            this.replayImageOrLabel_.apply(this, args);
                        }
                        ++i;
                        break;
                    case Instruction.DRAW_CHARS:
                        var begin = /** @type {number} */ (instruction[1]);
                        var end = /** @type {number} */ (instruction[2]);
                        var baseline = /** @type {number} */ (instruction[3]);
                        var overflow = /** @type {number} */ (instruction[4]);
                        fillKey = /** @type {string} */ (instruction[5]);
                        var maxAngle = /** @type {number} */ (instruction[6]);
                        var measurePixelRatio = /** @type {number} */ (instruction[7]);
                        var offsetY = /** @type {number} */ (instruction[8]);
                        strokeKey = /** @type {string} */ (instruction[9]);
                        var strokeWidth = /** @type {number} */ (instruction[10]);
                        text = /** @type {string} */ (instruction[11]);
                        textKey = /** @type {string} */ (instruction[12]);
                        var pixelRatioScale = [
                            /** @type {number} */ (instruction[13]),
                            /** @type {number} */ (instruction[13]),
                        ];
                        var textState = this.textStates[textKey];
                        var font = textState.font;
                        var textScale = [
                            textState.scale[0] * measurePixelRatio,
                            textState.scale[1] * measurePixelRatio,
                        ];
                        var cachedWidths = void 0;
                        if (font in this.widths_) {
                            cachedWidths = this.widths_[font];
                        }
                        else {
                            cachedWidths = {};
                            this.widths_[font] = cachedWidths;
                        }
                        var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
                        var textLength = Math.abs(textScale[0]) *
                            measureAndCacheTextWidth(font, text, cachedWidths);
                        if (overflow || textLength <= pathLength) {
                            var textAlign = this.textStates[textKey].textAlign;
                            var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];
                            var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
                            drawChars: if (parts) {
                                /** @type {Array<ReplayImageOrLabelArgs>} */
                                var replayImageOrLabelArgs = [];
                                var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;
                                if (strokeKey) {
                                    for (c = 0, cc = parts.length; c < cc; ++c) {
                                        part = parts[c]; // x, y, anchorX, rotation, chunk
                                        chars = /** @type {string} */ (part[4]);
                                        label = this.createLabel(chars, textKey, '', strokeKey);
                                        anchorX =
                                            /** @type {number} */ (part[2]) +
                                                (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                                        anchorY =
                                            baseline * label.height +
                                                ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /
                                                    textScale[0] -
                                                offsetY;
                                        var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);
                                        if (opt_declutterTree &&
                                            opt_declutterTree.collides(dimensions.declutterBox)) {
                                            break drawChars;
                                        }
                                        replayImageOrLabelArgs.push([
                                            context,
                                            contextScale,
                                            label,
                                            dimensions,
                                            1,
                                            null,
                                            null,
                                        ]);
                                    }
                                }
                                if (fillKey) {
                                    for (c = 0, cc = parts.length; c < cc; ++c) {
                                        part = parts[c]; // x, y, anchorX, rotation, chunk
                                        chars = /** @type {string} */ (part[4]);
                                        label = this.createLabel(chars, textKey, fillKey, '');
                                        anchorX = /** @type {number} */ (part[2]);
                                        anchorY = baseline * label.height - offsetY;
                                        var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);
                                        if (opt_declutterTree &&
                                            opt_declutterTree.collides(dimensions.declutterBox)) {
                                            break drawChars;
                                        }
                                        replayImageOrLabelArgs.push([
                                            context,
                                            contextScale,
                                            label,
                                            dimensions,
                                            1,
                                            null,
                                            null,
                                        ]);
                                    }
                                }
                                if (opt_declutterTree) {
                                    opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                                }
                                for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {
                                    this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);
                                }
                            }
                        }
                        ++i;
                        break;
                    case Instruction.END_GEOMETRY:
                        if (opt_featureCallback !== undefined) {
                            feature = /** @type {import("../../Feature.js").FeatureLike} */ (instruction[1]);
                            var result = opt_featureCallback(feature, currentGeometry);
                            if (result) {
                                return result;
                            }
                        }
                        ++i;
                        break;
                    case Instruction.FILL:
                        if (batchSize) {
                            pendingFill++;
                        }
                        else {
                            this.fill_(context);
                        }
                        ++i;
                        break;
                    case Instruction.MOVE_TO_LINE_TO:
                        d = /** @type {number} */ (instruction[1]);
                        dd = /** @type {number} */ (instruction[2]);
                        x = pixelCoordinates[d];
                        y = pixelCoordinates[d + 1];
                        roundX = (x + 0.5) | 0;
                        roundY = (y + 0.5) | 0;
                        if (roundX !== prevX || roundY !== prevY) {
                            context.moveTo(x, y);
                            prevX = roundX;
                            prevY = roundY;
                        }
                        for (d += 2; d < dd; d += 2) {
                            x = pixelCoordinates[d];
                            y = pixelCoordinates[d + 1];
                            roundX = (x + 0.5) | 0;
                            roundY = (y + 0.5) | 0;
                            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                                context.lineTo(x, y);
                                prevX = roundX;
                                prevY = roundY;
                            }
                        }
                        ++i;
                        break;
                    case Instruction.SET_FILL_STYLE:
                        lastFillInstruction = instruction;
                        this.alignFill_ = instruction[2];
                        if (pendingFill) {
                            this.fill_(context);
                            pendingFill = 0;
                            if (pendingStroke) {
                                context.stroke();
                                pendingStroke = 0;
                            }
                        }
                        context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
                        ++i;
                        break;
                    case Instruction.SET_STROKE_STYLE:
                        lastStrokeInstruction = instruction;
                        if (pendingStroke) {
                            context.stroke();
                            pendingStroke = 0;
                        }
                        this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));
                        ++i;
                        break;
                    case Instruction.STROKE:
                        if (batchSize) {
                            pendingStroke++;
                        }
                        else {
                            context.stroke();
                        }
                        ++i;
                        break;
                    default:
                        ++i; // consume the instruction anyway, to avoid an infinite loop
                        break;
                }
            }
            if (pendingFill) {
                this.fill_(context);
            }
            if (pendingStroke) {
                context.stroke();
            }
            return undefined;
        };
        /**
         * @param {CanvasRenderingContext2D} context Context.
         * @param {number} contextScale Scale of the context.
         * @param {import("../../transform.js").Transform} transform Transform.
         * @param {number} viewRotation View rotation.
         * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
         * @param {import("rbush").default=} opt_declutterTree Declutter tree.
         */
        Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree) {
            this.viewRotation_ = viewRotation;
            this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, opt_declutterTree);
        };
        /**
         * @param {CanvasRenderingContext2D} context Context.
         * @param {import("../../transform.js").Transform} transform Transform.
         * @param {number} viewRotation View rotation.
         * @param {FeatureCallback<T>=} opt_featureCallback Feature callback.
         * @param {import("../../extent.js").Extent=} opt_hitExtent Only check
         *     features that intersect this extent.
         * @return {T|undefined} Callback result.
         * @template T
         */
        Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {
            this.viewRotation_ = viewRotation;
            return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
        };
        return Executor;
    }());

    /**
     * @module ol/render/canvas/ExecutorGroup
     */
    /**
     * @const
     * @type {Array<import("./BuilderType.js").default>}
     */
    var ORDER = [
        ReplayType.POLYGON,
        ReplayType.CIRCLE,
        ReplayType.LINE_STRING,
        ReplayType.IMAGE,
        ReplayType.TEXT,
        ReplayType.DEFAULT,
    ];
    var ExecutorGroup = /** @class */ (function () {
        /**
         * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
         * `maxExtent` was set on the Buillder for this executor group, the same `maxExtent`
         * should be set here, unless the target context does not exceet that extent (which
         * can be the case when rendering to tiles).
         * @param {number} resolution Resolution.
         * @param {number} pixelRatio Pixel ratio.
         * @param {boolean} overlaps The executor group can have overlapping geometries.
         * @param {!Object<string, !Object<import("./BuilderType.js").default, import("../canvas.js").SerializableInstructions>>} allInstructions
         * The serializable instructions.
         * @param {number=} opt_renderBuffer Optional rendering buffer.
         */
        function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
            /**
             * @private
             * @type {import("../../extent.js").Extent}
             */
            this.maxExtent_ = maxExtent;
            /**
             * @private
             * @type {boolean}
             */
            this.overlaps_ = overlaps;
            /**
             * @private
             * @type {number}
             */
            this.pixelRatio_ = pixelRatio;
            /**
             * @private
             * @type {number}
             */
            this.resolution_ = resolution;
            /**
             * @private
             * @type {number|undefined}
             */
            this.renderBuffer_ = opt_renderBuffer;
            /**
             * @private
             * @type {!Object<string, !Object<import("./BuilderType.js").default, import("./Executor").default>>}
             */
            this.executorsByZIndex_ = {};
            /**
             * @private
             * @type {CanvasRenderingContext2D}
             */
            this.hitDetectionContext_ = null;
            /**
             * @private
             * @type {import("../../transform.js").Transform}
             */
            this.hitDetectionTransform_ = create();
            this.createExecutors_(allInstructions);
        }
        /**
         * @param {CanvasRenderingContext2D} context Context.
         * @param {import("../../transform.js").Transform} transform Transform.
         */
        ExecutorGroup.prototype.clip = function (context, transform) {
            var flatClipCoords = this.getClipCoords(transform);
            context.beginPath();
            context.moveTo(flatClipCoords[0], flatClipCoords[1]);
            context.lineTo(flatClipCoords[2], flatClipCoords[3]);
            context.lineTo(flatClipCoords[4], flatClipCoords[5]);
            context.lineTo(flatClipCoords[6], flatClipCoords[7]);
            context.clip();
        };
        /**
         * Create executors and populate them using the provided instructions.
         * @private
         * @param {!Object<string, !Object<import("./BuilderType.js").default, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
         */
        ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {
            for (var zIndex in allInstructions) {
                var executors = this.executorsByZIndex_[zIndex];
                if (executors === undefined) {
                    executors = {};
                    this.executorsByZIndex_[zIndex] = executors;
                }
                var instructionByZindex = allInstructions[zIndex];
                var renderBuffer = [this.renderBuffer_ || 0, this.renderBuffer_ || 0];
                for (var builderType in instructionByZindex) {
                    var instructions = instructionByZindex[builderType];
                    executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions, renderBuffer);
                }
            }
        };
        /**
         * @param {Array<import("./BuilderType.js").default>} executors Executors.
         * @return {boolean} Has executors of the provided types.
         */
        ExecutorGroup.prototype.hasExecutors = function (executors) {
            for (var zIndex in this.executorsByZIndex_) {
                var candidates = this.executorsByZIndex_[zIndex];
                for (var i = 0, ii = executors.length; i < ii; ++i) {
                    if (executors[i] in candidates) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
         * @param {number} resolution Resolution.
         * @param {number} rotation Rotation.
         * @param {number} hitTolerance Hit tolerance in pixels.
         * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
         * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
         * @return {T|undefined} Callback result.
         * @template T
         */
        ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
            hitTolerance = Math.round(hitTolerance);
            var contextSize = hitTolerance * 2 + 1;
            var transform = compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
            var newContext = !this.hitDetectionContext_;
            if (newContext) {
                this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);
            }
            var context = this.hitDetectionContext_;
            if (context.canvas.width !== contextSize ||
                context.canvas.height !== contextSize) {
                context.canvas.width = contextSize;
                context.canvas.height = contextSize;
            }
            else if (!newContext) {
                context.clearRect(0, 0, contextSize, contextSize);
            }
            /**
             * @type {import("../../extent.js").Extent}
             */
            var hitExtent;
            if (this.renderBuffer_ !== undefined) {
                hitExtent = createEmpty();
                extendCoordinate(hitExtent, coordinate);
                buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
            }
            var indexes = getPixelIndexArray(hitTolerance);
            var builderType;
            /**
             * @param {import("../../Feature.js").FeatureLike} feature Feature.
             * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
             * @return {T|undefined} Callback result.
             */
            function featureCallback(feature, geometry) {
                var imageData = context.getImageData(0, 0, contextSize, contextSize)
                    .data;
                for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {
                    if (imageData[indexes[i_1]] > 0) {
                        if (!declutteredFeatures ||
                            (builderType !== ReplayType.IMAGE &&
                                builderType !== ReplayType.TEXT) ||
                            declutteredFeatures.indexOf(feature) !== -1) {
                            var idx = (indexes[i_1] - 3) / 4;
                            var x = hitTolerance - (idx % contextSize);
                            var y = hitTolerance - ((idx / contextSize) | 0);
                            var result_1 = callback(feature, geometry, x * x + y * y);
                            if (result_1) {
                                return result_1;
                            }
                        }
                        context.clearRect(0, 0, contextSize, contextSize);
                        break;
                    }
                }
                return undefined;
            }
            /** @type {Array<number>} */
            var zs = Object.keys(this.executorsByZIndex_).map(Number);
            zs.sort(numberSafeCompareFunction);
            var i, j, executors, executor, result;
            for (i = zs.length - 1; i >= 0; --i) {
                var zIndexKey = zs[i].toString();
                executors = this.executorsByZIndex_[zIndexKey];
                for (j = ORDER.length - 1; j >= 0; --j) {
                    builderType = ORDER[j];
                    executor = executors[builderType];
                    if (executor !== undefined) {
                        result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);
                        if (result) {
                            return result;
                        }
                    }
                }
            }
            return undefined;
        };
        /**
         * @param {import("../../transform.js").Transform} transform Transform.
         * @return {Array<number>} Clip coordinates.
         */
        ExecutorGroup.prototype.getClipCoords = function (transform) {
            var maxExtent = this.maxExtent_;
            if (!maxExtent) {
                return null;
            }
            var minX = maxExtent[0];
            var minY = maxExtent[1];
            var maxX = maxExtent[2];
            var maxY = maxExtent[3];
            var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
            transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
            return flatClipCoords;
        };
        /**
         * @return {boolean} Is empty.
         */
        ExecutorGroup.prototype.isEmpty = function () {
            return isEmpty$1(this.executorsByZIndex_);
        };
        /**
         * @param {CanvasRenderingContext2D} context Context.
         * @param {number} contextScale Scale of the context.
         * @param {import("../../transform.js").Transform} transform Transform.
         * @param {number} viewRotation View rotation.
         * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
         * @param {Array<import("./BuilderType.js").default>=} opt_builderTypes Ordered replay types to replay.
         *     Default is {@link module:ol/render/replay~ORDER}
         * @param {import("rbush").default=} opt_declutterTree Declutter tree.
         */
        ExecutorGroup.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {
            /** @type {Array<number>} */
            var zs = Object.keys(this.executorsByZIndex_).map(Number);
            zs.sort(numberSafeCompareFunction);
            // setup clipping so that the parts of over-simplified geometries are not
            // visible outside the current extent when panning
            if (this.maxExtent_) {
                context.save();
                this.clip(context, transform);
            }
            var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
            var i, ii, j, jj, replays, replay;
            if (opt_declutterTree) {
                zs.reverse();
            }
            for (i = 0, ii = zs.length; i < ii; ++i) {
                var zIndexKey = zs[i].toString();
                replays = this.executorsByZIndex_[zIndexKey];
                for (j = 0, jj = builderTypes.length; j < jj; ++j) {
                    var builderType = builderTypes[j];
                    replay = replays[builderType];
                    if (replay !== undefined) {
                        replay.execute(context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree);
                    }
                }
            }
            if (this.maxExtent_) {
                context.restore();
            }
        };
        return ExecutorGroup;
    }());
    /**
     * This cache is used to store arrays of indexes for calculated pixel circles
     * to increase performance.
     * It is a static property to allow each Replaygroup to access it.
     * @type {Object<number, Array<number>>}
     */
    var circlePixelIndexArrayCache = {};
    /**
     * This methods creates an array with indexes of all pixels within a circle,
     * ordered by how close they are to the center.
     * A cache is used to increase performance.
     * @param {number} radius Radius.
     * @returns {Array<number>} An array with indexes within a circle.
     */
    function getPixelIndexArray(radius) {
        if (circlePixelIndexArrayCache[radius] !== undefined) {
            return circlePixelIndexArrayCache[radius];
        }
        var size = radius * 2 + 1;
        var maxDistanceSq = radius * radius;
        var distances = new Array(maxDistanceSq + 1);
        for (var i = 0; i <= radius; ++i) {
            for (var j = 0; j <= radius; ++j) {
                var distanceSq = i * i + j * j;
                if (distanceSq > maxDistanceSq) {
                    break;
                }
                var distance = distances[distanceSq];
                if (!distance) {
                    distance = [];
                    distances[distanceSq] = distance;
                }
                distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
                if (i > 0) {
                    distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
                }
                if (j > 0) {
                    distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
                    if (i > 0) {
                        distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
                    }
                }
            }
        }
        var pixelIndex = [];
        for (var i = 0, ii = distances.length; i < ii; ++i) {
            if (distances[i]) {
                pixelIndex.push.apply(pixelIndex, distances[i]);
            }
        }
        circlePixelIndexArrayCache[radius] = pixelIndex;
        return pixelIndex;
    }

    /**
     * @module ol/ViewHint
     */
    /**
     * @enum {number}
     */
    var ViewHint = {
        ANIMATING: 0,
        INTERACTING: 1,
    };

    /**
     * @module ol/render/canvas/Immediate
     */
    // FIXME test, especially polygons with holes and multipolygons
    // FIXME need to handle large thick features (where pixel size matters)
    // FIXME add offset and end to ol/geom/flat/transform~transform2D?
    var __extends$K = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * A concrete subclass of {@link module:ol/render/VectorContext} that implements
     * direct rendering of features and geometries to an HTML5 Canvas context.
     * Instances of this class are created internally by the library and
     * provided to application code as vectorContext member of the
     * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
     * render events emitted by layers and maps.
     */
    var CanvasImmediateRenderer = /** @class */ (function (_super) {
        __extends$K(CanvasImmediateRenderer, _super);
        /**
         * @param {CanvasRenderingContext2D} context Context.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../../extent.js").Extent} extent Extent.
         * @param {import("../../transform.js").Transform} transform Transform.
         * @param {number} viewRotation View rotation.
         * @param {number=} opt_squaredTolerance Optional squared tolerance for simplification.
         * @param {import("../../proj.js").TransformFunction=} opt_userTransform Transform from user to view projection.
         */
        function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation, opt_squaredTolerance, opt_userTransform) {
            var _this = _super.call(this) || this;
            /**
             * @private
             * @type {CanvasRenderingContext2D}
             */
            _this.context_ = context;
            /**
             * @private
             * @type {number}
             */
            _this.pixelRatio_ = pixelRatio;
            /**
             * @private
             * @type {import("../../extent.js").Extent}
             */
            _this.extent_ = extent;
            /**
             * @private
             * @type {import("../../transform.js").Transform}
             */
            _this.transform_ = transform;
            /**
             * @private
             * @type {number}
             */
            _this.viewRotation_ = viewRotation;
            /**
             * @private
             * @type {number}
             */
            _this.squaredTolerance_ = opt_squaredTolerance;
            /**
             * @private
             * @type {import("../../proj.js").TransformFunction}
             */
            _this.userTransform_ = opt_userTransform;
            /**
             * @private
             * @type {?import("../canvas.js").FillState}
             */
            _this.contextFillState_ = null;
            /**
             * @private
             * @type {?import("../canvas.js").StrokeState}
             */
            _this.contextStrokeState_ = null;
            /**
             * @private
             * @type {?import("../canvas.js").TextState}
             */
            _this.contextTextState_ = null;
            /**
             * @private
             * @type {?import("../canvas.js").FillState}
             */
            _this.fillState_ = null;
            /**
             * @private
             * @type {?import("../canvas.js").StrokeState}
             */
            _this.strokeState_ = null;
            /**
             * @private
             * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
             */
            _this.image_ = null;
            /**
             * @private
             * @type {number}
             */
            _this.imageAnchorX_ = 0;
            /**
             * @private
             * @type {number}
             */
            _this.imageAnchorY_ = 0;
            /**
             * @private
             * @type {number}
             */
            _this.imageHeight_ = 0;
            /**
             * @private
             * @type {number}
             */
            _this.imageOpacity_ = 0;
            /**
             * @private
             * @type {number}
             */
            _this.imageOriginX_ = 0;
            /**
             * @private
             * @type {number}
             */
            _this.imageOriginY_ = 0;
            /**
             * @private
             * @type {boolean}
             */
            _this.imageRotateWithView_ = false;
            /**
             * @private
             * @type {number}
             */
            _this.imageRotation_ = 0;
            /**
             * @private
             * @type {import("../../size.js").Size}
             */
            _this.imageScale_ = [0, 0];
            /**
             * @private
             * @type {number}
             */
            _this.imageWidth_ = 0;
            /**
             * @private
             * @type {string}
             */
            _this.text_ = '';
            /**
             * @private
             * @type {number}
             */
            _this.textOffsetX_ = 0;
            /**
             * @private
             * @type {number}
             */
            _this.textOffsetY_ = 0;
            /**
             * @private
             * @type {boolean}
             */
            _this.textRotateWithView_ = false;
            /**
             * @private
             * @type {number}
             */
            _this.textRotation_ = 0;
            /**
             * @private
             * @type {import("../../size.js").Size}
             */
            _this.textScale_ = [0, 0];
            /**
             * @private
             * @type {?import("../canvas.js").FillState}
             */
            _this.textFillState_ = null;
            /**
             * @private
             * @type {?import("../canvas.js").StrokeState}
             */
            _this.textStrokeState_ = null;
            /**
             * @private
             * @type {?import("../canvas.js").TextState}
             */
            _this.textState_ = null;
            /**
             * @private
             * @type {Array<number>}
             */
            _this.pixelCoordinates_ = [];
            /**
             * @private
             * @type {import("../../transform.js").Transform}
             */
            _this.tmpLocalTransform_ = create();
            return _this;
        }
        /**
         * @param {Array<number>} flatCoordinates Flat coordinates.
         * @param {number} offset Offset.
         * @param {number} end End.
         * @param {number} stride Stride.
         * @private
         */
        CanvasImmediateRenderer.prototype.drawImages_ = function (flatCoordinates, offset, end, stride) {
            if (!this.image_) {
                return;
            }
            var pixelCoordinates = transform2D(flatCoordinates, offset, end, 2, this.transform_, this.pixelCoordinates_);
            var context = this.context_;
            var localTransform = this.tmpLocalTransform_;
            var alpha = context.globalAlpha;
            if (this.imageOpacity_ != 1) {
                context.globalAlpha = alpha * this.imageOpacity_;
            }
            var rotation = this.imageRotation_;
            if (this.imageRotateWithView_) {
                rotation += this.viewRotation_;
            }
            for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
                var x = pixelCoordinates[i] - this.imageAnchorX_;
                var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
                if (rotation !== 0 ||
                    this.imageScale_[0] != 1 ||
                    this.imageScale_[1] != 1) {
                    var centerX = x + this.imageAnchorX_;
                    var centerY = y + this.imageAnchorY_;
                    compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                    context.setTransform.apply(context, localTransform);
                    context.translate(centerX, centerY);
                    context.scale(this.imageScale_[0], this.imageScale_[1]);
                    context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
                    context.setTransform(1, 0, 0, 1, 0, 0);
                }
                else {
                    context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
                }
            }
            if (this.imageOpacity_ != 1) {
                context.globalAlpha = alpha;
            }
        };
        /**
         * @param {Array<number>} flatCoordinates Flat coordinates.
         * @param {number} offset Offset.
         * @param {number} end End.
         * @param {number} stride Stride.
         * @private
         */
        CanvasImmediateRenderer.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
            if (!this.textState_ || this.text_ === '') {
                return;
            }
            if (this.textFillState_) {
                this.setContextFillState_(this.textFillState_);
            }
            if (this.textStrokeState_) {
                this.setContextStrokeState_(this.textStrokeState_);
            }
            this.setContextTextState_(this.textState_);
            var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
            var context = this.context_;
            var rotation = this.textRotation_;
            if (this.textRotateWithView_) {
                rotation += this.viewRotation_;
            }
            for (; offset < end; offset += stride) {
                var x = pixelCoordinates[offset] + this.textOffsetX_;
                var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
                if (rotation !== 0 ||
                    this.textScale_[0] != 1 ||
                    this.textScale_[1] != 1) {
                    var localTransform = compose(this.tmpLocalTransform_, x, y, 1, 1, rotation, -x, -y);
                    context.setTransform.apply(context, localTransform);
                    context.translate(x, y);
                    context.scale(this.textScale_[0], this.textScale_[1]);
                    if (this.textStrokeState_) {
                        context.strokeText(this.text_, 0, 0);
                    }
                    if (this.textFillState_) {
                        context.fillText(this.text_, 0, 0);
                    }
                    context.setTransform(1, 0, 0, 1, 0, 0);
                }
                else {
                    if (this.textStrokeState_) {
                        context.strokeText(this.text_, x, y);
                    }
                    if (this.textFillState_) {
                        context.fillText(this.text_, x, y);
                    }
                }
            }
        };
        /**
         * @param {Array<number>} flatCoordinates Flat coordinates.
         * @param {number} offset Offset.
         * @param {number} end End.
         * @param {number} stride Stride.
         * @param {boolean} close Close.
         * @private
         * @return {number} end End.
         */
        CanvasImmediateRenderer.prototype.moveToLineTo_ = function (flatCoordinates, offset, end, stride, close) {
            var context = this.context_;
            var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
            context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
            var length = pixelCoordinates.length;
            if (close) {
                length -= 2;
            }
            for (var i = 2; i < length; i += 2) {
                context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
            }
            if (close) {
                context.closePath();
            }
            return end;
        };
        /**
         * @param {Array<number>} flatCoordinates Flat coordinates.
         * @param {number} offset Offset.
         * @param {Array<number>} ends Ends.
         * @param {number} stride Stride.
         * @private
         * @return {number} End.
         */
        CanvasImmediateRenderer.prototype.drawRings_ = function (flatCoordinates, offset, ends, stride) {
            for (var i = 0, ii = ends.length; i < ii; ++i) {
                offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
            }
            return offset;
        };
        /**
         * Render a circle geometry into the canvas.  Rendering is immediate and uses
         * the current fill and stroke styles.
         *
         * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
         * @api
         */
        CanvasImmediateRenderer.prototype.drawCircle = function (geometry) {
            if (!intersects(this.extent_, geometry.getExtent())) {
                return;
            }
            if (this.fillState_ || this.strokeState_) {
                if (this.fillState_) {
                    this.setContextFillState_(this.fillState_);
                }
                if (this.strokeState_) {
                    this.setContextStrokeState_(this.strokeState_);
                }
                var pixelCoordinates = transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);
                var dx = pixelCoordinates[2] - pixelCoordinates[0];
                var dy = pixelCoordinates[3] - pixelCoordinates[1];
                var radius = Math.sqrt(dx * dx + dy * dy);
                var context = this.context_;
                context.beginPath();
                context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
                if (this.fillState_) {
                    context.fill();
                }
                if (this.strokeState_) {
                    context.stroke();
                }
            }
            if (this.text_ !== '') {
                this.drawText_(geometry.getCenter(), 0, 2, 2);
            }
        };
        /**
         * Set the rendering style.  Note that since this is an immediate rendering API,
         * any `zIndex` on the provided style will be ignored.
         *
         * @param {import("../../style/Style.js").default} style The rendering style.
         * @api
         */
        CanvasImmediateRenderer.prototype.setStyle = function (style) {
            this.setFillStrokeStyle(style.getFill(), style.getStroke());
            this.setImageStyle(style.getImage());
            this.setTextStyle(style.getText());
        };
        /**
         * @param {import("../../transform.js").Transform} transform Transform.
         */
        CanvasImmediateRenderer.prototype.setTransform = function (transform) {
            this.transform_ = transform;
        };
        /**
         * Render a geometry into the canvas.  Call
         * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.
         *
         * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
         * @api
         */
        CanvasImmediateRenderer.prototype.drawGeometry = function (geometry) {
            var type = geometry.getType();
            switch (type) {
                case GeometryType.POINT:
                    this.drawPoint(
                    /** @type {import("../../geom/Point.js").default} */ (geometry));
                    break;
                case GeometryType.LINE_STRING:
                    this.drawLineString(
                    /** @type {import("../../geom/LineString.js").default} */ (geometry));
                    break;
                case GeometryType.POLYGON:
                    this.drawPolygon(
                    /** @type {import("../../geom/Polygon.js").default} */ (geometry));
                    break;
                case GeometryType.MULTI_POINT:
                    this.drawMultiPoint(
                    /** @type {import("../../geom/MultiPoint.js").default} */ (geometry));
                    break;
                case GeometryType.MULTI_LINE_STRING:
                    this.drawMultiLineString(
                    /** @type {import("../../geom/MultiLineString.js").default} */ (geometry));
                    break;
                case GeometryType.MULTI_POLYGON:
                    this.drawMultiPolygon(
                    /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry));
                    break;
                case GeometryType.GEOMETRY_COLLECTION:
                    this.drawGeometryCollection(
                    /** @type {import("../../geom/GeometryCollection.js").default} */ (geometry));
                    break;
                case GeometryType.CIRCLE:
                    this.drawCircle(
                    /** @type {import("../../geom/Circle.js").default} */ (geometry));
                    break;
            }
        };
        /**
         * Render a feature into the canvas.  Note that any `zIndex` on the provided
         * style will be ignored - features are rendered immediately in the order that
         * this method is called.  If you need `zIndex` support, you should be using an
         * {@link module:ol/layer/Vector~VectorLayer} instead.
         *
         * @param {import("../../Feature.js").default} feature Feature.
         * @param {import("../../style/Style.js").default} style Style.
         * @api
         */
        CanvasImmediateRenderer.prototype.drawFeature = function (feature, style) {
            var geometry = style.getGeometryFunction()(feature);
            if (!geometry || !intersects(this.extent_, geometry.getExtent())) {
                return;
            }
            this.setStyle(style);
            this.drawGeometry(geometry);
        };
        /**
         * Render a GeometryCollection to the canvas.  Rendering is immediate and
         * uses the current styles appropriate for each geometry in the collection.
         *
         * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
         */
        CanvasImmediateRenderer.prototype.drawGeometryCollection = function (geometry) {
            var geometries = geometry.getGeometriesArray();
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
                this.drawGeometry(geometries[i]);
            }
        };
        /**
         * Render a Point geometry into the canvas.  Rendering is immediate and uses
         * the current style.
         *
         * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
         */
        CanvasImmediateRenderer.prototype.drawPoint = function (geometry) {
            if (this.squaredTolerance_) {
                geometry = /** @type {import("../../geom/Point.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
            }
            var flatCoordinates = geometry.getFlatCoordinates();
            var stride = geometry.getStride();
            if (this.image_) {
                this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
            }
            if (this.text_ !== '') {
                this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
            }
        };
        /**
         * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
         * uses the current style.
         *
         * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
         */
        CanvasImmediateRenderer.prototype.drawMultiPoint = function (geometry) {
            if (this.squaredTolerance_) {
                geometry = /** @type {import("../../geom/MultiPoint.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
            }
            var flatCoordinates = geometry.getFlatCoordinates();
            var stride = geometry.getStride();
            if (this.image_) {
                this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
            }
            if (this.text_ !== '') {
                this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
            }
        };
        /**
         * Render a LineString into the canvas.  Rendering is immediate and uses
         * the current style.
         *
         * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
         */
        CanvasImmediateRenderer.prototype.drawLineString = function (geometry) {
            if (this.squaredTolerance_) {
                geometry = /** @type {import("../../geom/LineString.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
            }
            if (!intersects(this.extent_, geometry.getExtent())) {
                return;
            }
            if (this.strokeState_) {
                this.setContextStrokeState_(this.strokeState_);
                var context = this.context_;
                var flatCoordinates = geometry.getFlatCoordinates();
                context.beginPath();
                this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
                context.stroke();
            }
            if (this.text_ !== '') {
                var flatMidpoint = geometry.getFlatMidpoint();
                this.drawText_(flatMidpoint, 0, 2, 2);
            }
        };
        /**
         * Render a MultiLineString geometry into the canvas.  Rendering is immediate
         * and uses the current style.
         *
         * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
         */
        CanvasImmediateRenderer.prototype.drawMultiLineString = function (geometry) {
            if (this.squaredTolerance_) {
                geometry = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
            }
            var geometryExtent = geometry.getExtent();
            if (!intersects(this.extent_, geometryExtent)) {
                return;
            }
            if (this.strokeState_) {
                this.setContextStrokeState_(this.strokeState_);
                var context = this.context_;
                var flatCoordinates = geometry.getFlatCoordinates();
                var offset = 0;
                var ends = /** @type {Array<number>} */ (geometry.getEnds());
                var stride = geometry.getStride();
                context.beginPath();
                for (var i = 0, ii = ends.length; i < ii; ++i) {
                    offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
                }
                context.stroke();
            }
            if (this.text_ !== '') {
                var flatMidpoints = geometry.getFlatMidpoints();
                this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
            }
        };
        /**
         * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
         * the current style.
         *
         * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
         */
        CanvasImmediateRenderer.prototype.drawPolygon = function (geometry) {
            if (this.squaredTolerance_) {
                geometry = /** @type {import("../../geom/Polygon.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
            }
            if (!intersects(this.extent_, geometry.getExtent())) {
                return;
            }
            if (this.strokeState_ || this.fillState_) {
                if (this.fillState_) {
                    this.setContextFillState_(this.fillState_);
                }
                if (this.strokeState_) {
                    this.setContextStrokeState_(this.strokeState_);
                }
                var context = this.context_;
                context.beginPath();
                this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, 
                /** @type {Array<number>} */ (geometry.getEnds()), geometry.getStride());
                if (this.fillState_) {
                    context.fill();
                }
                if (this.strokeState_) {
                    context.stroke();
                }
            }
            if (this.text_ !== '') {
                var flatInteriorPoint = geometry.getFlatInteriorPoint();
                this.drawText_(flatInteriorPoint, 0, 2, 2);
            }
        };
        /**
         * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
         * uses the current style.
         * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
         */
        CanvasImmediateRenderer.prototype.drawMultiPolygon = function (geometry) {
            if (this.squaredTolerance_) {
                geometry = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
            }
            if (!intersects(this.extent_, geometry.getExtent())) {
                return;
            }
            if (this.strokeState_ || this.fillState_) {
                if (this.fillState_) {
                    this.setContextFillState_(this.fillState_);
                }
                if (this.strokeState_) {
                    this.setContextStrokeState_(this.strokeState_);
                }
                var context = this.context_;
                var flatCoordinates = geometry.getOrientedFlatCoordinates();
                var offset = 0;
                var endss = geometry.getEndss();
                var stride = geometry.getStride();
                context.beginPath();
                for (var i = 0, ii = endss.length; i < ii; ++i) {
                    var ends = endss[i];
                    offset = this.drawRings_(flatCoordinates, offset, ends, stride);
                }
                if (this.fillState_) {
                    context.fill();
                }
                if (this.strokeState_) {
                    context.stroke();
                }
            }
            if (this.text_ !== '') {
                var flatInteriorPoints = geometry.getFlatInteriorPoints();
                this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
            }
        };
        /**
         * @param {import("../canvas.js").FillState} fillState Fill state.
         * @private
         */
        CanvasImmediateRenderer.prototype.setContextFillState_ = function (fillState) {
            var context = this.context_;
            var contextFillState = this.contextFillState_;
            if (!contextFillState) {
                context.fillStyle = fillState.fillStyle;
                this.contextFillState_ = {
                    fillStyle: fillState.fillStyle,
                };
            }
            else {
                if (contextFillState.fillStyle != fillState.fillStyle) {
                    contextFillState.fillStyle = fillState.fillStyle;
                    context.fillStyle = fillState.fillStyle;
                }
            }
        };
        /**
         * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
         * @private
         */
        CanvasImmediateRenderer.prototype.setContextStrokeState_ = function (strokeState) {
            var context = this.context_;
            var contextStrokeState = this.contextStrokeState_;
            if (!contextStrokeState) {
                context.lineCap = strokeState.lineCap;
                if (context.setLineDash) {
                    context.setLineDash(strokeState.lineDash);
                    context.lineDashOffset = strokeState.lineDashOffset;
                }
                context.lineJoin = strokeState.lineJoin;
                context.lineWidth = strokeState.lineWidth;
                context.miterLimit = strokeState.miterLimit;
                context.strokeStyle = strokeState.strokeStyle;
                this.contextStrokeState_ = {
                    lineCap: strokeState.lineCap,
                    lineDash: strokeState.lineDash,
                    lineDashOffset: strokeState.lineDashOffset,
                    lineJoin: strokeState.lineJoin,
                    lineWidth: strokeState.lineWidth,
                    miterLimit: strokeState.miterLimit,
                    strokeStyle: strokeState.strokeStyle,
                };
            }
            else {
                if (contextStrokeState.lineCap != strokeState.lineCap) {
                    contextStrokeState.lineCap = strokeState.lineCap;
                    context.lineCap = strokeState.lineCap;
                }
                if (context.setLineDash) {
                    if (!equals$2(contextStrokeState.lineDash, strokeState.lineDash)) {
                        context.setLineDash((contextStrokeState.lineDash = strokeState.lineDash));
                    }
                    if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
                        contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
                        context.lineDashOffset = strokeState.lineDashOffset;
                    }
                }
                if (contextStrokeState.lineJoin != strokeState.lineJoin) {
                    contextStrokeState.lineJoin = strokeState.lineJoin;
                    context.lineJoin = strokeState.lineJoin;
                }
                if (contextStrokeState.lineWidth != strokeState.lineWidth) {
                    contextStrokeState.lineWidth = strokeState.lineWidth;
                    context.lineWidth = strokeState.lineWidth;
                }
                if (contextStrokeState.miterLimit != strokeState.miterLimit) {
                    contextStrokeState.miterLimit = strokeState.miterLimit;
                    context.miterLimit = strokeState.miterLimit;
                }
                if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
                    contextStrokeState.strokeStyle = strokeState.strokeStyle;
                    context.strokeStyle = strokeState.strokeStyle;
                }
            }
        };
        /**
         * @param {import("../canvas.js").TextState} textState Text state.
         * @private
         */
        CanvasImmediateRenderer.prototype.setContextTextState_ = function (textState) {
            var context = this.context_;
            var contextTextState = this.contextTextState_;
            var textAlign = textState.textAlign
                ? textState.textAlign
                : defaultTextAlign;
            if (!contextTextState) {
                context.font = textState.font;
                context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
                context.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
                this.contextTextState_ = {
                    font: textState.font,
                    textAlign: textAlign,
                    textBaseline: textState.textBaseline,
                };
            }
            else {
                if (contextTextState.font != textState.font) {
                    contextTextState.font = textState.font;
                    context.font = textState.font;
                }
                if (contextTextState.textAlign != textAlign) {
                    contextTextState.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
                    context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
                }
                if (contextTextState.textBaseline != textState.textBaseline) {
                    contextTextState.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
                    context.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
                }
            }
        };
        /**
         * Set the fill and stroke style for subsequent draw operations.  To clear
         * either fill or stroke styles, pass null for the appropriate parameter.
         *
         * @param {import("../../style/Fill.js").default} fillStyle Fill style.
         * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
         */
        CanvasImmediateRenderer.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
            if (!fillStyle) {
                this.fillState_ = null;
            }
            else {
                var fillStyleColor = fillStyle.getColor();
                this.fillState_ = {
                    fillStyle: asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle),
                };
            }
            if (!strokeStyle) {
                this.strokeState_ = null;
            }
            else {
                var strokeStyleColor = strokeStyle.getColor();
                var strokeStyleLineCap = strokeStyle.getLineCap();
                var strokeStyleLineDash = strokeStyle.getLineDash();
                var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
                var strokeStyleLineJoin = strokeStyle.getLineJoin();
                var strokeStyleWidth = strokeStyle.getWidth();
                var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
                this.strokeState_ = {
                    lineCap: strokeStyleLineCap !== undefined
                        ? strokeStyleLineCap
                        : defaultLineCap,
                    lineDash: strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash,
                    lineDashOffset: strokeStyleLineDashOffset
                        ? strokeStyleLineDashOffset
                        : defaultLineDashOffset,
                    lineJoin: strokeStyleLineJoin !== undefined
                        ? strokeStyleLineJoin
                        : defaultLineJoin,
                    lineWidth: this.pixelRatio_ *
                        (strokeStyleWidth !== undefined
                            ? strokeStyleWidth
                            : defaultLineWidth),
                    miterLimit: strokeStyleMiterLimit !== undefined
                        ? strokeStyleMiterLimit
                        : defaultMiterLimit,
                    strokeStyle: asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle),
                };
            }
        };
        /**
         * Set the image style for subsequent draw operations.  Pass null to remove
         * the image style.
         *
         * @param {import("../../style/Image.js").default} imageStyle Image style.
         */
        CanvasImmediateRenderer.prototype.setImageStyle = function (imageStyle) {
            if (!imageStyle) {
                this.image_ = null;
            }
            else {
                var imageSize = imageStyle.getSize();
                if (!imageSize) {
                    this.image_ = null;
                }
                else {
                    var imageAnchor = imageStyle.getAnchor();
                    // FIXME pixel ratio
                    var imageImage = imageStyle.getImage(1);
                    var imageOrigin = imageStyle.getOrigin();
                    var imageScale = imageStyle.getScaleArray();
                    this.imageAnchorX_ = imageAnchor[0];
                    this.imageAnchorY_ = imageAnchor[1];
                    this.imageHeight_ = imageSize[1];
                    this.image_ = imageImage;
                    this.imageOpacity_ = imageStyle.getOpacity();
                    this.imageOriginX_ = imageOrigin[0];
                    this.imageOriginY_ = imageOrigin[1];
                    this.imageRotateWithView_ = imageStyle.getRotateWithView();
                    this.imageRotation_ = imageStyle.getRotation();
                    this.imageScale_ = [
                        this.pixelRatio_ * imageScale[0],
                        this.pixelRatio_ * imageScale[1],
                    ];
                    this.imageWidth_ = imageSize[0];
                }
            }
        };
        /**
         * Set the text style for subsequent draw operations.  Pass null to
         * remove the text style.
         *
         * @param {import("../../style/Text.js").default} textStyle Text style.
         */
        CanvasImmediateRenderer.prototype.setTextStyle = function (textStyle) {
            if (!textStyle) {
                this.text_ = '';
            }
            else {
                var textFillStyle = textStyle.getFill();
                if (!textFillStyle) {
                    this.textFillState_ = null;
                }
                else {
                    var textFillStyleColor = textFillStyle.getColor();
                    this.textFillState_ = {
                        fillStyle: asColorLike(textFillStyleColor ? textFillStyleColor : defaultFillStyle),
                    };
                }
                var textStrokeStyle = textStyle.getStroke();
                if (!textStrokeStyle) {
                    this.textStrokeState_ = null;
                }
                else {
                    var textStrokeStyleColor = textStrokeStyle.getColor();
                    var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
                    var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
                    var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
                    var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
                    var textStrokeStyleWidth = textStrokeStyle.getWidth();
                    var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
                    this.textStrokeState_ = {
                        lineCap: textStrokeStyleLineCap !== undefined
                            ? textStrokeStyleLineCap
                            : defaultLineCap,
                        lineDash: textStrokeStyleLineDash
                            ? textStrokeStyleLineDash
                            : defaultLineDash,
                        lineDashOffset: textStrokeStyleLineDashOffset
                            ? textStrokeStyleLineDashOffset
                            : defaultLineDashOffset,
                        lineJoin: textStrokeStyleLineJoin !== undefined
                            ? textStrokeStyleLineJoin
                            : defaultLineJoin,
                        lineWidth: textStrokeStyleWidth !== undefined
                            ? textStrokeStyleWidth
                            : defaultLineWidth,
                        miterLimit: textStrokeStyleMiterLimit !== undefined
                            ? textStrokeStyleMiterLimit
                            : defaultMiterLimit,
                        strokeStyle: asColorLike(textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle),
                    };
                }
                var textFont = textStyle.getFont();
                var textOffsetX = textStyle.getOffsetX();
                var textOffsetY = textStyle.getOffsetY();
                var textRotateWithView = textStyle.getRotateWithView();
                var textRotation = textStyle.getRotation();
                var textScale = textStyle.getScaleArray();
                var textText = textStyle.getText();
                var textTextAlign = textStyle.getTextAlign();
                var textTextBaseline = textStyle.getTextBaseline();
                this.textState_ = {
                    font: textFont !== undefined ? textFont : defaultFont,
                    textAlign: textTextAlign !== undefined ? textTextAlign : defaultTextAlign,
                    textBaseline: textTextBaseline !== undefined
                        ? textTextBaseline
                        : defaultTextBaseline,
                };
                this.text_ = textText !== undefined ? textText : '';
                this.textOffsetX_ =
                    textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
                this.textOffsetY_ =
                    textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
                this.textRotateWithView_ =
                    textRotateWithView !== undefined ? textRotateWithView : false;
                this.textRotation_ = textRotation !== undefined ? textRotation : 0;
                this.textScale_ = [
                    this.pixelRatio_ * textScale[0],
                    this.pixelRatio_ * textScale[1],
                ];
            }
        };
        return CanvasImmediateRenderer;
    }(VectorContext));

    /**
     * @module ol/render/canvas/hitdetect
     */
    /**
     * @param {import("../../size.js").Size} size Canvas size in css pixels.
     * @param {Array<import("../../transform.js").Transform>} transforms Transforms
     * for rendering features to all worlds of the viewport, from coordinates to css
     * pixels.
     * @param {Array<import("../../Feature.js").FeatureLike>} features
     * Features to consider for hit detection.
     * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
     * Layer style function.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @return {ImageData} Hit detection image data.
     */
    function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
        var width = size[0] / 2;
        var height = size[1] / 2;
        var context = createCanvasContext2D(width, height);
        context.imageSmoothingEnabled = false;
        var canvas = context.canvas;
        var renderer = new CanvasImmediateRenderer(context, 0.5, extent, null, rotation);
        var featureCount = features.length;
        // Stretch hit detection index to use the whole available color range
        var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
        var featuresByZIndex = {};
        for (var i = 1; i <= featureCount; ++i) {
            var feature = features[i - 1];
            var featureStyleFunction = feature.getStyleFunction() || styleFunction;
            if (!styleFunction) {
                continue;
            }
            var styles = featureStyleFunction(feature, resolution);
            if (!styles) {
                continue;
            }
            if (!Array.isArray(styles)) {
                styles = [styles];
            }
            var index = i * indexFactor;
            var color = '#' + ('000000' + index.toString(16)).slice(-6);
            for (var j = 0, jj = styles.length; j < jj; ++j) {
                var originalStyle = styles[j];
                var style = originalStyle.clone();
                var fill = style.getFill();
                if (fill) {
                    fill.setColor(color);
                }
                var stroke = style.getStroke();
                if (stroke) {
                    stroke.setColor(color);
                }
                style.setText(undefined);
                var image = originalStyle.getImage();
                if (image) {
                    var imgSize = image.getImageSize();
                    if (!imgSize) {
                        continue;
                    }
                    var canvas_1 = document.createElement('canvas');
                    canvas_1.width = imgSize[0];
                    canvas_1.height = imgSize[1];
                    var imgContext = canvas_1.getContext('2d', { alpha: false });
                    imgContext.fillStyle = color;
                    var img = imgContext.canvas;
                    imgContext.fillRect(0, 0, img.width, img.height);
                    var width_1 = imgSize ? imgSize[0] : img.width;
                    var height_1 = imgSize ? imgSize[1] : img.height;
                    var iconContext = createCanvasContext2D(width_1, height_1);
                    iconContext.drawImage(img, 0, 0);
                    style.setImage(new Icon({
                        img: img,
                        imgSize: imgSize,
                        anchor: image.getAnchor(),
                        anchorXUnits: IconAnchorUnits.PIXELS,
                        anchorYUnits: IconAnchorUnits.PIXELS,
                        offset: image.getOrigin(),
                        size: image.getSize(),
                        opacity: image.getOpacity(),
                        scale: image.getScale(),
                        rotation: image.getRotation(),
                        rotateWithView: image.getRotateWithView(),
                    }));
                }
                var zIndex = Number(style.getZIndex());
                var byGeometryType = featuresByZIndex[zIndex];
                if (!byGeometryType) {
                    byGeometryType = {};
                    featuresByZIndex[zIndex] = byGeometryType;
                    byGeometryType[GeometryType.POLYGON] = [];
                    byGeometryType[GeometryType.CIRCLE] = [];
                    byGeometryType[GeometryType.LINE_STRING] = [];
                    byGeometryType[GeometryType.POINT] = [];
                }
                var geometry = style.getGeometryFunction()(feature);
                if (geometry && intersects(extent, geometry.getExtent())) {
                    byGeometryType[geometry.getType().replace('Multi', '')].push(geometry, style);
                }
            }
        }
        var zIndexKeys = Object.keys(featuresByZIndex)
            .map(Number)
            .sort(numberSafeCompareFunction);
        for (var i = 0, ii = zIndexKeys.length; i < ii; ++i) {
            var byGeometryType = featuresByZIndex[zIndexKeys[i]];
            for (var type in byGeometryType) {
                var geomAndStyle = byGeometryType[type];
                for (var j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
                    renderer.setStyle(geomAndStyle[j + 1]);
                    for (var k = 0, kk = transforms.length; k < kk; ++k) {
                        renderer.setTransform(transforms[k]);
                        renderer.drawGeometry(geomAndStyle[j]);
                    }
                }
            }
        }
        return context.getImageData(0, 0, canvas.width, canvas.height);
    }
    /**
     * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
     * detection canvas in css pixels.
     * @param {Array<import("../../Feature").FeatureLike>} features Features. Has to
     * match the `features` array that was passed to `createHitDetectionImageData()`.
     * @param {ImageData} imageData Hit detection image data generated by
     * `createHitDetectionImageData()`.
     * @return {Array<import("../../Feature").FeatureLike>} features Features.
     */
    function hitDetect(pixel, features, imageData) {
        var resultFeatures = [];
        if (imageData) {
            var index = (Math.round(pixel[0] / 2) + Math.round(pixel[1] / 2) * imageData.width) *
                4;
            var r = imageData.data[index];
            var g = imageData.data[index + 1];
            var b = imageData.data[index + 2];
            var i = b + 256 * (g + 256 * r);
            var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
            if (i && i % indexFactor === 0) {
                resultFeatures.push(features[i / indexFactor - 1]);
            }
        }
        return resultFeatures;
    }

    /**
     * @module ol/renderer/vector
     */
    /**
     * Feature callback. The callback will be called with three arguments. The first
     * argument is one {@link module:ol/Feature feature} or {@link module:ol/render/Feature render feature}
     * at the pixel, the second is the {@link module:ol/layer/Layer layer} of the feature and will be null for
     * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry} of the feature. For features
     * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
     * @template T
     * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default, import("../geom/SimpleGeometry.js").default): T} FeatureCallback
     */
    /**
     * Tolerance for geometry simplification in device pixels.
     * @type {number}
     */
    var SIMPLIFY_TOLERANCE = 0.5;
    /**
     * @const
     * @type {Object<import("../geom/GeometryType.js").default,
     *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
     *                         import("../style/Style.js").default, Object): void>}
     */
    var GEOMETRY_RENDERERS = {
        'Point': renderPointGeometry,
        'LineString': renderLineStringGeometry,
        'Polygon': renderPolygonGeometry,
        'MultiPoint': renderMultiPointGeometry,
        'MultiLineString': renderMultiLineStringGeometry,
        'MultiPolygon': renderMultiPolygonGeometry,
        'GeometryCollection': renderGeometryCollectionGeometry,
        'Circle': renderCircleGeometry,
    };
    /**
     * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
     * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
     * @return {number} Order.
     */
    function defaultOrder(feature1, feature2) {
        return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
    }
    /**
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Squared pixel tolerance.
     */
    function getSquaredTolerance(resolution, pixelRatio) {
        var tolerance = getTolerance(resolution, pixelRatio);
        return tolerance * tolerance;
    }
    /**
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel tolerance.
     */
    function getTolerance(resolution, pixelRatio) {
        return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;
    }
    /**
     * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
     * @param {import("../geom/Circle.js").default} geometry Geometry.
     * @param {import("../style/Style.js").default} style Style.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
     */
    function renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var fillStyle = style.getFill();
        var strokeStyle = style.getStroke();
        if (fillStyle || strokeStyle) {
            var circleReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.CIRCLE);
            circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
            circleReplay.drawCircle(geometry, feature);
        }
        var textStyle = style.getText();
        if (textStyle && textStyle.getText()) {
            var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), ReplayType.TEXT);
            textReplay.setTextStyle(textStyle);
            textReplay.drawText(geometry, feature);
        }
    }
    /**
     * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../style/Style.js").default} style Style.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     * @param {import("../proj.js").TransformFunction} [opt_transform] Transform from user to view projection.
     * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
     * @return {boolean} `true` if style is loading.
     */
    function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {
        var loading = false;
        var imageStyle = style.getImage();
        if (imageStyle) {
            var imageState = imageStyle.getImageState();
            if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {
                imageStyle.unlistenImageChange(listener);
            }
            else {
                if (imageState == ImageState.IDLE) {
                    imageStyle.load();
                }
                imageState = imageStyle.getImageState();
                imageStyle.listenImageChange(listener);
                loading = true;
            }
        }
        renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);
        return loading;
    }
    /**
     * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../style/Style.js").default} style Style.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
     * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
     */
    function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {
        var geometry = style.getGeometryFunction()(feature);
        if (!geometry) {
            return;
        }
        var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
        var renderer = style.getRenderer();
        if (renderer) {
            renderGeometry(replayGroup, simplifiedGeometry, style, feature);
        }
        else {
            var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
            geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);
        }
    }
    /**
     * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
     * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
     * @param {import("../style/Style.js").default} style Style.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    function renderGeometry(replayGroup, geometry, style, feature) {
        if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {
            var geometries = /** @type {import("../geom/GeometryCollection.js").default} */ (geometry).getGeometries();
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
                renderGeometry(replayGroup, geometries[i], style, feature);
            }
            return;
        }
        var replay = replayGroup.getBuilder(style.getZIndex(), ReplayType.DEFAULT);
        replay.drawCustom(
        /** @type {import("../geom/SimpleGeometry.js").default} */ (geometry), feature, style.getRenderer());
    }
    /**
     * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
     * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
     * @param {import("../style/Style.js").default} style Style.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
     */
    function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var geometries = geometry.getGeometriesArray();
        var i, ii;
        for (i = 0, ii = geometries.length; i < ii; ++i) {
            var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
            geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);
        }
    }
    /**
     * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
     * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
     * @param {import("../style/Style.js").default} style Style.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
     */
    function renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var strokeStyle = style.getStroke();
        if (strokeStyle) {
            var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.LINE_STRING);
            lineStringReplay.setFillStrokeStyle(null, strokeStyle);
            lineStringReplay.drawLineString(geometry, feature);
        }
        var textStyle = style.getText();
        if (textStyle && textStyle.getText()) {
            var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), ReplayType.TEXT);
            textReplay.setTextStyle(textStyle);
            textReplay.drawText(geometry, feature);
        }
    }
    /**
     * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
     * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
     * @param {import("../style/Style.js").default} style Style.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
     */
    function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var strokeStyle = style.getStroke();
        if (strokeStyle) {
            var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.LINE_STRING);
            lineStringReplay.setFillStrokeStyle(null, strokeStyle);
            lineStringReplay.drawMultiLineString(geometry, feature);
        }
        var textStyle = style.getText();
        if (textStyle && textStyle.getText()) {
            var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), ReplayType.TEXT);
            textReplay.setTextStyle(textStyle);
            textReplay.drawText(geometry, feature);
        }
    }
    /**
     * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
     * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
     * @param {import("../style/Style.js").default} style Style.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
     */
    function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var fillStyle = style.getFill();
        var strokeStyle = style.getStroke();
        if (strokeStyle || fillStyle) {
            var polygonReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.POLYGON);
            polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
            polygonReplay.drawMultiPolygon(geometry, feature);
        }
        var textStyle = style.getText();
        if (textStyle && textStyle.getText()) {
            var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), ReplayType.TEXT);
            textReplay.setTextStyle(textStyle);
            textReplay.drawText(geometry, feature);
        }
    }
    /**
     * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
     * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
     * @param {import("../style/Style.js").default} style Style.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
     */
    function renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var imageStyle = style.getImage();
        var textStyle = style.getText();
        /** @type {import("../render/canvas.js").DeclutterImageWithText} */
        var declutterImageWithText;
        if (opt_declutterBuilderGroup) {
            builderGroup = opt_declutterBuilderGroup;
            declutterImageWithText =
                imageStyle && textStyle && textStyle.getText() ? {} : undefined;
        }
        if (imageStyle) {
            if (imageStyle.getImageState() != ImageState.LOADED) {
                return;
            }
            var imageReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.IMAGE);
            imageReplay.setImageStyle(imageStyle, declutterImageWithText);
            imageReplay.drawPoint(geometry, feature);
        }
        if (textStyle && textStyle.getText()) {
            var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
            textReplay.setTextStyle(textStyle, declutterImageWithText);
            textReplay.drawText(geometry, feature);
        }
    }
    /**
     * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
     * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
     * @param {import("../style/Style.js").default} style Style.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
     */
    function renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var imageStyle = style.getImage();
        var textStyle = style.getText();
        /** @type {import("../render/canvas.js").DeclutterImageWithText} */
        var declutterImageWithText;
        if (opt_declutterBuilderGroup) {
            builderGroup = opt_declutterBuilderGroup;
            declutterImageWithText =
                imageStyle && textStyle && textStyle.getText() ? {} : undefined;
        }
        if (imageStyle) {
            if (imageStyle.getImageState() != ImageState.LOADED) {
                return;
            }
            var imageReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.IMAGE);
            imageReplay.setImageStyle(imageStyle, declutterImageWithText);
            imageReplay.drawMultiPoint(geometry, feature);
        }
        if (textStyle && textStyle.getText()) {
            var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), ReplayType.TEXT);
            textReplay.setTextStyle(textStyle, declutterImageWithText);
            textReplay.drawText(geometry, feature);
        }
    }
    /**
     * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
     * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
     * @param {import("../style/Style.js").default} style Style.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
     */
    function renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var fillStyle = style.getFill();
        var strokeStyle = style.getStroke();
        if (fillStyle || strokeStyle) {
            var polygonReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.POLYGON);
            polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
            polygonReplay.drawPolygon(geometry, feature);
        }
        var textStyle = style.getText();
        if (textStyle && textStyle.getText()) {
            var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), ReplayType.TEXT);
            textReplay.setTextStyle(textStyle);
            textReplay.drawText(geometry, feature);
        }
    }

    var __extends$J = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Canvas renderer for vector layers.
     * @api
     */
    var CanvasVectorLayerRenderer = /** @class */ (function (_super) {
        __extends$J(CanvasVectorLayerRenderer, _super);
        /**
         * @param {import("../../layer/Vector.js").default} vectorLayer Vector layer.
         */
        function CanvasVectorLayerRenderer(vectorLayer) {
            var _this = _super.call(this, vectorLayer) || this;
            /** @private */
            _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
            /**
             * @type {boolean}
             */
            _this.animatingOrInteracting_;
            /**
             * @private
             * @type {boolean}
             */
            _this.dirty_ = false;
            /**
             * @type {ImageData}
             */
            _this.hitDetectionImageData_ = null;
            /**
             * @type {Array<import("../../Feature.js").default>}
             */
            _this.renderedFeatures_ = null;
            /**
             * @private
             * @type {number}
             */
            _this.renderedRevision_ = -1;
            /**
             * @private
             * @type {number}
             */
            _this.renderedResolution_ = NaN;
            /**
             * @private
             * @type {import("../../extent.js").Extent}
             */
            _this.renderedExtent_ = createEmpty();
            /**
             * @private
             * @type {number}
             */
            _this.renderedRotation_;
            /**
             * @private
             * @type {import("../../coordinate").Coordinate}
             */
            _this.renderedCenter_ = null;
            /**
             * @private
             * @type {import("../../proj/Projection").default}
             */
            _this.renderedProjection_ = null;
            /**
             * @private
             * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
             */
            _this.renderedRenderOrder_ = null;
            /**
             * @private
             * @type {import("../../render/canvas/ExecutorGroup").default}
             */
            _this.replayGroup_ = null;
            /**
             * A new replay group had to be created by `prepareFrame()`
             * @type {boolean}
             */
            _this.replayGroupChanged = true;
            /**
             * @type {import("../../render/canvas/ExecutorGroup").default}
             */
            _this.declutterExecutorGroup = null;
            /**
             * Clipping to be performed by `renderFrame()`
             * @type {boolean}
             */
            _this.clipping = true;
            return _this;
        }
        /**
         * Get a rendering container from an existing target, if compatible.
         * @param {HTMLElement} target Potential render target.
         * @param {string} transform CSS Transform.
         * @param {number} opacity Opacity.
         */
        CanvasVectorLayerRenderer.prototype.useContainer = function (target, transform, opacity) {
            if (opacity < 1) {
                target = null;
            }
            _super.prototype.useContainer.call(this, target, transform, opacity);
        };
        /**
         * @param {ExecutorGroup} executorGroup Executor group.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @param {import("rbush").default=} opt_declutterTree Declutter tree.
         */
        CanvasVectorLayerRenderer.prototype.renderWorlds = function (executorGroup, frameState, opt_declutterTree) {
            var extent = frameState.extent;
            var viewState = frameState.viewState;
            var center = viewState.center;
            var resolution = viewState.resolution;
            var projection = viewState.projection;
            var rotation = viewState.rotation;
            var projectionExtent = projection.getExtent();
            var vectorSource = this.getLayer().getSource();
            var pixelRatio = frameState.pixelRatio;
            var viewHints = frameState.viewHints;
            var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
            var context = this.context;
            var width = Math.round(frameState.size[0] * pixelRatio);
            var height = Math.round(frameState.size[1] * pixelRatio);
            var multiWorld = vectorSource.getWrapX() && projection.canWrapX();
            var worldWidth = multiWorld ? getWidth(projectionExtent) : null;
            var endWorld = multiWorld
                ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1
                : 1;
            var world = multiWorld
                ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)
                : 0;
            do {
                var transform = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
                executorGroup.execute(context, 1, transform, rotation, snapToPixel, undefined, opt_declutterTree);
            } while (++world < endWorld);
        };
        /**
         * Render declutter items for this layer
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         */
        CanvasVectorLayerRenderer.prototype.renderDeclutter = function (frameState) {
            if (this.declutterExecutorGroup) {
                this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
            }
        };
        /**
         * Render the layer.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @param {HTMLElement} target Target that may be used to render content to.
         * @return {HTMLElement} The rendered element.
         */
        CanvasVectorLayerRenderer.prototype.renderFrame = function (frameState, target) {
            var pixelRatio = frameState.pixelRatio;
            var layerState = frameState.layerStatesArray[frameState.layerIndex];
            // set forward and inverse pixel transforms
            makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
            makeInverse(this.inversePixelTransform, this.pixelTransform);
            var canvasTransform = toString$2(this.pixelTransform);
            this.useContainer(target, canvasTransform, layerState.opacity);
            var context = this.context;
            var canvas = context.canvas;
            var replayGroup = this.replayGroup_;
            var declutterExecutorGroup = this.declutterExecutorGroup;
            if ((!replayGroup || replayGroup.isEmpty()) &&
                (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())) {
                if (!this.containerReused && canvas.width > 0) {
                    canvas.width = 0;
                }
                return this.container;
            }
            // resize and clear
            var width = Math.round(frameState.size[0] * pixelRatio);
            var height = Math.round(frameState.size[1] * pixelRatio);
            if (canvas.width != width || canvas.height != height) {
                canvas.width = width;
                canvas.height = height;
                if (canvas.style.transform !== canvasTransform) {
                    canvas.style.transform = canvasTransform;
                }
            }
            else if (!this.containerReused) {
                context.clearRect(0, 0, width, height);
            }
            this.preRender(context, frameState);
            var viewState = frameState.viewState;
            viewState.projection;
            // clipped rendering if layer extent is set
            var clipped = false;
            if (layerState.extent && this.clipping) {
                var layerExtent = fromUserExtent(layerState.extent);
                clipped =
                    !containsExtent(layerExtent, frameState.extent) &&
                        intersects(layerExtent, frameState.extent);
                if (clipped) {
                    this.clipUnrotated(context, frameState, layerExtent);
                }
            }
            this.renderWorlds(replayGroup, frameState);
            if (clipped) {
                context.restore();
            }
            this.postRender(context, frameState);
            var opacity = layerState.opacity;
            var container = this.container;
            if (opacity !== parseFloat(container.style.opacity)) {
                container.style.opacity = opacity === 1 ? '' : String(opacity);
            }
            if (this.renderedRotation_ !== viewState.rotation) {
                this.renderedRotation_ = viewState.rotation;
                this.hitDetectionImageData_ = null;
            }
            return this.container;
        };
        /**
         * Asynchronous layer level hit detection.
         * @param {import("../../pixel.js").Pixel} pixel Pixel.
         * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
         */
        CanvasVectorLayerRenderer.prototype.getFeatures = function (pixel) {
            return new Promise(
            /**
             * @param {function(Array<import("../../Feature").default|import("../../render/Feature").default>): void} resolve Resolver function.
             * @this {CanvasVectorLayerRenderer}
             */
            function (resolve) {
                if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                    var size = [this.context.canvas.width, this.context.canvas.height];
                    apply(this.pixelTransform, size);
                    var center = this.renderedCenter_;
                    var resolution = this.renderedResolution_;
                    var rotation = this.renderedRotation_;
                    var projection = this.renderedProjection_;
                    var extent = this.renderedExtent_;
                    var layer = this.getLayer();
                    var transforms = [];
                    var width = size[0] / 2;
                    var height = size[1] / 2;
                    transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, 0).slice());
                    var source = layer.getSource();
                    var projectionExtent = projection.getExtent();
                    if (source.getWrapX() &&
                        projection.canWrapX() &&
                        !containsExtent(projectionExtent, extent)) {
                        var startX = extent[0];
                        var worldWidth = getWidth(projectionExtent);
                        var world = 0;
                        var offsetX = void 0;
                        while (startX < projectionExtent[0]) {
                            --world;
                            offsetX = worldWidth * world;
                            transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, offsetX).slice());
                            startX += worldWidth;
                        }
                        world = 0;
                        startX = extent[2];
                        while (startX > projectionExtent[2]) {
                            ++world;
                            offsetX = worldWidth * world;
                            transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, offsetX).slice());
                            startX -= worldWidth;
                        }
                    }
                    this.hitDetectionImageData_ = createHitDetectionImageData(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
                }
                resolve(hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
            }.bind(this));
        };
        /**
         * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @param {number} hitTolerance Hit tolerance in pixels.
         * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
         * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
         * @return {T|undefined} Callback result.
         * @template T
         */
        CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {
            var _this = this;
            if (!this.replayGroup_) {
                return undefined;
            }
            var resolution = frameState.viewState.resolution;
            var rotation = frameState.viewState.rotation;
            var layer = this.getLayer();
            /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */
            var features = {};
            /**
             * @param {import("../../Feature.js").FeatureLike} feature Feature.
             * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
             * @param {number} distanceSq The squared distance to the click position
             * @return {T|undefined} Callback result.
             */
            var featureCallback = function (feature, geometry, distanceSq) {
                var key = getUid(feature);
                var match = features[key];
                if (!match) {
                    if (distanceSq === 0) {
                        features[key] = true;
                        return callback(feature, layer, geometry);
                    }
                    matches.push((features[key] = {
                        feature: feature,
                        layer: layer,
                        geometry: geometry,
                        distanceSq: distanceSq,
                        callback: callback,
                    }));
                }
                else if (match !== true && distanceSq < match.distanceSq) {
                    if (distanceSq === 0) {
                        features[key] = true;
                        matches.splice(matches.lastIndexOf(match), 1);
                        return callback(feature, layer, geometry);
                    }
                    match.geometry = geometry;
                    match.distanceSq = distanceSq;
                }
                return undefined;
            };
            var result;
            var executorGroups = [this.replayGroup_];
            if (this.declutterExecutorGroup) {
                executorGroups.push(this.declutterExecutorGroup);
            }
            executorGroups.some(function (executorGroup) {
                return (result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === _this.declutterExecutorGroup
                    ? frameState.declutterTree.all().map(function (item) { return item.value; })
                    : null));
            });
            return result;
        };
        /**
         * Perform action necessary to get the layer rendered after new fonts have loaded
         */
        CanvasVectorLayerRenderer.prototype.handleFontsChanged = function () {
            var layer = this.getLayer();
            if (layer.getVisible() && this.replayGroup_) {
                layer.changed();
            }
        };
        /**
         * Handle changes in image style state.
         * @param {import("../../events/Event.js").default} event Image style change event.
         * @private
         */
        CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function (event) {
            this.renderIfReadyAndVisible();
        };
        /**
         * Determine whether render should be called.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @return {boolean} Layer is ready to be rendered.
         */
        CanvasVectorLayerRenderer.prototype.prepareFrame = function (frameState) {
            var vectorLayer = this.getLayer();
            var vectorSource = vectorLayer.getSource();
            if (!vectorSource) {
                return false;
            }
            var animating = frameState.viewHints[ViewHint.ANIMATING];
            var interacting = frameState.viewHints[ViewHint.INTERACTING];
            var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
            var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
            if ((!this.dirty_ && !updateWhileAnimating && animating) ||
                (!updateWhileInteracting && interacting)) {
                this.animatingOrInteracting_ = true;
                return true;
            }
            this.animatingOrInteracting_ = false;
            var frameStateExtent = frameState.extent;
            var viewState = frameState.viewState;
            var projection = viewState.projection;
            var resolution = viewState.resolution;
            var pixelRatio = frameState.pixelRatio;
            var vectorLayerRevision = vectorLayer.getRevision();
            var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
            var vectorLayerRenderOrder = vectorLayer.getRenderOrder();
            if (vectorLayerRenderOrder === undefined) {
                vectorLayerRenderOrder = defaultOrder;
            }
            var center = viewState.center.slice();
            var extent = buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);
            var loadExtents = [extent.slice()];
            var projectionExtent = projection.getExtent();
            if (vectorSource.getWrapX() &&
                projection.canWrapX() &&
                !containsExtent(projectionExtent, frameState.extent)) {
                // For the replay group, we need an extent that intersects the real world
                // (-180° to +180°). To support geometries in a coordinate range from -540°
                // to +540°, we add at least 1 world width on each side of the projection
                // extent. If the viewport is wider than the world, we need to add half of
                // the viewport width to make sure we cover the whole viewport.
                var worldWidth = getWidth(projectionExtent);
                var gutter = Math.max(getWidth(extent) / 2, worldWidth);
                extent[0] = projectionExtent[0] - gutter;
                extent[2] = projectionExtent[2] + gutter;
                wrapX$1(center, projection);
                var loadExtent = wrapX$2(loadExtents[0], projection);
                // If the extent crosses the date line, we load data for both edges of the worlds
                if (loadExtent[0] < projectionExtent[0] &&
                    loadExtent[2] < projectionExtent[2]) {
                    loadExtents.push([
                        loadExtent[0] + worldWidth,
                        loadExtent[1],
                        loadExtent[2] + worldWidth,
                        loadExtent[3],
                    ]);
                }
                else if (loadExtent[0] > projectionExtent[0] &&
                    loadExtent[2] > projectionExtent[2]) {
                    loadExtents.push([
                        loadExtent[0] - worldWidth,
                        loadExtent[1],
                        loadExtent[2] - worldWidth,
                        loadExtent[3],
                    ]);
                }
            }
            if (!this.dirty_ &&
                this.renderedResolution_ == resolution &&
                this.renderedRevision_ == vectorLayerRevision &&
                this.renderedRenderOrder_ == vectorLayerRenderOrder &&
                containsExtent(this.renderedExtent_, extent)) {
                this.replayGroupChanged = false;
                return true;
            }
            this.replayGroup_ = null;
            this.dirty_ = false;
            var replayGroup = new BuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
            var declutterBuilderGroup;
            if (this.getLayer().getDeclutter()) {
                declutterBuilderGroup = new BuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
            }
            var userTransform;
            var i, ii; {
                for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
                    vectorSource.loadFeatures(loadExtents[i], resolution, projection);
                }
            }
            var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
            var render = 
            /**
             * @param {import("../../Feature.js").default} feature Feature.
             * @this {CanvasVectorLayerRenderer}
             */
            function (feature) {
                var styles;
                var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
                if (styleFunction) {
                    styles = styleFunction(feature, resolution);
                }
                if (styles) {
                    var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
                    this.dirty_ = this.dirty_ || dirty;
                }
            }.bind(this);
            var userExtent = toUserExtent(extent);
            /** @type {Array<import("../../Feature.js").default>} */
            var features = vectorSource.getFeaturesInExtent(userExtent);
            if (vectorLayerRenderOrder) {
                features.sort(vectorLayerRenderOrder);
            }
            for (var i = 0, ii = features.length; i < ii; ++i) {
                render(features[i]);
            }
            this.renderedFeatures_ = features;
            var replayGroupInstructions = replayGroup.finish();
            var executorGroup = new ExecutorGroup(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
            if (declutterBuilderGroup) {
                this.declutterExecutorGroup = new ExecutorGroup(extent, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
            }
            this.renderedResolution_ = resolution;
            this.renderedRevision_ = vectorLayerRevision;
            this.renderedRenderOrder_ = vectorLayerRenderOrder;
            this.renderedExtent_ = extent;
            this.renderedCenter_ = center;
            this.renderedProjection_ = projection;
            this.replayGroup_ = executorGroup;
            this.hitDetectionImageData_ = null;
            this.replayGroupChanged = true;
            return true;
        };
        /**
         * @param {import("../../Feature.js").default} feature Feature.
         * @param {number} squaredTolerance Squared render tolerance.
         * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
         * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
         * @param {import("../../proj.js").TransformFunction=} opt_transform Transform from user to view projection.
         * @param {import("../../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
         * @return {boolean} `true` if an image is loading.
         */
        CanvasVectorLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, builderGroup, opt_transform, opt_declutterBuilderGroup) {
            if (!styles) {
                return false;
            }
            var loading = false;
            if (Array.isArray(styles)) {
                for (var i = 0, ii = styles.length; i < ii; ++i) {
                    loading =
                        renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup) || loading;
                }
            }
            else {
                loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup);
            }
            return loading;
        };
        return CanvasVectorLayerRenderer;
    }(CanvasLayerRenderer));

    var __extends$I = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Vector data that is rendered client-side.
     * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
     * property on the layer object; for example, setting `title: 'My Title'` in the
     * options means that `title` is observable, and has get/set accessors.
     *
     * @extends {BaseVectorLayer<import("../source/Vector.js").default>}
     * @api
     */
    var VectorLayer = /** @class */ (function (_super) {
        __extends$I(VectorLayer, _super);
        /**
         * @param {import("./BaseVector.js").Options=} opt_options Options.
         */
        function VectorLayer(opt_options) {
            return _super.call(this, opt_options) || this;
        }
        /**
         * Create a renderer for this layer.
         * @return {import("../renderer/Layer.js").default} A layer renderer.
         */
        VectorLayer.prototype.createRenderer = function () {
            return new CanvasVectorLayerRenderer(this);
        };
        return VectorLayer;
    }(BaseVectorLayer));

    /**
     * @module ol/structs/RBush
     */
    /**
     * @typedef {Object} Entry
     * @property {number} minX
     * @property {number} minY
     * @property {number} maxX
     * @property {number} maxY
     * @property {Object} [value]
     */
    /**
     * @classdesc
     * Wrapper around the RBush by Vladimir Agafonkin.
     * See https://github.com/mourner/rbush.
     *
     * @template T
     */
    var RBush = /** @class */ (function () {
        /**
         * @param {number=} opt_maxEntries Max entries.
         */
        function RBush(opt_maxEntries) {
            /**
             * @private
             */
            this.rbush_ = new rbush_min(opt_maxEntries);
            /**
             * A mapping between the objects added to this rbush wrapper
             * and the objects that are actually added to the internal rbush.
             * @private
             * @type {Object<string, Entry>}
             */
            this.items_ = {};
        }
        /**
         * Insert a value into the RBush.
         * @param {import("../extent.js").Extent} extent Extent.
         * @param {T} value Value.
         */
        RBush.prototype.insert = function (extent, value) {
            /** @type {Entry} */
            var item = {
                minX: extent[0],
                minY: extent[1],
                maxX: extent[2],
                maxY: extent[3],
                value: value,
            };
            this.rbush_.insert(item);
            this.items_[getUid(value)] = item;
        };
        /**
         * Bulk-insert values into the RBush.
         * @param {Array<import("../extent.js").Extent>} extents Extents.
         * @param {Array<T>} values Values.
         */
        RBush.prototype.load = function (extents, values) {
            var items = new Array(values.length);
            for (var i = 0, l = values.length; i < l; i++) {
                var extent = extents[i];
                var value = values[i];
                /** @type {Entry} */
                var item = {
                    minX: extent[0],
                    minY: extent[1],
                    maxX: extent[2],
                    maxY: extent[3],
                    value: value,
                };
                items[i] = item;
                this.items_[getUid(value)] = item;
            }
            this.rbush_.load(items);
        };
        /**
         * Remove a value from the RBush.
         * @param {T} value Value.
         * @return {boolean} Removed.
         */
        RBush.prototype.remove = function (value) {
            var uid = getUid(value);
            // get the object in which the value was wrapped when adding to the
            // internal rbush. then use that object to do the removal.
            var item = this.items_[uid];
            delete this.items_[uid];
            return this.rbush_.remove(item) !== null;
        };
        /**
         * Update the extent of a value in the RBush.
         * @param {import("../extent.js").Extent} extent Extent.
         * @param {T} value Value.
         */
        RBush.prototype.update = function (extent, value) {
            var item = this.items_[getUid(value)];
            var bbox = [item.minX, item.minY, item.maxX, item.maxY];
            if (!equals$1(bbox, extent)) {
                this.remove(value);
                this.insert(extent, value);
            }
        };
        /**
         * Return all values in the RBush.
         * @return {Array<T>} All.
         */
        RBush.prototype.getAll = function () {
            var items = this.rbush_.all();
            return items.map(function (item) {
                return item.value;
            });
        };
        /**
         * Return all values in the given extent.
         * @param {import("../extent.js").Extent} extent Extent.
         * @return {Array<T>} All in extent.
         */
        RBush.prototype.getInExtent = function (extent) {
            /** @type {Entry} */
            var bbox = {
                minX: extent[0],
                minY: extent[1],
                maxX: extent[2],
                maxY: extent[3],
            };
            var items = this.rbush_.search(bbox);
            return items.map(function (item) {
                return item.value;
            });
        };
        /**
         * Calls a callback function with each value in the tree.
         * If the callback returns a truthy value, this value is returned without
         * checking the rest of the tree.
         * @param {function(T): *} callback Callback.
         * @return {*} Callback return value.
         */
        RBush.prototype.forEach = function (callback) {
            return this.forEach_(this.getAll(), callback);
        };
        /**
         * Calls a callback function with each value in the provided extent.
         * @param {import("../extent.js").Extent} extent Extent.
         * @param {function(T): *} callback Callback.
         * @return {*} Callback return value.
         */
        RBush.prototype.forEachInExtent = function (extent, callback) {
            return this.forEach_(this.getInExtent(extent), callback);
        };
        /**
         * @param {Array<T>} values Values.
         * @param {function(T): *} callback Callback.
         * @private
         * @return {*} Callback return value.
         */
        RBush.prototype.forEach_ = function (values, callback) {
            var result;
            for (var i = 0, l = values.length; i < l; i++) {
                result = callback(values[i]);
                if (result) {
                    return result;
                }
            }
            return result;
        };
        /**
         * @return {boolean} Is empty.
         */
        RBush.prototype.isEmpty = function () {
            return isEmpty$1(this.items_);
        };
        /**
         * Remove all values from the RBush.
         */
        RBush.prototype.clear = function () {
            this.rbush_.clear();
            this.items_ = {};
        };
        /**
         * @param {import("../extent.js").Extent=} opt_extent Extent.
         * @return {import("../extent.js").Extent} Extent.
         */
        RBush.prototype.getExtent = function (opt_extent) {
            var data = this.rbush_.toJSON();
            return createOrUpdate$2(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
        };
        /**
         * @param {RBush} rbush R-Tree.
         */
        RBush.prototype.concat = function (rbush) {
            this.rbush_.load(rbush.rbush_.all());
            for (var i in rbush.items_) {
                this.items_[i] = rbush.items_[i];
            }
        };
        return RBush;
    }());

    var __extends$H = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A function that returns a string or an array of strings representing source
     * attributions.
     *
     * @typedef {function(import("../PluggableMap.js").FrameState): (string|Array<string>)} Attribution
     */
    /**
     * A type that can be used to provide attribution information for data sources.
     *
     * It represents either
     * * a simple string (e.g. `'© Acme Inc.'`)
     * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
     * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
     *
     * @typedef {string|Array<string>|Attribution} AttributionLike
     */
    /**
     * @typedef {Object} Options
     * @property {AttributionLike} [attributions]
     * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
     * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
     * @property {import("./State.js").default} [state='ready']
     * @property {boolean} [wrapX=false]
     */
    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Base class for {@link module:ol/layer/Layer~Layer} sources.
     *
     * A generic `change` event is triggered when the state of the source changes.
     * @abstract
     * @api
     */
    var Source = /** @class */ (function (_super) {
        __extends$H(Source, _super);
        /**
         * @param {Options} options Source options.
         */
        function Source(options) {
            var _this = _super.call(this) || this;
            /**
             * @private
             * @type {import("../proj/Projection.js").default}
             */
            _this.projection_ = get$1(options.projection);
            /**
             * @private
             * @type {?Attribution}
             */
            _this.attributions_ = adaptAttributions(options.attributions);
            /**
             * @private
             * @type {boolean}
             */
            _this.attributionsCollapsible_ =
                options.attributionsCollapsible !== undefined
                    ? options.attributionsCollapsible
                    : true;
            /**
             * This source is currently loading data. Sources that defer loading to the
             * map's tile queue never set this to `true`.
             * @type {boolean}
             */
            _this.loading = false;
            /**
             * @private
             * @type {import("./State.js").default}
             */
            _this.state_ =
                options.state !== undefined ? options.state : SourceState.READY;
            /**
             * @private
             * @type {boolean}
             */
            _this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
            return _this;
        }
        /**
         * Get the attribution function for the source.
         * @return {?Attribution} Attribution function.
         */
        Source.prototype.getAttributions = function () {
            return this.attributions_;
        };
        /**
         * @return {boolean} Attributions are collapsible.
         */
        Source.prototype.getAttributionsCollapsible = function () {
            return this.attributionsCollapsible_;
        };
        /**
         * Get the projection of the source.
         * @return {import("../proj/Projection.js").default} Projection.
         * @api
         */
        Source.prototype.getProjection = function () {
            return this.projection_;
        };
        /**
         * @abstract
         * @return {Array<number>|undefined} Resolutions.
         */
        Source.prototype.getResolutions = function () {
            return abstract();
        };
        /**
         * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
         * @return {import("./State.js").default} State.
         * @api
         */
        Source.prototype.getState = function () {
            return this.state_;
        };
        /**
         * @return {boolean|undefined} Wrap X.
         */
        Source.prototype.getWrapX = function () {
            return this.wrapX_;
        };
        /**
         * @return {Object|undefined} Context options.
         */
        Source.prototype.getContextOptions = function () {
            return undefined;
        };
        /**
         * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
         * @api
         */
        Source.prototype.refresh = function () {
            this.changed();
        };
        /**
         * Set the attributions of the source.
         * @param {AttributionLike|undefined} attributions Attributions.
         *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
         *     or `undefined`.
         * @api
         */
        Source.prototype.setAttributions = function (attributions) {
            this.attributions_ = adaptAttributions(attributions);
            this.changed();
        };
        /**
         * Set the state of the source.
         * @param {import("./State.js").default} state State.
         */
        Source.prototype.setState = function (state) {
            this.state_ = state;
            this.changed();
        };
        return Source;
    }(BaseObject));
    /**
     * Turns the attributions option into an attributions function.
     * @param {AttributionLike|undefined} attributionLike The attribution option.
     * @return {?Attribution} An attribution function (or null).
     */
    function adaptAttributions(attributionLike) {
        if (!attributionLike) {
            return null;
        }
        if (Array.isArray(attributionLike)) {
            return function (frameState) {
                return attributionLike;
            };
        }
        if (typeof attributionLike === 'function') {
            return attributionLike;
        }
        return function (frameState) {
            return [attributionLike];
        };
    }

    /**
     * @module ol/source/VectorEventType
     */
    /**
     * @enum {string}
     */
    var VectorEventType = {
        /**
         * Triggered when a feature is added to the source.
         * @event module:ol/source/Vector.VectorSourceEvent#addfeature
         * @api
         */
        ADDFEATURE: 'addfeature',
        /**
         * Triggered when a feature is updated.
         * @event module:ol/source/Vector.VectorSourceEvent#changefeature
         * @api
         */
        CHANGEFEATURE: 'changefeature',
        /**
         * Triggered when the clear method is called on the source.
         * @event module:ol/source/Vector.VectorSourceEvent#clear
         * @api
         */
        CLEAR: 'clear',
        /**
         * Triggered when a feature is removed from the source.
         * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.
         * @event module:ol/source/Vector.VectorSourceEvent#removefeature
         * @api
         */
        REMOVEFEATURE: 'removefeature',
        /**
         * Triggered when features starts loading.
         * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
         * @api
         */
        FEATURESLOADSTART: 'featuresloadstart',
        /**
         * Triggered when features finishes loading.
         * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
         * @api
         */
        FEATURESLOADEND: 'featuresloadend',
        /**
         * Triggered if feature loading results in an error.
         * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
         * @api
         */
        FEATURESLOADERROR: 'featuresloaderror',
    };

    /**
     * @module ol/loadingstrategy
     */
    /**
     * Strategy function for loading all features with a single request.
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @return {Array<import("./extent.js").Extent>} Extents.
     * @api
     */
    function all$1(extent, resolution) {
        return [[-Infinity, -Infinity, Infinity, Infinity]];
    }

    /**
     * @module ol/featureloader
     */
    /**
     *
     * @type {boolean}
     * @private
     */
    var withCredentials = false;
    /**
     * {@link module:ol/source/Vector} sources use a function of this type to
     * load features.
     *
     * This function takes an {@link module:ol/extent~Extent} representing the area to be loaded,
     * a `{number}` representing the resolution (map units per pixel), an
     * {@link module:ol/proj/Projection} for the projection and success and failure callbacks as
     * arguments. `this` within the function is bound to the
     * {@link module:ol/source/Vector} it's called from.
     *
     * The function is responsible for loading the features and adding them to the
     * source.
     * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default),
     *           import("./extent.js").Extent,
     *           number,
     *           import("./proj/Projection.js").default,
     *           function(Array<import("./Feature.js").default>): void=,
     *           function(): void=): void} FeatureLoader
     * @api
     */
    /**
     * {@link module:ol/source/Vector} sources use a function of this type to
     * get the url to load features from.
     *
     * This function takes an {@link module:ol/extent~Extent} representing the area
     * to be loaded, a `{number}` representing the resolution (map units per pixel)
     * and an {@link module:ol/proj/Projection} for the projection  as
     * arguments and returns a `{string}` representing the URL.
     * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
     * @api
     */
    /**
     * @param {string|FeatureUrlFunction} url Feature URL service.
     * @param {import("./format/Feature.js").default} format Feature format.
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @param {function(Array<import("./Feature.js").default>, import("./proj/Projection.js").default): void} success Success
     *      Function called with the loaded features and optionally with the data projection.
     * @param {function(): void} failure Failure
     *      Function called when loading failed.
     */
    function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);
        if (format.getType() == FormatType.ARRAY_BUFFER) {
            xhr.responseType = 'arraybuffer';
        }
        xhr.withCredentials = withCredentials;
        /**
         * @param {Event} event Event.
         * @private
         */
        xhr.onload = function (event) {
            // status will be 0 for file:// urls
            if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {
                var type = format.getType();
                /** @type {Document|Node|Object|string|undefined} */
                var source = void 0;
                if (type == FormatType.JSON || type == FormatType.TEXT) {
                    source = xhr.responseText;
                }
                else if (type == FormatType.XML) {
                    source = xhr.responseXML;
                    if (!source) {
                        source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
                    }
                }
                else if (type == FormatType.ARRAY_BUFFER) {
                    source = /** @type {ArrayBuffer} */ (xhr.response);
                }
                if (source) {
                    success(
                    /** @type {Array<import("./Feature.js").default>} */
                    (format.readFeatures(source, {
                        extent: extent,
                        featureProjection: projection,
                    })), format.readProjection(source));
                }
                else {
                    failure();
                }
            }
            else {
                failure();
            }
        };
        /**
         * @private
         */
        xhr.onerror = failure;
        xhr.send();
    }
    /**
     * Create an XHR feature loader for a `url` and `format`. The feature loader
     * loads features (with XHR), parses the features, and adds them to the
     * vector source.
     * @param {string|FeatureUrlFunction} url Feature URL service.
     * @param {import("./format/Feature.js").default} format Feature format.
     * @return {FeatureLoader} The feature loader.
     * @api
     */
    function xhr$1(url, format) {
        /**
         * @param {import("./extent.js").Extent} extent Extent.
         * @param {number} resolution Resolution.
         * @param {import("./proj/Projection.js").default} projection Projection.
         * @param {function(): void=} success Success
         *      Function called when loading succeeded.
         * @param {function(): void=} failure Failure
         *      Function called when loading failed.
         * @this {import("./source/Vector").default}
         */
        return function (extent, resolution, projection, success, failure) {
            var source = /** @type {import("./source/Vector").default} */ (this);
            loadFeaturesXhr(url, format, extent, resolution, projection, 
            /**
             * @param {Array<import("./Feature.js").default>} features The loaded features.
             * @param {import("./proj/Projection.js").default} dataProjection Data
             * projection.
             */
            function (features, dataProjection) {
                if (success !== undefined) {
                    success(features);
                }
                source.addFeatures(features);
            }, 
            /* FIXME handle error */ failure ? failure : VOID);
        };
    }

    /**
     * @module ol/source/Vector
     */
    var __extends$G = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
     * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
     * is one of the standard {@link module:ol/loadingstrategy} strategies.
     *
     * @typedef {function(import("../extent.js").Extent, number): Array<import("../extent.js").Extent>} LoadingStrategy
     * @api
     */
    /**
     * @classdesc
     * Events emitted by {@link module:ol/source/Vector} instances are instances of this
     * type.
     * @template {import("../geom/Geometry.js").default} Geometry
     */
    var VectorSourceEvent = /** @class */ (function (_super) {
        __extends$G(VectorSourceEvent, _super);
        /**
         * @param {string} type Type.
         * @param {import("../Feature.js").default<Geometry>=} opt_feature Feature.
         * @param {Array<import("../Feature.js").default<Geometry>>=} opt_features Features.
         */
        function VectorSourceEvent(type, opt_feature, opt_features) {
            var _this = _super.call(this, type) || this;
            /**
             * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
             * @type {import("../Feature.js").default<Geometry>|undefined}
             * @api
             */
            _this.feature = opt_feature;
            /**
             * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
             * @type {Array<import("../Feature.js").default<Geometry>>|undefined}
             * @api
             */
            _this.features = opt_features;
            return _this;
        }
        return VectorSourceEvent;
    }(BaseEvent));
    /**
     * @typedef {Object} Options
     * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
     * @property {Array<import("../Feature.js").default>|Collection<import("../Feature.js").default>} [features]
     * Features. If provided as {@link module:ol/Collection}, the features in the source
     * and the collection will stay in sync.
     * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
     * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
     * @property {import("../featureloader.js").FeatureLoader} [loader]
     * The loader function used to load features, from a remote source for example.
     * If this is not set and `url` is set, the source will create and use an XHR
     * feature loader.
     *
     * Example:
     *
     * ```js
     * import {Vector} from 'ol/source';
     * import {GeoJSON} from 'ol/format';
     * import {bbox} from 'ol/loadingstrategy';
     *
     * var vectorSource = new Vector({
     *   format: new GeoJSON(),
     *   loader: function(extent, resolution, projection) {
     *      var proj = projection.getCode();
     *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
     *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
     *          'outputFormat=application/json&srsname=' + proj + '&' +
     *          'bbox=' + extent.join(',') + ',' + proj;
     *      var xhr = new XMLHttpRequest();
     *      xhr.open('GET', url);
     *      var onError = function() {
     *        vectorSource.removeLoadedExtent(extent);
     *      }
     *      xhr.onerror = onError;
     *      xhr.onload = function() {
     *        if (xhr.status == 200) {
     *          vectorSource.addFeatures(
     *              vectorSource.getFormat().readFeatures(xhr.responseText));
     *        } else {
     *          onError();
     *        }
     *      }
     *      xhr.send();
     *    },
     *    strategy: bbox
     *  });
     * ```
     * @property {boolean} [overlaps=true] This source may have overlapping geometries.
     * Setting this to `false` (e.g. for sources with polygons that represent administrative
     * boundaries or TopoJSON sources) allows the renderer to optimise fill and
     * stroke operations.
     * @property {LoadingStrategy} [strategy] The loading strategy to use.
     * By default an {@link module:ol/loadingstrategy~all}
     * strategy is used, a one-off strategy which loads all features at once.
     * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
     * Setting this option instructs the source to load features using an XHR loader
     * (see {@link module:ol/featureloader~xhr}). Use a `string` and an
     * {@link module:ol/loadingstrategy~all} for a one-off download of all features from
     * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
     * other loading strategies.
     * Requires `format` to be set as well.
     * When default XHR feature loader is provided, the features will
     * be transformed from the data projection to the view projection
     * during parsing. If your remote data source does not advertise its projection
     * properly, this transformation will be incorrect. For some formats, the
     * default projection (usually EPSG:4326) can be overridden by setting the
     * dataProjection constructor option on the format.
     * Note that if a source contains non-feature data, such as a GeoJSON geometry
     * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
     * @property {boolean} [useSpatialIndex=true]
     * By default, an RTree is used as spatial index. When features are removed and
     * added frequently, and the total number of features is low, setting this to
     * `false` may improve performance.
     *
     * Note that
     * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
     * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
     * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
     * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
     * through all features.
     *
     * When set to `false`, the features will be maintained in an
     * {@link module:ol/Collection}, which can be retrieved through
     * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
     * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
     * -180° and 180° meridians to work properly, this should be set to `false`. The
     * resulting geometry coordinates will then exceed the world bounds.
     */
    /**
     * @classdesc
     * Provides a source of features for vector layers. Vector features provided
     * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
     * vector data that is optimized for rendering.
     *
     * @fires VectorSourceEvent
     * @api
     * @template {import("../geom/Geometry.js").default} Geometry
     */
    var VectorSource = /** @class */ (function (_super) {
        __extends$G(VectorSource, _super);
        /**
         * @param {Options=} opt_options Vector source options.
         */
        function VectorSource(opt_options) {
            var _this = this;
            var options = opt_options || {};
            _this = _super.call(this, {
                attributions: options.attributions,
                projection: undefined,
                state: SourceState.READY,
                wrapX: options.wrapX !== undefined ? options.wrapX : true,
            }) || this;
            /**
             * @private
             * @type {import("../featureloader.js").FeatureLoader}
             */
            _this.loader_ = VOID;
            /**
             * @private
             * @type {import("../format/Feature.js").default|undefined}
             */
            _this.format_ = options.format;
            /**
             * @private
             * @type {boolean}
             */
            _this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;
            /**
             * @private
             * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
             */
            _this.url_ = options.url;
            if (options.loader !== undefined) {
                _this.loader_ = options.loader;
            }
            else if (_this.url_ !== undefined) {
                assert(_this.format_, 7); // `format` must be set when `url` is set
                // create a XHR feature loader for "url" and "format"
                _this.loader_ = xhr$1(_this.url_, 
                /** @type {import("../format/Feature.js").default} */ (_this.format_));
            }
            /**
             * @private
             * @type {LoadingStrategy}
             */
            _this.strategy_ =
                options.strategy !== undefined ? options.strategy : all$1;
            var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
            /**
             * @private
             * @type {RBush<import("../Feature.js").default<Geometry>>}
             */
            _this.featuresRtree_ = useSpatialIndex ? new RBush() : null;
            /**
             * @private
             * @type {RBush<{extent: import("../extent.js").Extent}>}
             */
            _this.loadedExtentsRtree_ = new RBush();
            /**
             * @private
             * @type {!Object<string, import("../Feature.js").default<Geometry>>}
             */
            _this.nullGeometryFeatures_ = {};
            /**
             * A lookup of features by id (the return from feature.getId()).
             * @private
             * @type {!Object<string, import("../Feature.js").default<Geometry>>}
             */
            _this.idIndex_ = {};
            /**
             * A lookup of features by uid (using getUid(feature)).
             * @private
             * @type {!Object<string, import("../Feature.js").default<Geometry>>}
             */
            _this.uidIndex_ = {};
            /**
             * @private
             * @type {Object<string, Array<import("../events.js").EventsKey>>}
             */
            _this.featureChangeKeys_ = {};
            /**
             * @private
             * @type {Collection<import("../Feature.js").default<Geometry>>}
             */
            _this.featuresCollection_ = null;
            var collection, features;
            if (Array.isArray(options.features)) {
                features = options.features;
            }
            else if (options.features) {
                collection = options.features;
                features = collection.getArray();
            }
            if (!useSpatialIndex && collection === undefined) {
                collection = new Collection(features);
            }
            if (features !== undefined) {
                _this.addFeaturesInternal(features);
            }
            if (collection !== undefined) {
                _this.bindFeaturesCollection_(collection);
            }
            return _this;
        }
        /**
         * Add a single feature to the source.  If you want to add a batch of features
         * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
         * instead. A feature will not be added to the source if feature with
         * the same id is already there. The reason for this behavior is to avoid
         * feature duplication when using bbox or tile loading strategies.
         * Note: this also applies if an {@link module:ol/Collection} is used for features,
         * meaning that if a feature with a duplicate id is added in the collection, it will
         * be removed from it right away.
         * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
         * @api
         */
        VectorSource.prototype.addFeature = function (feature) {
            this.addFeatureInternal(feature);
            this.changed();
        };
        /**
         * Add a feature without firing a `change` event.
         * @param {import("../Feature.js").default<Geometry>} feature Feature.
         * @protected
         */
        VectorSource.prototype.addFeatureInternal = function (feature) {
            var featureKey = getUid(feature);
            if (!this.addToIndex_(featureKey, feature)) {
                if (this.featuresCollection_) {
                    this.featuresCollection_.remove(feature);
                }
                return;
            }
            this.setupChangeEvents_(featureKey, feature);
            var geometry = feature.getGeometry();
            if (geometry) {
                var extent = geometry.getExtent();
                if (this.featuresRtree_) {
                    this.featuresRtree_.insert(extent, feature);
                }
            }
            else {
                this.nullGeometryFeatures_[featureKey] = feature;
            }
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));
        };
        /**
         * @param {string} featureKey Unique identifier for the feature.
         * @param {import("../Feature.js").default<Geometry>} feature The feature.
         * @private
         */
        VectorSource.prototype.setupChangeEvents_ = function (featureKey, feature) {
            this.featureChangeKeys_[featureKey] = [
                listen(feature, EventType.CHANGE, this.handleFeatureChange_, this),
                listen(feature, ObjectEventType.PROPERTYCHANGE, this.handleFeatureChange_, this),
            ];
        };
        /**
         * @param {string} featureKey Unique identifier for the feature.
         * @param {import("../Feature.js").default<Geometry>} feature The feature.
         * @return {boolean} The feature is "valid", in the sense that it is also a
         *     candidate for insertion into the Rtree.
         * @private
         */
        VectorSource.prototype.addToIndex_ = function (featureKey, feature) {
            var valid = true;
            var id = feature.getId();
            if (id !== undefined) {
                if (!(id.toString() in this.idIndex_)) {
                    this.idIndex_[id.toString()] = feature;
                }
                else {
                    valid = false;
                }
            }
            if (valid) {
                assert(!(featureKey in this.uidIndex_), 30); // The passed `feature` was already added to the source
                this.uidIndex_[featureKey] = feature;
            }
            return valid;
        };
        /**
         * Add a batch of features to the source.
         * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
         * @api
         */
        VectorSource.prototype.addFeatures = function (features) {
            this.addFeaturesInternal(features);
            this.changed();
        };
        /**
         * Add features without firing a `change` event.
         * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
         * @protected
         */
        VectorSource.prototype.addFeaturesInternal = function (features) {
            var extents = [];
            var newFeatures = [];
            var geometryFeatures = [];
            for (var i = 0, length_1 = features.length; i < length_1; i++) {
                var feature = features[i];
                var featureKey = getUid(feature);
                if (this.addToIndex_(featureKey, feature)) {
                    newFeatures.push(feature);
                }
            }
            for (var i = 0, length_2 = newFeatures.length; i < length_2; i++) {
                var feature = newFeatures[i];
                var featureKey = getUid(feature);
                this.setupChangeEvents_(featureKey, feature);
                var geometry = feature.getGeometry();
                if (geometry) {
                    var extent = geometry.getExtent();
                    extents.push(extent);
                    geometryFeatures.push(feature);
                }
                else {
                    this.nullGeometryFeatures_[featureKey] = feature;
                }
            }
            if (this.featuresRtree_) {
                this.featuresRtree_.load(extents, geometryFeatures);
            }
            for (var i = 0, length_3 = newFeatures.length; i < length_3; i++) {
                this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i]));
            }
        };
        /**
         * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
         * @private
         */
        VectorSource.prototype.bindFeaturesCollection_ = function (collection) {
            var modifyingCollection = false;
            this.addEventListener(VectorEventType.ADDFEATURE, 
            /**
             * @param {VectorSourceEvent<Geometry>} evt The vector source event
             */
            function (evt) {
                if (!modifyingCollection) {
                    modifyingCollection = true;
                    collection.push(evt.feature);
                    modifyingCollection = false;
                }
            });
            this.addEventListener(VectorEventType.REMOVEFEATURE, 
            /**
             * @param {VectorSourceEvent<Geometry>} evt The vector source event
             */
            function (evt) {
                if (!modifyingCollection) {
                    modifyingCollection = true;
                    collection.remove(evt.feature);
                    modifyingCollection = false;
                }
            });
            collection.addEventListener(CollectionEventType.ADD, 
            /**
             * @param {import("../Collection.js").CollectionEvent} evt The collection event
             */
            function (evt) {
                if (!modifyingCollection) {
                    modifyingCollection = true;
                    this.addFeature(
                    /** @type {import("../Feature.js").default<Geometry>} */ (evt.element));
                    modifyingCollection = false;
                }
            }.bind(this));
            collection.addEventListener(CollectionEventType.REMOVE, 
            /**
             * @param {import("../Collection.js").CollectionEvent} evt The collection event
             */
            function (evt) {
                if (!modifyingCollection) {
                    modifyingCollection = true;
                    this.removeFeature(
                    /** @type {import("../Feature.js").default<Geometry>} */ (evt.element));
                    modifyingCollection = false;
                }
            }.bind(this));
            this.featuresCollection_ = collection;
        };
        /**
         * Remove all features from the source.
         * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.
         * @api
         */
        VectorSource.prototype.clear = function (opt_fast) {
            if (opt_fast) {
                for (var featureId in this.featureChangeKeys_) {
                    var keys = this.featureChangeKeys_[featureId];
                    keys.forEach(unlistenByKey);
                }
                if (!this.featuresCollection_) {
                    this.featureChangeKeys_ = {};
                    this.idIndex_ = {};
                    this.uidIndex_ = {};
                }
            }
            else {
                if (this.featuresRtree_) {
                    this.featuresRtree_.forEach(this.removeFeatureInternal.bind(this));
                    for (var id in this.nullGeometryFeatures_) {
                        this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
                    }
                }
            }
            if (this.featuresCollection_) {
                this.featuresCollection_.clear();
            }
            if (this.featuresRtree_) {
                this.featuresRtree_.clear();
            }
            this.nullGeometryFeatures_ = {};
            var clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);
            this.dispatchEvent(clearEvent);
            this.changed();
        };
        /**
         * Iterate through all features on the source, calling the provided callback
         * with each one.  If the callback returns any "truthy" value, iteration will
         * stop and the function will return the same value.
         * Note: this function only iterate through the feature that have a defined geometry.
         *
         * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
         *     on the source.  Return a truthy value to stop iteration.
         * @return {T|undefined} The return value from the last call to the callback.
         * @template T
         * @api
         */
        VectorSource.prototype.forEachFeature = function (callback) {
            if (this.featuresRtree_) {
                return this.featuresRtree_.forEach(callback);
            }
            else if (this.featuresCollection_) {
                this.featuresCollection_.forEach(callback);
            }
        };
        /**
         * Iterate through all features whose geometries contain the provided
         * coordinate, calling the callback with each feature.  If the callback returns
         * a "truthy" value, iteration will stop and the function will return the same
         * value.
         *
         * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
         * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
         *     whose goemetry contains the provided coordinate.
         * @return {T|undefined} The return value from the last call to the callback.
         * @template T
         */
        VectorSource.prototype.forEachFeatureAtCoordinateDirect = function (coordinate, callback) {
            var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
            return this.forEachFeatureInExtent(extent, function (feature) {
                var geometry = feature.getGeometry();
                if (geometry.intersectsCoordinate(coordinate)) {
                    return callback(feature);
                }
                else {
                    return undefined;
                }
            });
        };
        /**
         * Iterate through all features whose bounding box intersects the provided
         * extent (note that the feature's geometry may not intersect the extent),
         * calling the callback with each feature.  If the callback returns a "truthy"
         * value, iteration will stop and the function will return the same value.
         *
         * If you are interested in features whose geometry intersects an extent, call
         * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
         *
         * When `useSpatialIndex` is set to false, this method will loop through all
         * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
         *
         * @param {import("../extent.js").Extent} extent Extent.
         * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
         *     whose bounding box intersects the provided extent.
         * @return {T|undefined} The return value from the last call to the callback.
         * @template T
         * @api
         */
        VectorSource.prototype.forEachFeatureInExtent = function (extent, callback) {
            if (this.featuresRtree_) {
                return this.featuresRtree_.forEachInExtent(extent, callback);
            }
            else if (this.featuresCollection_) {
                this.featuresCollection_.forEach(callback);
            }
        };
        /**
         * Iterate through all features whose geometry intersects the provided extent,
         * calling the callback with each feature.  If the callback returns a "truthy"
         * value, iteration will stop and the function will return the same value.
         *
         * If you only want to test for bounding box intersection, call the
         * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
         *
         * @param {import("../extent.js").Extent} extent Extent.
         * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
         *     whose geometry intersects the provided extent.
         * @return {T|undefined} The return value from the last call to the callback.
         * @template T
         * @api
         */
        VectorSource.prototype.forEachFeatureIntersectingExtent = function (extent, callback) {
            return this.forEachFeatureInExtent(extent, 
            /**
             * @param {import("../Feature.js").default<Geometry>} feature Feature.
             * @return {T|undefined} The return value from the last call to the callback.
             */
            function (feature) {
                var geometry = feature.getGeometry();
                if (geometry.intersectsExtent(extent)) {
                    var result = callback(feature);
                    if (result) {
                        return result;
                    }
                }
            });
        };
        /**
         * Get the features collection associated with this source. Will be `null`
         * unless the source was configured with `useSpatialIndex` set to `false`, or
         * with an {@link module:ol/Collection} as `features`.
         * @return {Collection<import("../Feature.js").default<Geometry>>} The collection of features.
         * @api
         */
        VectorSource.prototype.getFeaturesCollection = function () {
            return this.featuresCollection_;
        };
        /**
         * Get all features on the source in random order.
         * @return {Array<import("../Feature.js").default<Geometry>>} Features.
         * @api
         */
        VectorSource.prototype.getFeatures = function () {
            var features;
            if (this.featuresCollection_) {
                features = this.featuresCollection_.getArray();
            }
            else if (this.featuresRtree_) {
                features = this.featuresRtree_.getAll();
                if (!isEmpty$1(this.nullGeometryFeatures_)) {
                    extend$2(features, getValues(this.nullGeometryFeatures_));
                }
            }
            return /** @type {Array<import("../Feature.js").default<Geometry>>} */ (features);
        };
        /**
         * Get all features whose geometry intersects the provided coordinate.
         * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
         * @return {Array<import("../Feature.js").default<Geometry>>} Features.
         * @api
         */
        VectorSource.prototype.getFeaturesAtCoordinate = function (coordinate) {
            var features = [];
            this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
                features.push(feature);
            });
            return features;
        };
        /**
         * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
         * all features intersecting the given extent in random order (so it may include
         * features whose geometries do not intersect the extent).
         *
         * When `useSpatialIndex` is set to false, this method will return all
         * features.
         *
         * @param {import("../extent.js").Extent} extent Extent.
         * @return {Array<import("../Feature.js").default<Geometry>>} Features.
         * @api
         */
        VectorSource.prototype.getFeaturesInExtent = function (extent) {
            if (this.featuresRtree_) {
                return this.featuresRtree_.getInExtent(extent);
            }
            else if (this.featuresCollection_) {
                return this.featuresCollection_.getArray();
            }
            else {
                return [];
            }
        };
        /**
         * Get the closest feature to the provided coordinate.
         *
         * This method is not available when the source is configured with
         * `useSpatialIndex` set to `false`.
         * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
         * @param {function(import("../Feature.js").default<Geometry>):boolean=} opt_filter Feature filter function.
         *     The filter function will receive one argument, the {@link module:ol/Feature feature}
         *     and it should return a boolean value. By default, no filtering is made.
         * @return {import("../Feature.js").default<Geometry>} Closest feature.
         * @api
         */
        VectorSource.prototype.getClosestFeatureToCoordinate = function (coordinate, opt_filter) {
            // Find the closest feature using branch and bound.  We start searching an
            // infinite extent, and find the distance from the first feature found.  This
            // becomes the closest feature.  We then compute a smaller extent which any
            // closer feature must intersect.  We continue searching with this smaller
            // extent, trying to find a closer feature.  Every time we find a closer
            // feature, we update the extent being searched so that any even closer
            // feature must intersect it.  We continue until we run out of features.
            var x = coordinate[0];
            var y = coordinate[1];
            var closestFeature = null;
            var closestPoint = [NaN, NaN];
            var minSquaredDistance = Infinity;
            var extent = [-Infinity, -Infinity, Infinity, Infinity];
            var filter = opt_filter ? opt_filter : TRUE;
            this.featuresRtree_.forEachInExtent(extent, 
            /**
             * @param {import("../Feature.js").default<Geometry>} feature Feature.
             */
            function (feature) {
                if (filter(feature)) {
                    var geometry = feature.getGeometry();
                    var previousMinSquaredDistance = minSquaredDistance;
                    minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
                    if (minSquaredDistance < previousMinSquaredDistance) {
                        closestFeature = feature;
                        // This is sneaky.  Reduce the extent that it is currently being
                        // searched while the R-Tree traversal using this same extent object
                        // is still in progress.  This is safe because the new extent is
                        // strictly contained by the old extent.
                        var minDistance = Math.sqrt(minSquaredDistance);
                        extent[0] = x - minDistance;
                        extent[1] = y - minDistance;
                        extent[2] = x + minDistance;
                        extent[3] = y + minDistance;
                    }
                }
            });
            return closestFeature;
        };
        /**
         * Get the extent of the features currently in the source.
         *
         * This method is not available when the source is configured with
         * `useSpatialIndex` set to `false`.
         * @param {import("../extent.js").Extent=} opt_extent Destination extent. If provided, no new extent
         *     will be created. Instead, that extent's coordinates will be overwritten.
         * @return {import("../extent.js").Extent} Extent.
         * @api
         */
        VectorSource.prototype.getExtent = function (opt_extent) {
            return this.featuresRtree_.getExtent(opt_extent);
        };
        /**
         * Get a feature by its identifier (the value returned by feature.getId()).
         * Note that the index treats string and numeric identifiers as the same.  So
         * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
         *
         * @param {string|number} id Feature identifier.
         * @return {import("../Feature.js").default<Geometry>} The feature (or `null` if not found).
         * @api
         */
        VectorSource.prototype.getFeatureById = function (id) {
            var feature = this.idIndex_[id.toString()];
            return feature !== undefined ? feature : null;
        };
        /**
         * Get a feature by its internal unique identifier (using `getUid`).
         *
         * @param {string} uid Feature identifier.
         * @return {import("../Feature.js").default<Geometry>} The feature (or `null` if not found).
         */
        VectorSource.prototype.getFeatureByUid = function (uid) {
            var feature = this.uidIndex_[uid];
            return feature !== undefined ? feature : null;
        };
        /**
         * Get the format associated with this source.
         *
         * @return {import("../format/Feature.js").default|undefined} The feature format.
         * @api
         */
        VectorSource.prototype.getFormat = function () {
            return this.format_;
        };
        /**
         * @return {boolean} The source can have overlapping geometries.
         */
        VectorSource.prototype.getOverlaps = function () {
            return this.overlaps_;
        };
        /**
         * Get the url associated with this source.
         *
         * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
         * @api
         */
        VectorSource.prototype.getUrl = function () {
            return this.url_;
        };
        /**
         * @param {Event} event Event.
         * @private
         */
        VectorSource.prototype.handleFeatureChange_ = function (event) {
            var feature = /** @type {import("../Feature.js").default<Geometry>} */ (event.target);
            var featureKey = getUid(feature);
            var geometry = feature.getGeometry();
            if (!geometry) {
                if (!(featureKey in this.nullGeometryFeatures_)) {
                    if (this.featuresRtree_) {
                        this.featuresRtree_.remove(feature);
                    }
                    this.nullGeometryFeatures_[featureKey] = feature;
                }
            }
            else {
                var extent = geometry.getExtent();
                if (featureKey in this.nullGeometryFeatures_) {
                    delete this.nullGeometryFeatures_[featureKey];
                    if (this.featuresRtree_) {
                        this.featuresRtree_.insert(extent, feature);
                    }
                }
                else {
                    if (this.featuresRtree_) {
                        this.featuresRtree_.update(extent, feature);
                    }
                }
            }
            var id = feature.getId();
            if (id !== undefined) {
                var sid = id.toString();
                if (this.idIndex_[sid] !== feature) {
                    this.removeFromIdIndex_(feature);
                    this.idIndex_[sid] = feature;
                }
            }
            else {
                this.removeFromIdIndex_(feature);
                this.uidIndex_[featureKey] = feature;
            }
            this.changed();
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature));
        };
        /**
         * Returns true if the feature is contained within the source.
         * @param {import("../Feature.js").default<Geometry>} feature Feature.
         * @return {boolean} Has feature.
         * @api
         */
        VectorSource.prototype.hasFeature = function (feature) {
            var id = feature.getId();
            if (id !== undefined) {
                return id in this.idIndex_;
            }
            else {
                return getUid(feature) in this.uidIndex_;
            }
        };
        /**
         * @return {boolean} Is empty.
         */
        VectorSource.prototype.isEmpty = function () {
            return this.featuresRtree_.isEmpty() && isEmpty$1(this.nullGeometryFeatures_);
        };
        /**
         * @param {import("../extent.js").Extent} extent Extent.
         * @param {number} resolution Resolution.
         * @param {import("../proj/Projection.js").default} projection Projection.
         */
        VectorSource.prototype.loadFeatures = function (extent, resolution, projection) {
            var loadedExtentsRtree = this.loadedExtentsRtree_;
            var extentsToLoad = this.strategy_(extent, resolution);
            this.loading = false;
            var _loop_1 = function (i, ii) {
                var extentToLoad = extentsToLoad[i];
                var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, 
                /**
                 * @param {{extent: import("../extent.js").Extent}} object Object.
                 * @return {boolean} Contains.
                 */
                function (object) {
                    return containsExtent(object.extent, extentToLoad);
                });
                if (!alreadyLoaded) {
                    this_1.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADSTART));
                    this_1.loader_.call(this_1, extentToLoad, resolution, projection, function (features) {
                        this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADEND, undefined, features));
                    }.bind(this_1), function () {
                        this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADERROR));
                    }.bind(this_1));
                    loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
                    this_1.loading = this_1.loader_ !== VOID;
                }
            };
            var this_1 = this;
            for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
                _loop_1(i);
            }
        };
        VectorSource.prototype.refresh = function () {
            this.clear(true);
            this.loadedExtentsRtree_.clear();
            _super.prototype.refresh.call(this);
        };
        /**
         * Remove an extent from the list of loaded extents.
         * @param {import("../extent.js").Extent} extent Extent.
         * @api
         */
        VectorSource.prototype.removeLoadedExtent = function (extent) {
            var loadedExtentsRtree = this.loadedExtentsRtree_;
            var obj;
            loadedExtentsRtree.forEachInExtent(extent, function (object) {
                if (equals$1(object.extent, extent)) {
                    obj = object;
                    return true;
                }
            });
            if (obj) {
                loadedExtentsRtree.remove(obj);
            }
        };
        /**
         * Remove a single feature from the source.  If you want to remove all features
         * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
         * instead.
         * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
         * @api
         */
        VectorSource.prototype.removeFeature = function (feature) {
            var featureKey = getUid(feature);
            if (featureKey in this.nullGeometryFeatures_) {
                delete this.nullGeometryFeatures_[featureKey];
            }
            else {
                if (this.featuresRtree_) {
                    this.featuresRtree_.remove(feature);
                }
            }
            this.removeFeatureInternal(feature);
            this.changed();
        };
        /**
         * Remove feature without firing a `change` event.
         * @param {import("../Feature.js").default<Geometry>} feature Feature.
         * @protected
         */
        VectorSource.prototype.removeFeatureInternal = function (feature) {
            var featureKey = getUid(feature);
            this.featureChangeKeys_[featureKey].forEach(unlistenByKey);
            delete this.featureChangeKeys_[featureKey];
            var id = feature.getId();
            if (id !== undefined) {
                delete this.idIndex_[id.toString()];
            }
            delete this.uidIndex_[featureKey];
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature));
        };
        /**
         * Remove a feature from the id index.  Called internally when the feature id
         * may have changed.
         * @param {import("../Feature.js").default<Geometry>} feature The feature.
         * @return {boolean} Removed the feature from the index.
         * @private
         */
        VectorSource.prototype.removeFromIdIndex_ = function (feature) {
            var removed = false;
            for (var id in this.idIndex_) {
                if (this.idIndex_[id] === feature) {
                    delete this.idIndex_[id];
                    removed = true;
                    break;
                }
            }
            return removed;
        };
        /**
         * Set the new loader of the source. The next render cycle will use the
         * new loader.
         * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
         * @api
         */
        VectorSource.prototype.setLoader = function (loader) {
            this.loader_ = loader;
        };
        /**
         * Points the source to a new url. The next render cycle will use the new url.
         * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
         * @api
         */
        VectorSource.prototype.setUrl = function (url) {
            assert(this.format_, 7); // `format` must be set when `url` is set
            this.setLoader(xhr$1(url, this.format_));
        };
        return VectorSource;
    }(Source));

    var __extends$F = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {number} [opacity=1] Opacity (0, 1).
     * @property {boolean} [visible=true] Visibility.
     * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
     * visible.
     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
     * be visible.
     * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     * @property {Array<import("./Base.js").default>|import("../Collection.js").default<import("./Base.js").default>} [layers] Child layers.
     */
    /**
     * @enum {string}
     * @private
     */
    var Property = {
        LAYERS: 'layers',
    };
    /**
     * @classdesc
     * A {@link module:ol/Collection~Collection} of layers that are handled together.
     *
     * A generic `change` event is triggered when the group/Collection changes.
     *
     * @api
     */
    var LayerGroup = /** @class */ (function (_super) {
        __extends$F(LayerGroup, _super);
        /**
         * @param {Options=} opt_options Layer options.
         */
        function LayerGroup(opt_options) {
            var _this = this;
            var options = opt_options || {};
            var baseOptions = /** @type {Options} */ (assign({}, options));
            delete baseOptions.layers;
            var layers = options.layers;
            _this = _super.call(this, baseOptions) || this;
            /**
             * @private
             * @type {Array<import("../events.js").EventsKey>}
             */
            _this.layersListenerKeys_ = [];
            /**
             * @private
             * @type {Object<string, Array<import("../events.js").EventsKey>>}
             */
            _this.listenerKeys_ = {};
            _this.addEventListener(getChangeEventType(Property.LAYERS), _this.handleLayersChanged_);
            if (layers) {
                if (Array.isArray(layers)) {
                    layers = new Collection(layers.slice(), { unique: true });
                }
                else {
                    assert(typeof ( /** @type {?} */(layers).getArray) === 'function', 43); // Expected `layers` to be an array or a `Collection`
                }
            }
            else {
                layers = new Collection(undefined, { unique: true });
            }
            _this.setLayers(layers);
            return _this;
        }
        /**
         * @private
         */
        LayerGroup.prototype.handleLayerChange_ = function () {
            this.changed();
        };
        /**
         * @private
         */
        LayerGroup.prototype.handleLayersChanged_ = function () {
            this.layersListenerKeys_.forEach(unlistenByKey);
            this.layersListenerKeys_.length = 0;
            var layers = this.getLayers();
            this.layersListenerKeys_.push(listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));
            for (var id in this.listenerKeys_) {
                this.listenerKeys_[id].forEach(unlistenByKey);
            }
            clear(this.listenerKeys_);
            var layersArray = layers.getArray();
            for (var i = 0, ii = layersArray.length; i < ii; i++) {
                var layer = layersArray[i];
                this.listenerKeys_[getUid(layer)] = [
                    listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),
                    listen(layer, EventType.CHANGE, this.handleLayerChange_, this),
                ];
            }
            this.changed();
        };
        /**
         * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
         * @private
         */
        LayerGroup.prototype.handleLayersAdd_ = function (collectionEvent) {
            var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
            this.listenerKeys_[getUid(layer)] = [
                listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),
                listen(layer, EventType.CHANGE, this.handleLayerChange_, this),
            ];
            this.changed();
        };
        /**
         * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
         * @private
         */
        LayerGroup.prototype.handleLayersRemove_ = function (collectionEvent) {
            var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
            var key = getUid(layer);
            this.listenerKeys_[key].forEach(unlistenByKey);
            delete this.listenerKeys_[key];
            this.changed();
        };
        /**
         * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
         * in this group.
         * @return {!import("../Collection.js").default<import("./Base.js").default>} Collection of
         *   {@link module:ol/layer/Base layers} that are part of this group.
         * @observable
         * @api
         */
        LayerGroup.prototype.getLayers = function () {
            return /** @type {!import("../Collection.js").default<import("./Base.js").default>} */ (this.get(Property.LAYERS));
        };
        /**
         * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
         * in this group.
         * @param {!import("../Collection.js").default<import("./Base.js").default>} layers Collection of
         *   {@link module:ol/layer/Base layers} that are part of this group.
         * @observable
         * @api
         */
        LayerGroup.prototype.setLayers = function (layers) {
            this.set(Property.LAYERS, layers);
        };
        /**
         * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be modified in place).
         * @return {Array<import("./Layer.js").default>} Array of layers.
         */
        LayerGroup.prototype.getLayersArray = function (opt_array) {
            var array = opt_array !== undefined ? opt_array : [];
            this.getLayers().forEach(function (layer) {
                layer.getLayersArray(array);
            });
            return array;
        };
        /**
         * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer states (to be modified in place).
         * @return {Array<import("./Layer.js").State>} List of layer states.
         */
        LayerGroup.prototype.getLayerStatesArray = function (opt_states) {
            var states = opt_states !== undefined ? opt_states : [];
            var pos = states.length;
            this.getLayers().forEach(function (layer) {
                layer.getLayerStatesArray(states);
            });
            var ownLayerState = this.getLayerState();
            for (var i = pos, ii = states.length; i < ii; i++) {
                var layerState = states[i];
                layerState.opacity *= ownLayerState.opacity;
                layerState.visible = layerState.visible && ownLayerState.visible;
                layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
                layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
                layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
                layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
                if (ownLayerState.extent !== undefined) {
                    if (layerState.extent !== undefined) {
                        layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);
                    }
                    else {
                        layerState.extent = ownLayerState.extent;
                    }
                }
            }
            return states;
        };
        /**
         * @return {import("../source/State.js").default} Source state.
         */
        LayerGroup.prototype.getSourceState = function () {
            return SourceState.READY;
        };
        return LayerGroup;
    }(BaseLayer));

    /**
     * @module ol/reproj/common
     */
    /**
     * Default maximum allowed threshold  (in pixels) for reprojection
     * triangulation.
     * @type {number}
     */
    var ERROR_THRESHOLD = 0.5;

    var __extends$E = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Canvas renderer for image layers.
     * @api
     */
    var CanvasImageLayerRenderer = /** @class */ (function (_super) {
        __extends$E(CanvasImageLayerRenderer, _super);
        /**
         * @param {import("../../layer/Image.js").default} imageLayer Image layer.
         */
        function CanvasImageLayerRenderer(imageLayer) {
            var _this = _super.call(this, imageLayer) || this;
            /**
             * @protected
             * @type {?import("../../ImageBase.js").default}
             */
            _this.image_ = null;
            return _this;
        }
        /**
         * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
         */
        CanvasImageLayerRenderer.prototype.getImage = function () {
            return !this.image_ ? null : this.image_.getImage();
        };
        /**
         * Determine whether render should be called.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @return {boolean} Layer is ready to be rendered.
         */
        CanvasImageLayerRenderer.prototype.prepareFrame = function (frameState) {
            var layerState = frameState.layerStatesArray[frameState.layerIndex];
            var pixelRatio = frameState.pixelRatio;
            var viewState = frameState.viewState;
            var viewResolution = viewState.resolution;
            var imageSource = this.getLayer().getSource();
            var hints = frameState.viewHints;
            var renderedExtent = frameState.extent;
            if (layerState.extent !== undefined) {
                renderedExtent = getIntersection(renderedExtent, fromUserExtent(layerState.extent, viewState.projection));
            }
            if (!hints[ViewHint.ANIMATING] &&
                !hints[ViewHint.INTERACTING] &&
                !isEmpty(renderedExtent)) {
                if (imageSource) {
                    var projection = viewState.projection;
                    var image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
                    if (image && this.loadImage(image)) {
                        this.image_ = image;
                    }
                }
                else {
                    this.image_ = null;
                }
            }
            return !!this.image_;
        };
        /**
         * Render the layer.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @param {HTMLElement} target Target that may be used to render content to.
         * @return {HTMLElement} The rendered element.
         */
        CanvasImageLayerRenderer.prototype.renderFrame = function (frameState, target) {
            var image = this.image_;
            var imageExtent = image.getExtent();
            var imageResolution = image.getResolution();
            var imagePixelRatio = image.getPixelRatio();
            var layerState = frameState.layerStatesArray[frameState.layerIndex];
            var pixelRatio = frameState.pixelRatio;
            var viewState = frameState.viewState;
            var viewCenter = viewState.center;
            var viewResolution = viewState.resolution;
            var size = frameState.size;
            var scale = (pixelRatio * imageResolution) / (viewResolution * imagePixelRatio);
            var width = Math.round(size[0] * pixelRatio);
            var height = Math.round(size[1] * pixelRatio);
            var rotation = viewState.rotation;
            if (rotation) {
                var size_1 = Math.round(Math.sqrt(width * width + height * height));
                width = size_1;
                height = size_1;
            }
            // set forward and inverse pixel transforms
            compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
            makeInverse(this.inversePixelTransform, this.pixelTransform);
            var canvasTransform = createTransformString(this.pixelTransform);
            this.useContainer(target, canvasTransform, layerState.opacity);
            var context = this.context;
            var canvas = context.canvas;
            if (canvas.width != width || canvas.height != height) {
                canvas.width = width;
                canvas.height = height;
            }
            else if (!this.containerReused) {
                context.clearRect(0, 0, width, height);
            }
            // clipped rendering if layer extent is set
            var clipped = false;
            if (layerState.extent) {
                var layerExtent = fromUserExtent(layerState.extent, viewState.projection);
                clipped =
                    !containsExtent(layerExtent, frameState.extent) &&
                        intersects(layerExtent, frameState.extent);
                if (clipped) {
                    this.clipUnrotated(context, frameState, layerExtent);
                }
            }
            var img = image.getImage();
            var transform = compose(this.tempTransform, width / 2, height / 2, scale, scale, 0, (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolution, (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolution);
            this.renderedResolution = (imageResolution * pixelRatio) / imagePixelRatio;
            var dx = transform[4];
            var dy = transform[5];
            var dw = img.width * transform[0];
            var dh = img.height * transform[3];
            assign(context, this.getLayer().getSource().getContextOptions());
            this.preRender(context, frameState);
            if (dw >= 0.5 && dh >= 0.5) {
                var opacity = layerState.opacity;
                var previousAlpha = void 0;
                if (opacity !== 1) {
                    previousAlpha = this.context.globalAlpha;
                    this.context.globalAlpha = opacity;
                }
                this.context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
                if (opacity !== 1) {
                    this.context.globalAlpha = previousAlpha;
                }
            }
            this.postRender(context, frameState);
            if (clipped) {
                context.restore();
            }
            if (canvasTransform !== canvas.style.transform) {
                canvas.style.transform = canvasTransform;
            }
            return this.container;
        };
        return CanvasImageLayerRenderer;
    }(CanvasLayerRenderer));

    /**
     * @module ol/TileRange
     */
    /**
     * A representation of a contiguous block of tiles.  A tile range is specified
     * by its min/max tile coordinates and is inclusive of coordinates.
     */
    var TileRange = /** @class */ (function () {
        /**
         * @param {number} minX Minimum X.
         * @param {number} maxX Maximum X.
         * @param {number} minY Minimum Y.
         * @param {number} maxY Maximum Y.
         */
        function TileRange(minX, maxX, minY, maxY) {
            /**
             * @type {number}
             */
            this.minX = minX;
            /**
             * @type {number}
             */
            this.maxX = maxX;
            /**
             * @type {number}
             */
            this.minY = minY;
            /**
             * @type {number}
             */
            this.maxY = maxY;
        }
        /**
         * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @return {boolean} Contains tile coordinate.
         */
        TileRange.prototype.contains = function (tileCoord) {
            return this.containsXY(tileCoord[1], tileCoord[2]);
        };
        /**
         * @param {TileRange} tileRange Tile range.
         * @return {boolean} Contains.
         */
        TileRange.prototype.containsTileRange = function (tileRange) {
            return (this.minX <= tileRange.minX &&
                tileRange.maxX <= this.maxX &&
                this.minY <= tileRange.minY &&
                tileRange.maxY <= this.maxY);
        };
        /**
         * @param {number} x Tile coordinate x.
         * @param {number} y Tile coordinate y.
         * @return {boolean} Contains coordinate.
         */
        TileRange.prototype.containsXY = function (x, y) {
            return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
        };
        /**
         * @param {TileRange} tileRange Tile range.
         * @return {boolean} Equals.
         */
        TileRange.prototype.equals = function (tileRange) {
            return (this.minX == tileRange.minX &&
                this.minY == tileRange.minY &&
                this.maxX == tileRange.maxX &&
                this.maxY == tileRange.maxY);
        };
        /**
         * @param {TileRange} tileRange Tile range.
         */
        TileRange.prototype.extend = function (tileRange) {
            if (tileRange.minX < this.minX) {
                this.minX = tileRange.minX;
            }
            if (tileRange.maxX > this.maxX) {
                this.maxX = tileRange.maxX;
            }
            if (tileRange.minY < this.minY) {
                this.minY = tileRange.minY;
            }
            if (tileRange.maxY > this.maxY) {
                this.maxY = tileRange.maxY;
            }
        };
        /**
         * @return {number} Height.
         */
        TileRange.prototype.getHeight = function () {
            return this.maxY - this.minY + 1;
        };
        /**
         * @return {import("./size.js").Size} Size.
         */
        TileRange.prototype.getSize = function () {
            return [this.getWidth(), this.getHeight()];
        };
        /**
         * @return {number} Width.
         */
        TileRange.prototype.getWidth = function () {
            return this.maxX - this.minX + 1;
        };
        /**
         * @param {TileRange} tileRange Tile range.
         * @return {boolean} Intersects.
         */
        TileRange.prototype.intersects = function (tileRange) {
            return (this.minX <= tileRange.maxX &&
                this.maxX >= tileRange.minX &&
                this.minY <= tileRange.maxY &&
                this.maxY >= tileRange.minY);
        };
        return TileRange;
    }());
    /**
     * @param {number} minX Minimum X.
     * @param {number} maxX Maximum X.
     * @param {number} minY Minimum Y.
     * @param {number} maxY Maximum Y.
     * @param {TileRange=} tileRange TileRange.
     * @return {TileRange} Tile range.
     */
    function createOrUpdate$1(minX, maxX, minY, maxY, tileRange) {
        if (tileRange !== undefined) {
            tileRange.minX = minX;
            tileRange.maxX = maxX;
            tileRange.minY = minY;
            tileRange.maxY = maxY;
            return tileRange;
        }
        else {
            return new TileRange(minX, maxX, minY, maxY);
        }
    }

    /**
     * @module ol/TileState
     */
    /**
     * @enum {number}
     */
    var TileState = {
        IDLE: 0,
        LOADING: 1,
        LOADED: 2,
        /**
         * Indicates that tile loading failed
         * @type {number}
         */
        ERROR: 3,
        EMPTY: 4,
    };

    var __extends$D = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Canvas renderer for tile layers.
     * @api
     */
    var CanvasTileLayerRenderer = /** @class */ (function (_super) {
        __extends$D(CanvasTileLayerRenderer, _super);
        /**
         * @param {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default} tileLayer Tile layer.
         */
        function CanvasTileLayerRenderer(tileLayer) {
            var _this = _super.call(this, tileLayer) || this;
            /**
             * Rendered extent has changed since the previous `renderFrame()` call
             * @type {boolean}
             */
            _this.extentChanged = true;
            /**
             * @private
             * @type {?import("../../extent.js").Extent}
             */
            _this.renderedExtent_ = null;
            /**
             * @protected
             * @type {number}
             */
            _this.renderedPixelRatio;
            /**
             * @protected
             * @type {import("../../proj/Projection.js").default}
             */
            _this.renderedProjection = null;
            /**
             * @protected
             * @type {number}
             */
            _this.renderedRevision;
            /**
             * @protected
             * @type {!Array<import("../../Tile.js").default>}
             */
            _this.renderedTiles = [];
            /**
             * @private
             * @type {boolean}
             */
            _this.newTiles_ = false;
            /**
             * @protected
             * @type {import("../../extent.js").Extent}
             */
            _this.tmpExtent = createEmpty();
            /**
             * @private
             * @type {import("../../TileRange.js").default}
             */
            _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);
            return _this;
        }
        /**
         * @protected
         * @param {import("../../Tile.js").default} tile Tile.
         * @return {boolean} Tile is drawable.
         */
        CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {
            var tileLayer = this.getLayer();
            var tileState = tile.getState();
            var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
            return (tileState == TileState.LOADED ||
                tileState == TileState.EMPTY ||
                (tileState == TileState.ERROR && !useInterimTilesOnError));
        };
        /**
         * @param {number} z Tile coordinate z.
         * @param {number} x Tile coordinate x.
         * @param {number} y Tile coordinate y.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @return {!import("../../Tile.js").default} Tile.
         */
        CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {
            var pixelRatio = frameState.pixelRatio;
            var projection = frameState.viewState.projection;
            var tileLayer = this.getLayer();
            var tileSource = tileLayer.getSource();
            var tile = tileSource.getTile(z, x, y, pixelRatio, projection);
            if (tile.getState() == TileState.ERROR) {
                if (!tileLayer.getUseInterimTilesOnError()) {
                    // When useInterimTilesOnError is false, we consider the error tile as loaded.
                    tile.setState(TileState.LOADED);
                }
                else if (tileLayer.getPreload() > 0) {
                    // Preloaded tiles for lower resolutions might have finished loading.
                    this.newTiles_ = true;
                }
            }
            if (!this.isDrawableTile(tile)) {
                tile = tile.getInterimTile();
            }
            return tile;
        };
        /**
         * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
         * @param {number} zoom Zoom level.
         * @param {import("../../Tile.js").default} tile Tile.
         * @return {boolean|void} If `false`, the tile will not be considered loaded.
         */
        CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
            if (this.isDrawableTile(tile)) {
                return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);
            }
            return false;
        };
        /**
         * Determine whether render should be called.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @return {boolean} Layer is ready to be rendered.
         */
        CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {
            return !!this.getLayer().getSource();
        };
        /**
         * Render the layer.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @param {HTMLElement} target Target that may be used to render content to.
         * @return {HTMLElement} The rendered element.
         */
        CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {
            var layerState = frameState.layerStatesArray[frameState.layerIndex];
            var viewState = frameState.viewState;
            var projection = viewState.projection;
            var viewResolution = viewState.resolution;
            var viewCenter = viewState.center;
            var rotation = viewState.rotation;
            var pixelRatio = frameState.pixelRatio;
            var tileLayer = this.getLayer();
            var tileSource = tileLayer.getSource();
            var sourceRevision = tileSource.getRevision();
            var tileGrid = tileSource.getTileGridForProjection(projection);
            var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
            var tileResolution = tileGrid.getResolution(z);
            var extent = frameState.extent;
            var layerExtent = layerState.extent && fromUserExtent(layerState.extent);
            if (layerExtent) {
                extent = getIntersection(extent, fromUserExtent(layerState.extent));
            }
            var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
            // desired dimensions of the canvas in pixels
            var width = Math.round(frameState.size[0] * tilePixelRatio);
            var height = Math.round(frameState.size[1] * tilePixelRatio);
            if (rotation) {
                var size = Math.round(Math.sqrt(width * width + height * height));
                width = size;
                height = size;
            }
            var dx = (tileResolution * width) / 2 / tilePixelRatio;
            var dy = (tileResolution * height) / 2 / tilePixelRatio;
            var canvasExtent = [
                viewCenter[0] - dx,
                viewCenter[1] - dy,
                viewCenter[0] + dx,
                viewCenter[1] + dy,
            ];
            var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
            /**
             * @type {Object<number, Object<string, import("../../Tile.js").default>>}
             */
            var tilesToDrawByZ = {};
            tilesToDrawByZ[z] = {};
            var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
            var tmpExtent = this.tmpExtent;
            var tmpTileRange = this.tmpTileRange_;
            this.newTiles_ = false;
            for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
                for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
                    var tile = this.getTile(z, x, y, frameState);
                    if (this.isDrawableTile(tile)) {
                        var uid = getUid(this);
                        if (tile.getState() == TileState.LOADED) {
                            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
                            var inTransition = tile.inTransition(uid);
                            if (!this.newTiles_ &&
                                (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
                                this.newTiles_ = true;
                            }
                        }
                        if (tile.getAlpha(uid, frameState.time) === 1) {
                            // don't look for alt tiles if alpha is 1
                            continue;
                        }
                    }
                    var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
                    var covered = false;
                    if (childTileRange) {
                        covered = findLoadedTiles(z + 1, childTileRange);
                    }
                    if (!covered) {
                        tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
                    }
                }
            }
            var canvasScale = tileResolution / viewResolution;
            // set forward and inverse pixel transforms
            compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);
            var canvasTransform = createTransformString(this.pixelTransform);
            this.useContainer(target, canvasTransform, layerState.opacity);
            var context = this.context;
            var canvas = context.canvas;
            makeInverse(this.inversePixelTransform, this.pixelTransform);
            // set scale transform for calculating tile positions on the canvas
            compose(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);
            if (canvas.width != width || canvas.height != height) {
                canvas.width = width;
                canvas.height = height;
            }
            else if (!this.containerReused) {
                context.clearRect(0, 0, width, height);
            }
            if (layerExtent) {
                this.clipUnrotated(context, frameState, layerExtent);
            }
            assign(context, tileSource.getContextOptions());
            this.preRender(context, frameState);
            this.renderedTiles.length = 0;
            /** @type {Array<number>} */
            var zs = Object.keys(tilesToDrawByZ).map(Number);
            zs.sort(numberSafeCompareFunction);
            var clips, clipZs, currentClip;
            if (layerState.opacity === 1 &&
                (!this.containerReused ||
                    tileSource.getOpaque(frameState.viewState.projection))) {
                zs = zs.reverse();
            }
            else {
                clips = [];
                clipZs = [];
            }
            for (var i = zs.length - 1; i >= 0; --i) {
                var currentZ = zs[i];
                var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
                var currentResolution = tileGrid.getResolution(currentZ);
                var currentScale = currentResolution / tileResolution;
                var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;
                var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;
                var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);
                var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
                var origin_1 = apply(this.tempTransform, [
                    (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /
                        tileResolution,
                    (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /
                        tileResolution,
                ]);
                var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
                var tilesToDraw = tilesToDrawByZ[currentZ];
                for (var tileCoordKey in tilesToDraw) {
                    var tile = /** @type {import("../../ImageTile.js").default} */ (tilesToDraw[tileCoordKey]);
                    var tileCoord = tile.tileCoord;
                    // Calculate integer positions and sizes so that tiles align
                    var floatX = origin_1[0] - (originTileCoord[1] - tileCoord[1]) * dx_1;
                    var nextX = Math.round(floatX + dx_1);
                    var floatY = origin_1[1] - (originTileCoord[2] - tileCoord[2]) * dy_1;
                    var nextY = Math.round(floatY + dy_1);
                    var x = Math.round(floatX);
                    var y = Math.round(floatY);
                    var w = nextX - x;
                    var h = nextY - y;
                    var transition = z === currentZ;
                    var inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;
                    if (!inTransition) {
                        if (clips) {
                            // Clip mask for regions in this tile that already filled by a higher z tile
                            context.save();
                            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
                            for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {
                                if (z !== currentZ && currentZ < clipZs[i_1]) {
                                    var clip = clips[i_1];
                                    context.beginPath();
                                    // counter-clockwise (outer ring) for current tile
                                    context.moveTo(currentClip[0], currentClip[1]);
                                    context.lineTo(currentClip[2], currentClip[3]);
                                    context.lineTo(currentClip[4], currentClip[5]);
                                    context.lineTo(currentClip[6], currentClip[7]);
                                    // clockwise (inner ring) for higher z tile
                                    context.moveTo(clip[6], clip[7]);
                                    context.lineTo(clip[4], clip[5]);
                                    context.lineTo(clip[2], clip[3]);
                                    context.lineTo(clip[0], clip[1]);
                                    context.clip();
                                }
                            }
                            clips.push(currentClip);
                            clipZs.push(currentZ);
                        }
                        else {
                            context.clearRect(x, y, w, h);
                        }
                    }
                    this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition, layerState.opacity);
                    if (clips && !inTransition) {
                        context.restore();
                    }
                    this.renderedTiles.push(tile);
                    this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
                }
            }
            this.renderedRevision = sourceRevision;
            this.renderedResolution = tileResolution;
            this.extentChanged =
                !this.renderedExtent_ || !equals$1(this.renderedExtent_, canvasExtent);
            this.renderedExtent_ = canvasExtent;
            this.renderedPixelRatio = pixelRatio;
            this.renderedProjection = projection;
            this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
            this.scheduleExpireCache(frameState, tileSource);
            this.postRender(context, frameState);
            if (layerState.extent) {
                context.restore();
            }
            if (canvasTransform !== canvas.style.transform) {
                canvas.style.transform = canvasTransform;
            }
            return this.container;
        };
        /**
         * @param {import("../../ImageTile.js").default} tile Tile.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @param {number} x Left of the tile.
         * @param {number} y Top of the tile.
         * @param {number} w Width of the tile.
         * @param {number} h Height of the tile.
         * @param {number} gutter Tile gutter.
         * @param {boolean} transition Apply an alpha transition.
         * @param {number} opacity Opacity.
         */
        CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition, opacity) {
            var image = this.getTileImage(tile);
            if (!image) {
                return;
            }
            var uid = getUid(this);
            var tileAlpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
            var alpha = opacity * tileAlpha;
            var alphaChanged = alpha !== this.context.globalAlpha;
            if (alphaChanged) {
                this.context.save();
                this.context.globalAlpha = alpha;
            }
            this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);
            if (alphaChanged) {
                this.context.restore();
            }
            if (tileAlpha !== 1) {
                frameState.animate = true;
            }
            else if (transition) {
                tile.endTransition(uid);
            }
        };
        /**
         * @return {HTMLCanvasElement} Image
         */
        CanvasTileLayerRenderer.prototype.getImage = function () {
            var context = this.context;
            return context ? context.canvas : null;
        };
        /**
         * Get the image from a tile.
         * @param {import("../../ImageTile.js").default} tile Tile.
         * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
         * @protected
         */
        CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {
            return tile.getImage();
        };
        /**
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @param {import("../../source/Tile.js").default} tileSource Tile source.
         * @protected
         */
        CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {
            if (tileSource.canExpireCache()) {
                /**
                 * @param {import("../../source/Tile.js").default} tileSource Tile source.
                 * @param {import("../../PluggableMap.js").default} map Map.
                 * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
                 */
                var postRenderFunction = function (tileSource, map, frameState) {
                    var tileSourceKey = getUid(tileSource);
                    if (tileSourceKey in frameState.usedTiles) {
                        tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
                    }
                }.bind(null, tileSource);
                frameState.postRenderFunctions.push(
                /** @type {import("../../PluggableMap.js").PostRenderFunction} */ (postRenderFunction));
            }
        };
        /**
         * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
         * @param {import("../../source/Tile.js").default} tileSource Tile source.
         * @param {import('../../Tile.js').default} tile Tile.
         * @protected
         */
        CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {
            // FIXME should we use tilesToDrawByZ instead?
            var tileSourceKey = getUid(tileSource);
            if (!(tileSourceKey in usedTiles)) {
                usedTiles[tileSourceKey] = {};
            }
            usedTiles[tileSourceKey][tile.getKey()] = true;
        };
        /**
         * Manage tile pyramid.
         * This function performs a number of functions related to the tiles at the
         * current zoom and lower zoom levels:
         * - registers idle tiles in frameState.wantedTiles so that they are not
         *   discarded by the tile queue
         * - enqueues missing tiles
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @param {import("../../source/Tile.js").default} tileSource Tile source.
         * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../../proj/Projection.js").default} projection Projection.
         * @param {import("../../extent.js").Extent} extent Extent.
         * @param {number} currentZ Current Z.
         * @param {number} preload Load low resolution tiles up to 'preload' levels.
         * @param {function(import("../../Tile.js").default)=} opt_tileCallback Tile callback.
         * @protected
         */
        CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {
            var tileSourceKey = getUid(tileSource);
            if (!(tileSourceKey in frameState.wantedTiles)) {
                frameState.wantedTiles[tileSourceKey] = {};
            }
            var wantedTiles = frameState.wantedTiles[tileSourceKey];
            var tileQueue = frameState.tileQueue;
            var minZoom = tileGrid.getMinZoom();
            var tileCount = 0;
            var tile, tileRange, tileResolution, x, y, z;
            for (z = minZoom; z <= currentZ; ++z) {
                tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
                tileResolution = tileGrid.getResolution(z);
                for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
                    for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
                        if (currentZ - z <= preload) {
                            ++tileCount;
                            tile = tileSource.getTile(z, x, y, pixelRatio, projection);
                            if (tile.getState() == TileState.IDLE) {
                                wantedTiles[tile.getKey()] = true;
                                if (!tileQueue.isKeyQueued(tile.getKey())) {
                                    tileQueue.enqueue([
                                        tile,
                                        tileSourceKey,
                                        tileGrid.getTileCoordCenter(tile.tileCoord),
                                        tileResolution,
                                    ]);
                                }
                            }
                            if (opt_tileCallback !== undefined) {
                                opt_tileCallback(tile);
                            }
                        }
                        else {
                            tileSource.useTile(z, x, y, projection);
                        }
                    }
                }
            }
            tileSource.updateCacheSize(tileCount, projection);
        };
        return CanvasTileLayerRenderer;
    }(CanvasLayerRenderer));
    /**
     * @function
     * @return {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default}
     */
    CanvasTileLayerRenderer.prototype.getLayer;

    /**
     * @module ol/layer/TileProperty
     */
    /**
     * @enum {string}
     */
    var TileProperty = {
        PRELOAD: 'preload',
        USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',
    };

    var __extends$C = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A function that takes an {@link module:ol/Tile} for the tile and a
     * `{string}` for the url as arguments. The default is
     * ```js
     * source.setTileLoadFunction(function(tile, src) {
     *   tile.getImage().src = src;
     * });
     * ```
     * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
     * error handling:
     *
     * ```js
     * import TileState from 'ol/TileState';
     *
     * source.setTileLoadFunction(function(tile, src) {
     *   var xhr = new XMLHttpRequest();
     *   xhr.responseType = 'blob';
     *   xhr.addEventListener('loadend', function (evt) {
     *     var data = this.response;
     *     if (data !== undefined) {
     *       tile.getImage().src = URL.createObjectURL(data);
     *     } else {
     *       tile.setState(TileState.ERROR);
     *     }
     *   });
     *   xhr.addEventListener('error', function () {
     *     tile.setState(TileState.ERROR);
     *   });
     *   xhr.open('GET', src);
     *   xhr.send();
     * });
     * ```
     *
     * @typedef {function(Tile, string): void} LoadFunction
     * @api
     */
    /**
     * {@link module:ol/source/Tile~Tile} sources use a function of this type to get
     * the url that provides a tile for a given tile coordinate.
     *
     * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
     * coordinate, a `{number}` representing the pixel ratio and a
     * {@link module:ol/proj/Projection} for the projection  as arguments
     * and returns a `{string}` representing the tile URL, or undefined if no tile
     * should be requested for the passed tile coordinate.
     *
     * @typedef {function(import("./tilecoord.js").TileCoord, number,
     *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
     * @api
     */
    /**
     * @typedef {Object} Options
     * @property {number} [transition=250] A duration for tile opacity
     * transitions in milliseconds. A duration of 0 disables the opacity transition.
     * @api
     */
    /**
     * @classdesc
     * Base class for tiles.
     *
     * @abstract
     */
    var Tile = /** @class */ (function (_super) {
        __extends$C(Tile, _super);
        /**
         * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @param {import("./TileState.js").default} state State.
         * @param {Options=} opt_options Tile options.
         */
        function Tile(tileCoord, state, opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            /**
             * @type {import("./tilecoord.js").TileCoord}
             */
            _this.tileCoord = tileCoord;
            /**
             * @protected
             * @type {import("./TileState.js").default}
             */
            _this.state = state;
            /**
             * An "interim" tile for this tile. The interim tile may be used while this
             * one is loading, for "smooth" transitions when changing params/dimensions
             * on the source.
             * @type {Tile}
             */
            _this.interimTile = null;
            /**
             * The tile is available at the highest possible resolution. Subclasses can
             * set this to `false` initially. Tile load listeners will not be
             * unregistered before this is set to `true` and a `#changed()` is called.
             * @type {boolean}
             */
            _this.hifi = true;
            /**
             * A key assigned to the tile. This is used by the tile source to determine
             * if this tile can effectively be used, or if a new tile should be created
             * and this one be used as an interim tile for this new tile.
             * @type {string}
             */
            _this.key = '';
            /**
             * The duration for the opacity transition.
             * @type {number}
             */
            _this.transition_ =
                options.transition === undefined ? 250 : options.transition;
            /**
             * Lookup of start times for rendering transitions.  If the start time is
             * equal to -1, the transition is complete.
             * @type {Object<string, number>}
             */
            _this.transitionStarts_ = {};
            return _this;
        }
        /**
         * @protected
         */
        Tile.prototype.changed = function () {
            this.dispatchEvent(EventType.CHANGE);
        };
        /**
         * Called by the tile cache when the tile is removed from the cache due to expiry
         */
        Tile.prototype.release = function () { };
        /**
         * @return {string} Key.
         */
        Tile.prototype.getKey = function () {
            return this.key + '/' + this.tileCoord;
        };
        /**
         * Get the interim tile most suitable for rendering using the chain of interim
         * tiles. This corresponds to the  most recent tile that has been loaded, if no
         * such tile exists, the original tile is returned.
         * @return {!Tile} Best tile for rendering.
         */
        Tile.prototype.getInterimTile = function () {
            if (!this.interimTile) {
                //empty chain
                return this;
            }
            var tile = this.interimTile;
            // find the first loaded tile and return it. Since the chain is sorted in
            // decreasing order of creation time, there is no need to search the remainder
            // of the list (all those tiles correspond to older requests and will be
            // cleaned up by refreshInterimChain)
            do {
                if (tile.getState() == TileState.LOADED) {
                    // Show tile immediately instead of fading it in after loading, because
                    // the interim tile is in place already
                    this.transition_ = 0;
                    return tile;
                }
                tile = tile.interimTile;
            } while (tile);
            // we can not find a better tile
            return this;
        };
        /**
         * Goes through the chain of interim tiles and discards sections of the chain
         * that are no longer relevant.
         */
        Tile.prototype.refreshInterimChain = function () {
            if (!this.interimTile) {
                return;
            }
            var tile = this.interimTile;
            var prev = /** @type {Tile} */ (this);
            do {
                if (tile.getState() == TileState.LOADED) {
                    //we have a loaded tile, we can discard the rest of the list
                    //we would could abort any LOADING tile request
                    //older than this tile (i.e. any LOADING tile following this entry in the chain)
                    tile.interimTile = null;
                    break;
                }
                else if (tile.getState() == TileState.LOADING) {
                    //keep this LOADING tile any loaded tiles later in the chain are
                    //older than this tile, so we're still interested in the request
                    prev = tile;
                }
                else if (tile.getState() == TileState.IDLE) {
                    //the head of the list is the most current tile, we don't need
                    //to start any other requests for this chain
                    prev.interimTile = tile.interimTile;
                }
                else {
                    prev = tile;
                }
                tile = prev.interimTile;
            } while (tile);
        };
        /**
         * Get the tile coordinate for this tile.
         * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
         * @api
         */
        Tile.prototype.getTileCoord = function () {
            return this.tileCoord;
        };
        /**
         * @return {import("./TileState.js").default} State.
         */
        Tile.prototype.getState = function () {
            return this.state;
        };
        /**
         * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
         * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
         * when the tile cannot be loaded. Otherwise the tile cannot be removed from
         * the tile queue and will block other requests.
         * @param {import("./TileState.js").default} state State.
         * @api
         */
        Tile.prototype.setState = function (state) {
            if (this.state !== TileState.ERROR && this.state > state) {
                throw new Error('Tile load sequence violation');
            }
            this.state = state;
            this.changed();
        };
        /**
         * Load the image or retry if loading previously failed.
         * Loading is taken care of by the tile queue, and calling this method is
         * only needed for preloading or for reloading in case of an error.
         * @abstract
         * @api
         */
        Tile.prototype.load = function () {
            abstract();
        };
        /**
         * Get the alpha value for rendering.
         * @param {string} id An id for the renderer.
         * @param {number} time The render frame time.
         * @return {number} A number between 0 and 1.
         */
        Tile.prototype.getAlpha = function (id, time) {
            if (!this.transition_) {
                return 1;
            }
            var start = this.transitionStarts_[id];
            if (!start) {
                start = time;
                this.transitionStarts_[id] = start;
            }
            else if (start === -1) {
                return 1;
            }
            var delta = time - start + 1000 / 60; // avoid rendering at 0
            if (delta >= this.transition_) {
                return 1;
            }
            return easeIn(delta / this.transition_);
        };
        /**
         * Determine if a tile is in an alpha transition.  A tile is considered in
         * transition if tile.getAlpha() has not yet been called or has been called
         * and returned 1.
         * @param {string} id An id for the renderer.
         * @return {boolean} The tile is in transition.
         */
        Tile.prototype.inTransition = function (id) {
            if (!this.transition_) {
                return false;
            }
            return this.transitionStarts_[id] !== -1;
        };
        /**
         * Mark a transition as complete.
         * @param {string} id An id for the renderer.
         */
        Tile.prototype.endTransition = function (id) {
            if (this.transition_) {
                this.transitionStarts_[id] = -1;
            }
        };
        return Tile;
    }(Target));

    /**
     * @module ol/structs/LRUCache
     */
    /**
     * @typedef {Object} Entry
     * @property {string} key_
     * @property {Object} newer
     * @property {Object} older
     * @property {*} value_
     */
    /**
     * @classdesc
     * Implements a Least-Recently-Used cache where the keys do not conflict with
     * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
     * items from the cache is the responsibility of the user.
     *
     * @fires import("../events/Event.js").default
     * @template T
     */
    var LRUCache = /** @class */ (function () {
        /**
         * @param {number=} opt_highWaterMark High water mark.
         */
        function LRUCache(opt_highWaterMark) {
            /**
             * Desired max cache size after expireCache(). If set to 0, no cache entries
             * will be pruned at all.
             * @type {number}
             */
            this.highWaterMark =
                opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;
            /**
             * @private
             * @type {number}
             */
            this.count_ = 0;
            /**
             * @private
             * @type {!Object<string, Entry>}
             */
            this.entries_ = {};
            /**
             * @private
             * @type {?Entry}
             */
            this.oldest_ = null;
            /**
             * @private
             * @type {?Entry}
             */
            this.newest_ = null;
        }
        /**
         * @return {boolean} Can expire cache.
         */
        LRUCache.prototype.canExpireCache = function () {
            return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
        };
        /**
         * FIXME empty description for jsdoc
         */
        LRUCache.prototype.clear = function () {
            this.count_ = 0;
            this.entries_ = {};
            this.oldest_ = null;
            this.newest_ = null;
        };
        /**
         * @param {string} key Key.
         * @return {boolean} Contains key.
         */
        LRUCache.prototype.containsKey = function (key) {
            return this.entries_.hasOwnProperty(key);
        };
        /**
         * @param {function(T, string, LRUCache<T>): ?} f The function
         *     to call for every entry from the oldest to the newer. This function takes
         *     3 arguments (the entry value, the entry key and the LRUCache object).
         *     The return value is ignored.
         */
        LRUCache.prototype.forEach = function (f) {
            var entry = this.oldest_;
            while (entry) {
                f(entry.value_, entry.key_, this);
                entry = entry.newer;
            }
        };
        /**
         * @param {string} key Key.
         * @param {*=} opt_options Options (reserverd for subclasses).
         * @return {T} Value.
         */
        LRUCache.prototype.get = function (key, opt_options) {
            var entry = this.entries_[key];
            assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
            if (entry === this.newest_) {
                return entry.value_;
            }
            else if (entry === this.oldest_) {
                this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);
                this.oldest_.older = null;
            }
            else {
                entry.newer.older = entry.older;
                entry.older.newer = entry.newer;
            }
            entry.newer = null;
            entry.older = this.newest_;
            this.newest_.newer = entry;
            this.newest_ = entry;
            return entry.value_;
        };
        /**
         * Remove an entry from the cache.
         * @param {string} key The entry key.
         * @return {T} The removed entry.
         */
        LRUCache.prototype.remove = function (key) {
            var entry = this.entries_[key];
            assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
            if (entry === this.newest_) {
                this.newest_ = /** @type {Entry} */ (entry.older);
                if (this.newest_) {
                    this.newest_.newer = null;
                }
            }
            else if (entry === this.oldest_) {
                this.oldest_ = /** @type {Entry} */ (entry.newer);
                if (this.oldest_) {
                    this.oldest_.older = null;
                }
            }
            else {
                entry.newer.older = entry.older;
                entry.older.newer = entry.newer;
            }
            delete this.entries_[key];
            --this.count_;
            return entry.value_;
        };
        /**
         * @return {number} Count.
         */
        LRUCache.prototype.getCount = function () {
            return this.count_;
        };
        /**
         * @return {Array<string>} Keys.
         */
        LRUCache.prototype.getKeys = function () {
            var keys = new Array(this.count_);
            var i = 0;
            var entry;
            for (entry = this.newest_; entry; entry = entry.older) {
                keys[i++] = entry.key_;
            }
            return keys;
        };
        /**
         * @return {Array<T>} Values.
         */
        LRUCache.prototype.getValues = function () {
            var values = new Array(this.count_);
            var i = 0;
            var entry;
            for (entry = this.newest_; entry; entry = entry.older) {
                values[i++] = entry.value_;
            }
            return values;
        };
        /**
         * @return {T} Last value.
         */
        LRUCache.prototype.peekLast = function () {
            return this.oldest_.value_;
        };
        /**
         * @return {string} Last key.
         */
        LRUCache.prototype.peekLastKey = function () {
            return this.oldest_.key_;
        };
        /**
         * Get the key of the newest item in the cache.  Throws if the cache is empty.
         * @return {string} The newest key.
         */
        LRUCache.prototype.peekFirstKey = function () {
            return this.newest_.key_;
        };
        /**
         * @return {T} value Value.
         */
        LRUCache.prototype.pop = function () {
            var entry = this.oldest_;
            delete this.entries_[entry.key_];
            if (entry.newer) {
                entry.newer.older = null;
            }
            this.oldest_ = /** @type {Entry} */ (entry.newer);
            if (!this.oldest_) {
                this.newest_ = null;
            }
            --this.count_;
            return entry.value_;
        };
        /**
         * @param {string} key Key.
         * @param {T} value Value.
         */
        LRUCache.prototype.replace = function (key, value) {
            this.get(key); // update `newest_`
            this.entries_[key].value_ = value;
        };
        /**
         * @param {string} key Key.
         * @param {T} value Value.
         */
        LRUCache.prototype.set = function (key, value) {
            assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already
            var entry = {
                key_: key,
                newer: null,
                older: this.newest_,
                value_: value,
            };
            if (!this.newest_) {
                this.oldest_ = entry;
            }
            else {
                this.newest_.newer = entry;
            }
            this.newest_ = entry;
            this.entries_[key] = entry;
            ++this.count_;
        };
        /**
         * Set a maximum number of entries for the cache.
         * @param {number} size Cache size.
         * @api
         */
        LRUCache.prototype.setSize = function (size) {
            this.highWaterMark = size;
        };
        return LRUCache;
    }());

    /**
     * @module ol/tilecoord
     */
    /**
     * An array of three numbers representing the location of a tile in a tile
     * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
     * @typedef {Array<number>} TileCoord
     * @api
     */
    /**
     * @param {number} z Z.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {TileCoord=} opt_tileCoord Tile coordinate.
     * @return {TileCoord} Tile coordinate.
     */
    function createOrUpdate(z, x, y, opt_tileCoord) {
        if (opt_tileCoord !== undefined) {
            opt_tileCoord[0] = z;
            opt_tileCoord[1] = x;
            opt_tileCoord[2] = y;
            return opt_tileCoord;
        }
        else {
            return [z, x, y];
        }
    }
    /**
     * @param {number} z Z.
     * @param {number} x X.
     * @param {number} y Y.
     * @return {string} Key.
     */
    function getKeyZXY(z, x, y) {
        return z + '/' + x + '/' + y;
    }
    /**
     * Get the key for a tile coord.
     * @param {TileCoord} tileCoord The tile coord.
     * @return {string} Key.
     */
    function getKey(tileCoord) {
        return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
    }
    /**
     * Get a tile coord given a key.
     * @param {string} key The tile coord key.
     * @return {TileCoord} The tile coord.
     */
    function fromKey(key) {
        return key.split('/').map(Number);
    }
    /**
     * @param {TileCoord} tileCoord Tile coord.
     * @return {number} Hash.
     */
    function hash(tileCoord) {
        return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
    }
    /**
     * @param {TileCoord} tileCoord Tile coordinate.
     * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
     * @return {boolean} Tile coordinate is within extent and zoom level range.
     */
    function withinExtentAndZ(tileCoord, tileGrid) {
        var z = tileCoord[0];
        var x = tileCoord[1];
        var y = tileCoord[2];
        if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
            return false;
        }
        var tileRange = tileGrid.getFullTileRange(z);
        if (!tileRange) {
            return true;
        }
        else {
            return tileRange.containsXY(x, y);
        }
    }

    var __extends$B = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TileCache = /** @class */ (function (_super) {
        __extends$B(TileCache, _super);
        function TileCache() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {!Object<string, boolean>} usedTiles Used tiles.
         */
        TileCache.prototype.expireCache = function (usedTiles) {
            while (this.canExpireCache()) {
                var tile = this.peekLast();
                if (tile.getKey() in usedTiles) {
                    break;
                }
                else {
                    this.pop().release();
                }
            }
        };
        /**
         * Prune all tiles from the cache that don't have the same z as the newest tile.
         */
        TileCache.prototype.pruneExceptNewestZ = function () {
            if (this.getCount() === 0) {
                return;
            }
            var key = this.peekFirstKey();
            var tileCoord = fromKey(key);
            var z = tileCoord[0];
            this.forEach(function (tile) {
                if (tile.tileCoord[0] !== z) {
                    this.remove(getKey(tile.tileCoord));
                    tile.release();
                }
            }.bind(this));
        };
        return TileCache;
    }(LRUCache));

    /**
     * @module ol/source/TileEventType
     */
    /**
     * @enum {string}
     */
    var TileEventType = {
        /**
         * Triggered when a tile starts loading.
         * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
         * @api
         */
        TILELOADSTART: 'tileloadstart',
        /**
         * Triggered when a tile finishes loading, either when its data is loaded,
         * or when loading was aborted because the tile is no longer needed.
         * @event module:ol/source/Tile.TileSourceEvent#tileloadend
         * @api
         */
        TILELOADEND: 'tileloadend',
        /**
         * Triggered if tile loading results in an error.
         * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
         * @api
         */
        TILELOADERROR: 'tileloaderror',
    };

    /**
     * @module ol/tilegrid/common
     */
    /**
     * Default maximum zoom for default tile grids.
     * @type {number}
     */
    var DEFAULT_MAX_ZOOM = 42;
    /**
     * Default tile size.
     * @type {number}
     */
    var DEFAULT_TILE_SIZE = 256;

    /**
     * @module ol/tilegrid/TileGrid
     */
    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */
    var tmpTileCoord = [0, 0, 0];
    /**
     * @typedef {Object} Options
     * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
     * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or
     * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
     * @property {number} [minZoom=0] Minimum zoom.
     * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
     * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
     * specified, `extent` or `origins` must be provided.
     * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
     * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
     * should match the length of the `resolutions` array, i.e. each resolution can have a different
     * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
     * `origin` must be provided.
     * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
     * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
     * array will have a length of `maxZoom + 1`.
     * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
     * of the grid for each zoom level. If specified the values
     * define each zoom level's extent together with the `origin` or `origins`.
     * A grid `extent` can be configured in addition, and will further limit the extent
     * for which tile requests are made by sources. If the bottom-left corner of
     * an extent is used as `origin` or `origins`, then the `y` value must be
     * negative because OpenLayers tile coordinates use the top left as the origin.
     * @property {number|import("../size.js").Size} [tileSize] Tile size.
     * Default is `[256, 256]`.
     * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
     * should match the length of the `resolutions` array, i.e. each resolution can have a different
     * tile size.
     */
    /**
     * @classdesc
     * Base class for setting the grid pattern for sources accessing tiled-image
     * servers.
     * @api
     */
    var TileGrid = /** @class */ (function () {
        /**
         * @param {Options} options Tile grid options.
         */
        function TileGrid(options) {
            /**
             * @protected
             * @type {number}
             */
            this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
            /**
             * @private
             * @type {!Array<number>}
             */
            this.resolutions_ = options.resolutions;
            assert(isSorted(this.resolutions_, function (a, b) {
                return b - a;
            }, true), 17); // `resolutions` must be sorted in descending order
            // check if we've got a consistent zoom factor and origin
            var zoomFactor;
            if (!options.origins) {
                for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
                    if (!zoomFactor) {
                        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
                    }
                    else {
                        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
                            zoomFactor = undefined;
                            break;
                        }
                    }
                }
            }
            /**
             * @private
             * @type {number|undefined}
             */
            this.zoomFactor_ = zoomFactor;
            /**
             * @protected
             * @type {number}
             */
            this.maxZoom = this.resolutions_.length - 1;
            /**
             * @private
             * @type {import("../coordinate.js").Coordinate}
             */
            this.origin_ = options.origin !== undefined ? options.origin : null;
            /**
             * @private
             * @type {Array<import("../coordinate.js").Coordinate>}
             */
            this.origins_ = null;
            if (options.origins !== undefined) {
                this.origins_ = options.origins;
                assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
            }
            var extent = options.extent;
            if (extent !== undefined && !this.origin_ && !this.origins_) {
                this.origin_ = getTopLeft(extent);
            }
            assert((!this.origin_ && this.origins_) || (this.origin_ && !this.origins_), 18); // Either `origin` or `origins` must be configured, never both
            /**
             * @private
             * @type {Array<number|import("../size.js").Size>}
             */
            this.tileSizes_ = null;
            if (options.tileSizes !== undefined) {
                this.tileSizes_ = options.tileSizes;
                assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
            }
            /**
             * @private
             * @type {number|import("../size.js").Size}
             */
            this.tileSize_ =
                options.tileSize !== undefined
                    ? options.tileSize
                    : !this.tileSizes_
                        ? DEFAULT_TILE_SIZE
                        : null;
            assert((!this.tileSize_ && this.tileSizes_) ||
                (this.tileSize_ && !this.tileSizes_), 22); // Either `tileSize` or `tileSizes` must be configured, never both
            /**
             * @private
             * @type {import("../extent.js").Extent}
             */
            this.extent_ = extent !== undefined ? extent : null;
            /**
             * @private
             * @type {Array<import("../TileRange.js").default>}
             */
            this.fullTileRanges_ = null;
            /**
             * @private
             * @type {import("../size.js").Size}
             */
            this.tmpSize_ = [0, 0];
            if (options.sizes !== undefined) {
                this.fullTileRanges_ = options.sizes.map(function (size, z) {
                    var tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
                    if (extent) {
                        var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
                        tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
                        tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
                        tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
                        tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
                    }
                    return tileRange;
                }, this);
            }
            else if (extent) {
                this.calculateTileRanges_(extent);
            }
        }
        /**
         * Call a function with each tile coordinate for a given extent and zoom level.
         *
         * @param {import("../extent.js").Extent} extent Extent.
         * @param {number} zoom Integer zoom level.
         * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
         * @api
         */
        TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {
            var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
            for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
                for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
                    callback([zoom, i, j]);
                }
            }
        };
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
         * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
         * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
         * @return {boolean} Callback succeeded.
         */
        TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {
            var tileRange, x, y;
            var tileCoordExtent = null;
            var z = tileCoord[0] - 1;
            if (this.zoomFactor_ === 2) {
                x = tileCoord[1];
                y = tileCoord[2];
            }
            else {
                tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
            }
            while (z >= this.minZoom) {
                if (this.zoomFactor_ === 2) {
                    x = Math.floor(x / 2);
                    y = Math.floor(y / 2);
                    tileRange = createOrUpdate$1(x, x, y, y, opt_tileRange);
                }
                else {
                    tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
                }
                if (callback(z, tileRange)) {
                    return true;
                }
                --z;
            }
            return false;
        };
        /**
         * Get the extent for this tile grid, if it was configured.
         * @return {import("../extent.js").Extent} Extent.
         * @api
         */
        TileGrid.prototype.getExtent = function () {
            return this.extent_;
        };
        /**
         * Get the maximum zoom level for the grid.
         * @return {number} Max zoom.
         * @api
         */
        TileGrid.prototype.getMaxZoom = function () {
            return this.maxZoom;
        };
        /**
         * Get the minimum zoom level for the grid.
         * @return {number} Min zoom.
         * @api
         */
        TileGrid.prototype.getMinZoom = function () {
            return this.minZoom;
        };
        /**
         * Get the origin for the grid at the given zoom level.
         * @param {number} z Integer zoom level.
         * @return {import("../coordinate.js").Coordinate} Origin.
         * @api
         */
        TileGrid.prototype.getOrigin = function (z) {
            if (this.origin_) {
                return this.origin_;
            }
            else {
                return this.origins_[z];
            }
        };
        /**
         * Get the resolution for the given zoom level.
         * @param {number} z Integer zoom level.
         * @return {number} Resolution.
         * @api
         */
        TileGrid.prototype.getResolution = function (z) {
            return this.resolutions_[z];
        };
        /**
         * Get the list of resolutions for the tile grid.
         * @return {Array<number>} Resolutions.
         * @api
         */
        TileGrid.prototype.getResolutions = function () {
            return this.resolutions_;
        };
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
         * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
         * @return {import("../TileRange.js").default} Tile range.
         */
        TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {
            if (tileCoord[0] < this.maxZoom) {
                if (this.zoomFactor_ === 2) {
                    var minX = tileCoord[1] * 2;
                    var minY = tileCoord[2] * 2;
                    return createOrUpdate$1(minX, minX + 1, minY, minY + 1, opt_tileRange);
                }
                var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
                return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
            }
            return null;
        };
        /**
         * Get the extent for a tile range.
         * @param {number} z Integer zoom level.
         * @param {import("../TileRange.js").default} tileRange Tile range.
         * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
         * @return {import("../extent.js").Extent} Extent.
         */
        TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {
            var origin = this.getOrigin(z);
            var resolution = this.getResolution(z);
            var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
            var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
            var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
            var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
            var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
            return createOrUpdate$2(minX, minY, maxX, maxY, opt_extent);
        };
        /**
         * Get a tile range for the given extent and integer zoom level.
         * @param {import("../extent.js").Extent} extent Extent.
         * @param {number} z Integer zoom level.
         * @param {import("../TileRange.js").default=} opt_tileRange Temporary tile range object.
         * @return {import("../TileRange.js").default} Tile range.
         */
        TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {
            var tileCoord = tmpTileCoord;
            this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);
            var minX = tileCoord[1];
            var minY = tileCoord[2];
            this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);
            return createOrUpdate$1(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
        };
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @return {import("../coordinate.js").Coordinate} Tile center.
         */
        TileGrid.prototype.getTileCoordCenter = function (tileCoord) {
            var origin = this.getOrigin(tileCoord[0]);
            var resolution = this.getResolution(tileCoord[0]);
            var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
            return [
                origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
                origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,
            ];
        };
        /**
         * Get the extent of a tile coordinate.
         *
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @param {import("../extent.js").Extent=} opt_extent Temporary extent object.
         * @return {import("../extent.js").Extent} Extent.
         * @api
         */
        TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {
            var origin = this.getOrigin(tileCoord[0]);
            var resolution = this.getResolution(tileCoord[0]);
            var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
            var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
            var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
            var maxX = minX + tileSize[0] * resolution;
            var maxY = minY + tileSize[1] * resolution;
            return createOrUpdate$2(minX, minY, maxX, maxY, opt_extent);
        };
        /**
         * Get the tile coordinate for the given map coordinate and resolution.  This
         * method considers that coordinates that intersect tile boundaries should be
         * assigned the higher tile coordinate.
         *
         * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
         * @param {number} resolution Resolution.
         * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
         * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
         * @api
         */
        TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {
            return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
        };
        /**
         * Note that this method should not be called for resolutions that correspond
         * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
         * @param {number} x X.
         * @param {number} y Y.
         * @param {number} resolution Resolution (for a non-integer zoom level).
         * @param {boolean} reverseIntersectionPolicy Instead of letting edge
         *     intersections go to the higher tile coordinate, let edge intersections
         *     go to the lower tile coordinate.
         * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
         * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
         * @private
         */
        TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
            var z = this.getZForResolution(resolution);
            var scale = resolution / this.getResolution(z);
            var origin = this.getOrigin(z);
            var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
            var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
            var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
            var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
            var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
            var tileCoordX = (scale * xFromOrigin) / tileSize[0];
            var tileCoordY = (scale * yFromOrigin) / tileSize[1];
            if (reverseIntersectionPolicy) {
                tileCoordX = Math.ceil(tileCoordX) - 1;
                tileCoordY = Math.ceil(tileCoordY) - 1;
            }
            else {
                tileCoordX = Math.floor(tileCoordX);
                tileCoordY = Math.floor(tileCoordY);
            }
            return createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
        };
        /**
         * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
         * they should have separate implementations.  This method is for integer zoom
         * levels.  The other method should only be called for resolutions corresponding
         * to non-integer zoom levels.
         * @param {number} x Map x coordinate.
         * @param {number} y Map y coordinate.
         * @param {number} z Integer zoom level.
         * @param {boolean} reverseIntersectionPolicy Instead of letting edge
         *     intersections go to the higher tile coordinate, let edge intersections
         *     go to the lower tile coordinate.
         * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
         * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
         * @private
         */
        TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
            var origin = this.getOrigin(z);
            var resolution = this.getResolution(z);
            var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
            var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
            var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
            var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
            var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
            var tileCoordX = xFromOrigin / tileSize[0];
            var tileCoordY = yFromOrigin / tileSize[1];
            if (reverseIntersectionPolicy) {
                tileCoordX = Math.ceil(tileCoordX) - 1;
                tileCoordY = Math.ceil(tileCoordY) - 1;
            }
            else {
                tileCoordX = Math.floor(tileCoordX);
                tileCoordY = Math.floor(tileCoordY);
            }
            return createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
        };
        /**
         * Get a tile coordinate given a map coordinate and zoom level.
         * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
         * @param {number} z Zoom level.
         * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
         * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
         * @api
         */
        TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {
            return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
        };
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @return {number} Tile resolution.
         */
        TileGrid.prototype.getTileCoordResolution = function (tileCoord) {
            return this.resolutions_[tileCoord[0]];
        };
        /**
         * Get the tile size for a zoom level. The type of the return value matches the
         * `tileSize` or `tileSizes` that the tile grid was configured with. To always
         * get an `import("../size.js").Size`, run the result through `import("../size.js").Size.toSize()`.
         * @param {number} z Z.
         * @return {number|import("../size.js").Size} Tile size.
         * @api
         */
        TileGrid.prototype.getTileSize = function (z) {
            if (this.tileSize_) {
                return this.tileSize_;
            }
            else {
                return this.tileSizes_[z];
            }
        };
        /**
         * @param {number} z Zoom level.
         * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
         */
        TileGrid.prototype.getFullTileRange = function (z) {
            if (!this.fullTileRanges_) {
                return this.extent_
                    ? this.getTileRangeForExtentAndZ(this.extent_, z)
                    : null;
            }
            else {
                return this.fullTileRanges_[z];
            }
        };
        /**
         * @param {number} resolution Resolution.
         * @param {number=} opt_direction If 0, the nearest resolution will be used.
         *     If 1, the nearest lower resolution will be used. If -1, the nearest
         *     higher resolution will be used. Default is 0.
         * @return {number} Z.
         * @api
         */
        TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {
            var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);
            return clamp(z, this.minZoom, this.maxZoom);
        };
        /**
         * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
         * @private
         */
        TileGrid.prototype.calculateTileRanges_ = function (extent) {
            var length = this.resolutions_.length;
            var fullTileRanges = new Array(length);
            for (var z = this.minZoom; z < length; ++z) {
                fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
            }
            this.fullTileRanges_ = fullTileRanges;
        };
        return TileGrid;
    }());

    /**
     * @module ol/tilegrid
     */
    /**
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {!TileGrid} Default tile grid for the
     * passed projection.
     */
    function getForProjection(projection) {
        var tileGrid = projection.getDefaultTileGrid();
        if (!tileGrid) {
            tileGrid = createForProjection(projection);
            projection.setDefaultTileGrid(tileGrid);
        }
        return tileGrid;
    }
    /**
     * @param {TileGrid} tileGrid Tile grid.
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
     */
    function wrapX(tileGrid, tileCoord, projection) {
        var z = tileCoord[0];
        var center = tileGrid.getTileCoordCenter(tileCoord);
        var projectionExtent = extentFromProjection(projection);
        if (!containsCoordinate(projectionExtent, center)) {
            var worldWidth = getWidth(projectionExtent);
            var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
            center[0] += worldWidth * worldsAway;
            return tileGrid.getTileCoordForCoordAndZ(center, z);
        }
        else {
            return tileCoord;
        }
    }
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number=} opt_maxZoom Maximum zoom level (default is
     *     DEFAULT_MAX_ZOOM).
     * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
     *     DEFAULT_TILE_SIZE).
     * @param {import("./extent/Corner.js").default=} opt_corner Extent corner (default is `'top-left'`).
     * @return {!TileGrid} TileGrid instance.
     */
    function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
        var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;
        var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);
        return new TileGrid({
            extent: extent,
            origin: getCorner(extent, corner),
            resolutions: resolutions,
            tileSize: opt_tileSize,
        });
    }
    /**
     * @typedef {Object} XYZOptions
     * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
     * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
     * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
     * @property {number} [maxResolution] Resolution at level zero.
     * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
     * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
     * @property {number} [minZoom=0] Minimum zoom.
     * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
     */
    /**
     * Creates a tile grid with a standard XYZ tiling scheme.
     * @param {XYZOptions=} opt_options Tile grid options.
     * @return {!TileGrid} Tile grid instance.
     * @api
     */
    function createXYZ(opt_options) {
        var xyzOptions = opt_options || {};
        var extent = xyzOptions.extent || get$1('EPSG:3857').getExtent();
        var gridOptions = {
            extent: extent,
            minZoom: xyzOptions.minZoom,
            tileSize: xyzOptions.tileSize,
            resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution),
        };
        return new TileGrid(gridOptions);
    }
    /**
     * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number=} opt_maxZoom Maximum zoom level (default is
     *     DEFAULT_MAX_ZOOM).
     * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
     *     DEFAULT_TILE_SIZE).
     * @param {number=} opt_maxResolution Resolution at level zero.
     * @return {!Array<number>} Resolutions array.
     */
    function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {
        var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;
        var height = getHeight(extent);
        var width = getWidth(extent);
        var tileSize = toSize(opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE);
        var maxResolution = opt_maxResolution > 0
            ? opt_maxResolution
            : Math.max(width / tileSize[0], height / tileSize[1]);
        var length = maxZoom + 1;
        var resolutions = new Array(length);
        for (var z = 0; z < length; ++z) {
            resolutions[z] = maxResolution / Math.pow(2, z);
        }
        return resolutions;
    }
    /**
     * @param {import("./proj.js").ProjectionLike} projection Projection.
     * @param {number=} opt_maxZoom Maximum zoom level (default is
     *     DEFAULT_MAX_ZOOM).
     * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
     *     DEFAULT_TILE_SIZE).
     * @param {import("./extent/Corner.js").default=} opt_corner Extent corner (default is `'top-left'`).
     * @return {!TileGrid} TileGrid instance.
     */
    function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
        var extent = extentFromProjection(projection);
        return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
    }
    /**
     * Generate a tile grid extent from a projection.  If the projection has an
     * extent, it is used.  If not, a global extent is assumed.
     * @param {import("./proj.js").ProjectionLike} projection Projection.
     * @return {import("./extent.js").Extent} Extent.
     */
    function extentFromProjection(projection) {
        projection = get$1(projection);
        var extent = projection.getExtent();
        if (!extent) {
            var half = (180 * METERS_PER_UNIT$1[Units.DEGREES]) / projection.getMetersPerUnit();
            extent = createOrUpdate$2(-half, -half, half, half);
        }
        return extent;
    }

    var __extends$A = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {import("./Source.js").AttributionLike} [attributions]
     * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
     * @property {number} [cacheSize]
     * @property {boolean} [opaque=false] Whether the layer is opaque.
     * @property {number} [tilePixelRatio]
     * @property {import("../proj.js").ProjectionLike} [projection]
     * @property {import("./State.js").default} [state]
     * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
     * @property {boolean} [wrapX=true]
     * @property {number} [transition]
     * @property {string} [key]
     * @property {number} [zDirection=0]
     */
    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Base class for sources providing images divided into a tile grid.
     * @abstract
     * @api
     */
    var TileSource = /** @class */ (function (_super) {
        __extends$A(TileSource, _super);
        /**
         * @param {Options} options SourceTile source options.
         */
        function TileSource(options) {
            var _this = _super.call(this, {
                attributions: options.attributions,
                attributionsCollapsible: options.attributionsCollapsible,
                projection: options.projection,
                state: options.state,
                wrapX: options.wrapX,
            }) || this;
            /**
             * @private
             * @type {boolean}
             */
            _this.opaque_ = options.opaque !== undefined ? options.opaque : false;
            /**
             * @private
             * @type {number}
             */
            _this.tilePixelRatio_ =
                options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
            /**
             * @protected
             * @type {import("../tilegrid/TileGrid.js").default}
             */
            _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
            var tileSize = [256, 256];
            var tileGrid = options.tileGrid;
            if (tileGrid) {
                toSize(tileGrid.getTileSize(tileGrid.getMinZoom()), tileSize);
            }
            /**
             * @protected
             * @type {import("../TileCache.js").default}
             */
            _this.tileCache = new TileCache(options.cacheSize || 0);
            /**
             * @protected
             * @type {import("../size.js").Size}
             */
            _this.tmpSize = [0, 0];
            /**
             * @private
             * @type {string}
             */
            _this.key_ = options.key || '';
            /**
             * @protected
             * @type {import("../Tile.js").Options}
             */
            _this.tileOptions = { transition: options.transition };
            /**
             * zDirection hint, read by the renderer. Indicates which resolution should be used
             * by a renderer if the views resolution does not match any resolution of the tile source.
             * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
             * will be used. If -1, the nearest higher resolution will be used.
             * @type {number}
             */
            _this.zDirection = options.zDirection ? options.zDirection : 0;
            return _this;
        }
        /**
         * @return {boolean} Can expire cache.
         */
        TileSource.prototype.canExpireCache = function () {
            return this.tileCache.canExpireCache();
        };
        /**
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @param {!Object<string, boolean>} usedTiles Used tiles.
         */
        TileSource.prototype.expireCache = function (projection, usedTiles) {
            var tileCache = this.getTileCacheForProjection(projection);
            if (tileCache) {
                tileCache.expireCache(usedTiles);
            }
        };
        /**
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @param {number} z Zoom level.
         * @param {import("../TileRange.js").default} tileRange Tile range.
         * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
         *     loaded tile.  If the callback returns `false`, the tile will not be
         *     considered loaded.
         * @return {boolean} The tile range is fully covered with loaded tiles.
         */
        TileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {
            var tileCache = this.getTileCacheForProjection(projection);
            if (!tileCache) {
                return false;
            }
            var covered = true;
            var tile, tileCoordKey, loaded;
            for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
                for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
                    tileCoordKey = getKeyZXY(z, x, y);
                    loaded = false;
                    if (tileCache.containsKey(tileCoordKey)) {
                        tile = /** @type {!import("../Tile.js").default} */ (tileCache.get(tileCoordKey));
                        loaded = tile.getState() === TileState.LOADED;
                        if (loaded) {
                            loaded = callback(tile) !== false;
                        }
                    }
                    if (!loaded) {
                        covered = false;
                    }
                }
            }
            return covered;
        };
        /**
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {number} Gutter.
         */
        TileSource.prototype.getGutterForProjection = function (projection) {
            return 0;
        };
        /**
         * Return the key to be used for all tiles in the source.
         * @return {string} The key for all tiles.
         * @protected
         */
        TileSource.prototype.getKey = function () {
            return this.key_;
        };
        /**
         * Set the value to be used as the key for all tiles in the source.
         * @param {string} key The key for tiles.
         * @protected
         */
        TileSource.prototype.setKey = function (key) {
            if (this.key_ !== key) {
                this.key_ = key;
                this.changed();
            }
        };
        /**
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {boolean} Opaque.
         */
        TileSource.prototype.getOpaque = function (projection) {
            return this.opaque_;
        };
        /**
         * @return {Array<number>} Resolutions.
         */
        TileSource.prototype.getResolutions = function () {
            return this.tileGrid.getResolutions();
        };
        /**
         * @abstract
         * @param {number} z Tile coordinate z.
         * @param {number} x Tile coordinate x.
         * @param {number} y Tile coordinate y.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {!import("../Tile.js").default} Tile.
         */
        TileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {
            return abstract();
        };
        /**
         * Return the tile grid of the tile source.
         * @return {import("../tilegrid/TileGrid.js").default} Tile grid.
         * @api
         */
        TileSource.prototype.getTileGrid = function () {
            return this.tileGrid;
        };
        /**
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
         */
        TileSource.prototype.getTileGridForProjection = function (projection) {
            if (!this.tileGrid) {
                return getForProjection(projection);
            }
            else {
                return this.tileGrid;
            }
        };
        /**
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {import("../TileCache.js").default} Tile cache.
         * @protected
         */
        TileSource.prototype.getTileCacheForProjection = function (projection) {
            assert(equivalent(this.getProjection(), projection), 68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
            );
            return this.tileCache;
        };
        /**
         * Get the tile pixel ratio for this source. Subclasses may override this
         * method, which is meant to return a supported pixel ratio that matches the
         * provided `pixelRatio` as close as possible.
         * @param {number} pixelRatio Pixel ratio.
         * @return {number} Tile pixel ratio.
         */
        TileSource.prototype.getTilePixelRatio = function (pixelRatio) {
            return this.tilePixelRatio_;
        };
        /**
         * @param {number} z Z.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {import("../size.js").Size} Tile size.
         */
        TileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
            var tileGrid = this.getTileGridForProjection(projection);
            var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
            var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
            if (tilePixelRatio == 1) {
                return tileSize;
            }
            else {
                return scale(tileSize, tilePixelRatio, this.tmpSize);
            }
        };
        /**
         * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
         * is outside the resolution and extent range of the tile grid, `null` will be
         * returned.
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @param {import("../proj/Projection.js").default=} opt_projection Projection.
         * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
         *     null if no tile URL should be created for the passed `tileCoord`.
         */
        TileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {
            var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
            var tileGrid = this.getTileGridForProjection(projection);
            if (this.getWrapX() && projection.isGlobal()) {
                tileCoord = wrapX(tileGrid, tileCoord, projection);
            }
            return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
        };
        /**
         * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
         * @api
         */
        TileSource.prototype.clear = function () {
            this.tileCache.clear();
        };
        TileSource.prototype.refresh = function () {
            this.clear();
            _super.prototype.refresh.call(this);
        };
        /**
         * Increases the cache size if needed
         * @param {number} tileCount Minimum number of tiles needed.
         * @param {import("../proj/Projection.js").default} projection Projection.
         */
        TileSource.prototype.updateCacheSize = function (tileCount, projection) {
            var tileCache = this.getTileCacheForProjection(projection);
            if (tileCount > tileCache.highWaterMark) {
                tileCache.highWaterMark = tileCount;
            }
        };
        /**
         * Marks a tile coord as being used, without triggering a load.
         * @abstract
         * @param {number} z Tile coordinate z.
         * @param {number} x Tile coordinate x.
         * @param {number} y Tile coordinate y.
         * @param {import("../proj/Projection.js").default} projection Projection.
         */
        TileSource.prototype.useTile = function (z, x, y, projection) { };
        return TileSource;
    }(Source));
    /**
     * @classdesc
     * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
     * type.
     */
    var TileSourceEvent = /** @class */ (function (_super) {
        __extends$A(TileSourceEvent, _super);
        /**
         * @param {string} type Type.
         * @param {import("../Tile.js").default} tile The tile.
         */
        function TileSourceEvent(type, tile) {
            var _this = _super.call(this, type) || this;
            /**
             * The tile related to the event.
             * @type {import("../Tile.js").default}
             * @api
             */
            _this.tile = tile;
            return _this;
        }
        return TileSourceEvent;
    }(BaseEvent));

    /**
     * @module ol/tileurlfunction
     */
    /**
     * @param {string} template Template.
     * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
     * @return {import("./Tile.js").UrlFunction} Tile URL function.
     */
    function createFromTemplate(template, tileGrid) {
        var zRegEx = /\{z\}/g;
        var xRegEx = /\{x\}/g;
        var yRegEx = /\{y\}/g;
        var dashYRegEx = /\{-y\}/g;
        return (
        /**
         * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("./proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function (tileCoord, pixelRatio, projection) {
            if (!tileCoord) {
                return undefined;
            }
            else {
                return template
                    .replace(zRegEx, tileCoord[0].toString())
                    .replace(xRegEx, tileCoord[1].toString())
                    .replace(yRegEx, tileCoord[2].toString())
                    .replace(dashYRegEx, function () {
                    var z = tileCoord[0];
                    var range = tileGrid.getFullTileRange(z);
                    assert(range, 55); // The {-y} placeholder requires a tile grid with extent
                    var y = range.getHeight() - tileCoord[2] - 1;
                    return y.toString();
                });
            }
        });
    }
    /**
     * @param {Array<string>} templates Templates.
     * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
     * @return {import("./Tile.js").UrlFunction} Tile URL function.
     */
    function createFromTemplates(templates, tileGrid) {
        var len = templates.length;
        var tileUrlFunctions = new Array(len);
        for (var i = 0; i < len; ++i) {
            tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
        }
        return createFromTileUrlFunctions(tileUrlFunctions);
    }
    /**
     * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
     * @return {import("./Tile.js").UrlFunction} Tile URL function.
     */
    function createFromTileUrlFunctions(tileUrlFunctions) {
        if (tileUrlFunctions.length === 1) {
            return tileUrlFunctions[0];
        }
        return (
        /**
         * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("./proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function (tileCoord, pixelRatio, projection) {
            if (!tileCoord) {
                return undefined;
            }
            else {
                var h = hash(tileCoord);
                var index = modulo(h, tileUrlFunctions.length);
                return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
            }
        });
    }
    /**
     * @param {string} url URL.
     * @return {Array<string>} Array of urls.
     */
    function expandUrl(url) {
        var urls = [];
        var match = /\{([a-z])-([a-z])\}/.exec(url);
        if (match) {
            // char range
            var startCharCode = match[1].charCodeAt(0);
            var stopCharCode = match[2].charCodeAt(0);
            var charCode = void 0;
            for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
                urls.push(url.replace(match[0], String.fromCharCode(charCode)));
            }
            return urls;
        }
        match = /\{(\d+)-(\d+)\}/.exec(url);
        if (match) {
            // number range
            var stop_1 = parseInt(match[2], 10);
            for (var i = parseInt(match[1], 10); i <= stop_1; i++) {
                urls.push(url.replace(match[0], i.toString()));
            }
            return urls;
        }
        urls.push(url);
        return urls;
    }

    var __extends$z = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {import("./Source.js").AttributionLike} [attributions]
     * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
     * @property {number} [cacheSize]
     * @property {boolean} [opaque=false] Whether the layer is opaque.
     * @property {import("../proj.js").ProjectionLike} [projection]
     * @property {import("./State.js").default} [state]
     * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
     * @property {import("../Tile.js").LoadFunction} tileLoadFunction
     * @property {number} [tilePixelRatio]
     * @property {import("../Tile.js").UrlFunction} [tileUrlFunction]
     * @property {string} [url]
     * @property {Array<string>} [urls]
     * @property {boolean} [wrapX=true]
     * @property {number} [transition]
     * @property {string} [key]
     * @property {number} [zDirection=0]
     */
    /**
     * @classdesc
     * Base class for sources providing tiles divided into a tile grid over http.
     *
     * @fires import("./Tile.js").TileSourceEvent
     */
    var UrlTile = /** @class */ (function (_super) {
        __extends$z(UrlTile, _super);
        /**
         * @param {Options} options Image tile options.
         */
        function UrlTile(options) {
            var _this = _super.call(this, {
                attributions: options.attributions,
                cacheSize: options.cacheSize,
                opaque: options.opaque,
                projection: options.projection,
                state: options.state,
                tileGrid: options.tileGrid,
                tilePixelRatio: options.tilePixelRatio,
                wrapX: options.wrapX,
                transition: options.transition,
                key: options.key,
                attributionsCollapsible: options.attributionsCollapsible,
                zDirection: options.zDirection,
            }) || this;
            /**
             * @private
             * @type {boolean}
             */
            _this.generateTileUrlFunction_ =
                _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
            /**
             * @protected
             * @type {import("../Tile.js").LoadFunction}
             */
            _this.tileLoadFunction = options.tileLoadFunction;
            if (options.tileUrlFunction) {
                _this.tileUrlFunction = options.tileUrlFunction;
            }
            /**
             * @protected
             * @type {!Array<string>|null}
             */
            _this.urls = null;
            if (options.urls) {
                _this.setUrls(options.urls);
            }
            else if (options.url) {
                _this.setUrl(options.url);
            }
            /**
             * @private
             * @type {!Object<string, boolean>}
             */
            _this.tileLoadingKeys_ = {};
            return _this;
        }
        /**
         * Return the tile load function of the source.
         * @return {import("../Tile.js").LoadFunction} TileLoadFunction
         * @api
         */
        UrlTile.prototype.getTileLoadFunction = function () {
            return this.tileLoadFunction;
        };
        /**
         * Return the tile URL function of the source.
         * @return {import("../Tile.js").UrlFunction} TileUrlFunction
         * @api
         */
        UrlTile.prototype.getTileUrlFunction = function () {
            return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction
                ? this.tileUrlFunction.bind(this)
                : this.tileUrlFunction;
        };
        /**
         * Return the URLs used for this source.
         * When a tileUrlFunction is used instead of url or urls,
         * null will be returned.
         * @return {!Array<string>|null} URLs.
         * @api
         */
        UrlTile.prototype.getUrls = function () {
            return this.urls;
        };
        /**
         * Handle tile change events.
         * @param {import("../events/Event.js").default} event Event.
         * @protected
         */
        UrlTile.prototype.handleTileChange = function (event) {
            var tile = /** @type {import("../Tile.js").default} */ (event.target);
            var uid = getUid(tile);
            var tileState = tile.getState();
            var type;
            if (tileState == TileState.LOADING) {
                this.tileLoadingKeys_[uid] = true;
                type = TileEventType.TILELOADSTART;
            }
            else if (uid in this.tileLoadingKeys_) {
                delete this.tileLoadingKeys_[uid];
                type =
                    tileState == TileState.ERROR
                        ? TileEventType.TILELOADERROR
                        : tileState == TileState.LOADED
                            ? TileEventType.TILELOADEND
                            : undefined;
            }
            if (type != undefined) {
                this.dispatchEvent(new TileSourceEvent(type, tile));
            }
        };
        /**
         * Set the tile load function of the source.
         * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
         * @api
         */
        UrlTile.prototype.setTileLoadFunction = function (tileLoadFunction) {
            this.tileCache.clear();
            this.tileLoadFunction = tileLoadFunction;
            this.changed();
        };
        /**
         * Set the tile URL function of the source.
         * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
         * @param {string=} key Optional new tile key for the source.
         * @api
         */
        UrlTile.prototype.setTileUrlFunction = function (tileUrlFunction, key) {
            this.tileUrlFunction = tileUrlFunction;
            this.tileCache.pruneExceptNewestZ();
            if (typeof key !== 'undefined') {
                this.setKey(key);
            }
            else {
                this.changed();
            }
        };
        /**
         * Set the URL to use for requests.
         * @param {string} url URL.
         * @api
         */
        UrlTile.prototype.setUrl = function (url) {
            var urls = expandUrl(url);
            this.urls = urls;
            this.setUrls(urls);
        };
        /**
         * Set the URLs to use for requests.
         * @param {Array<string>} urls URLs.
         * @api
         */
        UrlTile.prototype.setUrls = function (urls) {
            this.urls = urls;
            var key = urls.join('\n');
            if (this.generateTileUrlFunction_) {
                this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
            }
            else {
                this.setKey(key);
            }
        };
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        UrlTile.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {
            return undefined;
        };
        /**
         * Marks a tile coord as being used, without triggering a load.
         * @param {number} z Tile coordinate z.
         * @param {number} x Tile coordinate x.
         * @param {number} y Tile coordinate y.
         */
        UrlTile.prototype.useTile = function (z, x, y) {
            var tileCoordKey = getKeyZXY(z, x, y);
            if (this.tileCache.containsKey(tileCoordKey)) {
                this.tileCache.get(tileCoordKey);
            }
        };
        return UrlTile;
    }(TileSource));

    var __extends$y = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef HitMatch
     * @property {import("../Feature.js").FeatureLike} feature
     * @property {import("../layer/Layer.js").default} layer
     * @property {import("../geom/SimpleGeometry.js").default} geometry
     * @property {number} distanceSq
     * @property {import("./vector.js").FeatureCallback<T>} callback
     * @template T
     */
    /**
     * @abstract
     */
    var MapRenderer = /** @class */ (function (_super) {
        __extends$y(MapRenderer, _super);
        /**
         * @param {import("../PluggableMap.js").default} map Map.
         */
        function MapRenderer(map) {
            var _this = _super.call(this) || this;
            /**
             * @private
             * @type {import("../PluggableMap.js").default}
             */
            _this.map_ = map;
            return _this;
        }
        /**
         * @abstract
         * @param {import("../render/EventType.js").default} type Event type.
         * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
         */
        MapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
            abstract();
        };
        /**
         * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
         * @protected
         */
        MapRenderer.prototype.calculateMatrices2D = function (frameState) {
            var viewState = frameState.viewState;
            var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
            var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
            compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
            makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
        };
        /**
         * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
         * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
         * @param {number} hitTolerance Hit tolerance in pixels.
         * @param {boolean} checkWrapped Check for wrapped geometries.
         * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
         * @param {S} thisArg Value to use as `this` when executing `callback`.
         * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
         *     function, only layers which are visible and for which this function
         *     returns `true` will be tested for features.  By default, all visible
         *     layers will be tested.
         * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
         * @return {T|undefined} Callback result.
         * @template S,T,U
         */
        MapRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
            var result;
            var viewState = frameState.viewState;
            /**
             * @param {boolean} managed Managed layer.
             * @param {import("../Feature.js").FeatureLike} feature Feature.
             * @param {import("../layer/Layer.js").default} layer Layer.
             * @param {import("../geom/Geometry.js").default} geometry Geometry.
             * @return {T|undefined} Callback result.
             */
            function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
                return callback.call(thisArg, feature, managed ? layer : null, geometry);
            }
            var projection = viewState.projection;
            var translatedCoordinate = wrapX$1(coordinate.slice(), projection);
            var offsets = [[0, 0]];
            if (projection.canWrapX() && checkWrapped) {
                var projectionExtent = projection.getExtent();
                var worldWidth = getWidth(projectionExtent);
                offsets.push([-worldWidth, 0], [worldWidth, 0]);
            }
            var layerStates = frameState.layerStatesArray;
            var numLayers = layerStates.length;
            var matches = /** @type {Array<HitMatch<T>>} */ ([]);
            var tmpCoord = [];
            for (var i = 0; i < offsets.length; i++) {
                for (var j = numLayers - 1; j >= 0; --j) {
                    var layerState = layerStates[j];
                    var layer = layerState.layer;
                    if (layer.hasRenderer() &&
                        inView(layerState, viewState) &&
                        layerFilter.call(thisArg2, layer)) {
                        var layerRenderer = layer.getRenderer();
                        var source = layer.getSource();
                        if (layerRenderer && source) {
                            var coordinates = source.getWrapX()
                                ? translatedCoordinate
                                : coordinate;
                            var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
                            tmpCoord[0] = coordinates[0] + offsets[i][0];
                            tmpCoord[1] = coordinates[1] + offsets[i][1];
                            result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);
                        }
                        if (result) {
                            return result;
                        }
                    }
                }
            }
            if (matches.length === 0) {
                return undefined;
            }
            var order = 1 / matches.length;
            matches.forEach(function (m, i) { return (m.distanceSq += i * order); });
            matches.sort(function (a, b) { return a.distanceSq - b.distanceSq; });
            matches.some(function (m) {
                return (result = m.callback(m.feature, m.layer, m.geometry));
            });
            return result;
        };
        /**
         * @abstract
         * @param {import("../pixel.js").Pixel} pixel Pixel.
         * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
         * @param {number} hitTolerance Hit tolerance in pixels.
         * @param {function(import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
         *     callback.
         * @param {function(import("../layer/Layer.js").default): boolean} layerFilter Layer filter
         *     function, only layers which are visible and for which this function
         *     returns `true` will be tested for features.  By default, all visible
         *     layers will be tested.
         * @return {T|undefined} Callback result.
         * @template T
         */
        MapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
            return abstract();
        };
        /**
         * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
         * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
         * @param {number} hitTolerance Hit tolerance in pixels.
         * @param {boolean} checkWrapped Check for wrapped geometries.
         * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
         *     function, only layers which are visible and for which this function
         *     returns `true` will be tested for features.  By default, all visible
         *     layers will be tested.
         * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
         * @return {boolean} Is there a feature at the given coordinate?
         * @template U
         */
        MapRenderer.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
            var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);
            return hasFeature !== undefined;
        };
        /**
         * @return {import("../PluggableMap.js").default} Map.
         */
        MapRenderer.prototype.getMap = function () {
            return this.map_;
        };
        /**
         * Render.
         * @abstract
         * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
         */
        MapRenderer.prototype.renderFrame = function (frameState) {
            abstract();
        };
        /**
         * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
         * @protected
         */
        MapRenderer.prototype.scheduleExpireIconCache = function (frameState) {
            if (shared.canExpireCache()) {
                frameState.postRenderFunctions.push(expireIconCache);
            }
        };
        return MapRenderer;
    }(Disposable));
    /**
     * @param {import("../PluggableMap.js").default} map Map.
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     */
    function expireIconCache(map, frameState) {
        shared.expire();
    }

    var __extends$x = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Canvas map renderer.
     * @api
     */
    var CompositeMapRenderer = /** @class */ (function (_super) {
        __extends$x(CompositeMapRenderer, _super);
        /**
         * @param {import("../PluggableMap.js").default} map Map.
         */
        function CompositeMapRenderer(map) {
            var _this = _super.call(this, map) || this;
            /**
             * @type {import("../events.js").EventsKey}
             */
            _this.fontChangeListenerKey_ = listen(checkedFonts, ObjectEventType.PROPERTYCHANGE, map.redrawText.bind(map));
            /**
             * @private
             * @type {HTMLDivElement}
             */
            _this.element_ = document.createElement('div');
            var style = _this.element_.style;
            style.position = 'absolute';
            style.width = '100%';
            style.height = '100%';
            style.zIndex = '0';
            _this.element_.className = CLASS_UNSELECTABLE + ' ol-layers';
            var container = map.getViewport();
            container.insertBefore(_this.element_, container.firstChild || null);
            /**
             * @private
             * @type {Array<HTMLElement>}
             */
            _this.children_ = [];
            /**
             * @private
             * @type {boolean}
             */
            _this.renderedVisible_ = true;
            return _this;
        }
        /**
         * @param {import("../render/EventType.js").default} type Event type.
         * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
         */
        CompositeMapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
            var map = this.getMap();
            if (map.hasListener(type)) {
                var event_1 = new RenderEvent(type, undefined, frameState);
                map.dispatchEvent(event_1);
            }
        };
        CompositeMapRenderer.prototype.disposeInternal = function () {
            unlistenByKey(this.fontChangeListenerKey_);
            this.element_.parentNode.removeChild(this.element_);
            _super.prototype.disposeInternal.call(this);
        };
        /**
         * Render.
         * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
         */
        CompositeMapRenderer.prototype.renderFrame = function (frameState) {
            if (!frameState) {
                if (this.renderedVisible_) {
                    this.element_.style.display = 'none';
                    this.renderedVisible_ = false;
                }
                return;
            }
            this.calculateMatrices2D(frameState);
            this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);
            var layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {
                return a.zIndex - b.zIndex;
            });
            var viewState = frameState.viewState;
            this.children_.length = 0;
            /**
             * @type {Array<import("../layer/BaseVector.js").default>}
             */
            var declutterLayers = [];
            var previousElement = null;
            for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
                var layerState = layerStatesArray[i];
                frameState.layerIndex = i;
                if (!inView(layerState, viewState) ||
                    (layerState.sourceState != SourceState.READY &&
                        layerState.sourceState != SourceState.UNDEFINED)) {
                    continue;
                }
                var layer = layerState.layer;
                var element = layer.render(frameState, previousElement);
                if (!element) {
                    continue;
                }
                if (element !== previousElement) {
                    this.children_.push(element);
                    previousElement = element;
                }
                if ('getDeclutter' in layer) {
                    declutterLayers.push(layer);
                }
            }
            for (var i = declutterLayers.length - 1; i >= 0; --i) {
                declutterLayers[i].renderDeclutter(frameState);
            }
            replaceChildren(this.element_, this.children_);
            this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);
            if (!this.renderedVisible_) {
                this.element_.style.display = '';
                this.renderedVisible_ = true;
            }
            this.scheduleExpireIconCache(frameState);
        };
        /**
         * @param {import("../pixel.js").Pixel} pixel Pixel.
         * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
         * @param {number} hitTolerance Hit tolerance in pixels.
         * @param {function(import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
         *     callback.
         * @param {function(import("../layer/Layer.js").default): boolean} layerFilter Layer filter
         *     function, only layers which are visible and for which this function
         *     returns `true` will be tested for features.  By default, all visible
         *     layers will be tested.
         * @return {T|undefined} Callback result.
         * @template T
         */
        CompositeMapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
            var viewState = frameState.viewState;
            var layerStates = frameState.layerStatesArray;
            var numLayers = layerStates.length;
            for (var i = numLayers - 1; i >= 0; --i) {
                var layerState = layerStates[i];
                var layer = layerState.layer;
                if (layer.hasRenderer() &&
                    inView(layerState, viewState) &&
                    layerFilter(layer)) {
                    var layerRenderer = layer.getRenderer();
                    var data = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);
                    if (data) {
                        var result = callback(layer, data);
                        if (result) {
                            return result;
                        }
                    }
                }
            }
            return undefined;
        };
        return CompositeMapRenderer;
    }(MapRenderer));

    var __extends$w = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Events emitted as map events are instances of this type.
     * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map event.
     */
    var MapEvent = /** @class */ (function (_super) {
        __extends$w(MapEvent, _super);
        /**
         * @param {string} type Event type.
         * @param {import("./PluggableMap.js").default} map Map.
         * @param {?import("./PluggableMap.js").FrameState=} opt_frameState Frame state.
         */
        function MapEvent(type, map, opt_frameState) {
            var _this = _super.call(this, type) || this;
            /**
             * The map where the event occurred.
             * @type {import("./PluggableMap.js").default}
             * @api
             */
            _this.map = map;
            /**
             * The frame state at the time of the event.
             * @type {?import("./PluggableMap.js").FrameState}
             * @api
             */
            _this.frameState = opt_frameState !== undefined ? opt_frameState : null;
            return _this;
        }
        return MapEvent;
    }(BaseEvent));

    var __extends$v = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Events emitted as map browser events are instances of this type.
     * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map browser event.
     * @template {UIEvent} EVENT
     */
    var MapBrowserEvent = /** @class */ (function (_super) {
        __extends$v(MapBrowserEvent, _super);
        /**
         * @param {string} type Event type.
         * @param {import("./PluggableMap.js").default} map Map.
         * @param {EVENT} originalEvent Original event.
         * @param {boolean=} opt_dragging Is the map currently being dragged?
         * @param {?import("./PluggableMap.js").FrameState=} opt_frameState Frame state.
         */
        function MapBrowserEvent(type, map, originalEvent, opt_dragging, opt_frameState) {
            var _this = _super.call(this, type, map, opt_frameState) || this;
            /**
             * The original browser event.
             * @const
             * @type {EVENT}
             * @api
             */
            _this.originalEvent = originalEvent;
            /**
             * The map pixel relative to the viewport corresponding to the original browser event.
             * @type {?import("./pixel.js").Pixel}
             */
            _this.pixel_ = null;
            /**
             * The coordinate in the user projection corresponding to the original browser event.
             * @type {?import("./coordinate.js").Coordinate}
             */
            _this.coordinate_ = null;
            /**
             * Indicates if the map is currently being dragged. Only set for
             * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
             *
             * @type {boolean}
             * @api
             */
            _this.dragging = opt_dragging !== undefined ? opt_dragging : false;
            return _this;
        }
        Object.defineProperty(MapBrowserEvent.prototype, "pixel", {
            /**
             * The map pixel relative to the viewport corresponding to the original event.
             * @type {import("./pixel.js").Pixel}
             * @api
             */
            get: function () {
                if (!this.pixel_) {
                    this.pixel_ = this.map.getEventPixel(this.originalEvent);
                }
                return this.pixel_;
            },
            set: function (pixel) {
                this.pixel_ = pixel;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MapBrowserEvent.prototype, "coordinate", {
            /**
             * The coordinate corresponding to the original browser event.  This will be in the user
             * projection if one is set.  Otherwise it will be in the view projection.
             * @type {import("./coordinate.js").Coordinate}
             * @api
             */
            get: function () {
                if (!this.coordinate_) {
                    this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
                }
                return this.coordinate_;
            },
            set: function (coordinate) {
                this.coordinate_ = coordinate;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Prevents the default browser action.
         * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
         * @api
         */
        MapBrowserEvent.prototype.preventDefault = function () {
            _super.prototype.preventDefault.call(this);
            this.originalEvent.preventDefault();
        };
        /**
         * Prevents further propagation of the current event.
         * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
         * @api
         */
        MapBrowserEvent.prototype.stopPropagation = function () {
            _super.prototype.stopPropagation.call(this);
            this.originalEvent.stopPropagation();
        };
        return MapBrowserEvent;
    }(MapEvent));

    /**
     * @module ol/MapBrowserEventType
     */
    /**
     * Constants for event names.
     * @enum {string}
     */
    var MapBrowserEventType = {
        /**
         * A true single click with no dragging and no double click. Note that this
         * event is delayed by 250 ms to ensure that it is not a double click.
         * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
         * @api
         */
        SINGLECLICK: 'singleclick',
        /**
         * A click with no dragging. A double click will fire two of this.
         * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
         * @api
         */
        CLICK: EventType.CLICK,
        /**
         * A true double click, with no dragging.
         * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
         * @api
         */
        DBLCLICK: EventType.DBLCLICK,
        /**
         * Triggered when a pointer is dragged.
         * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
         * @api
         */
        POINTERDRAG: 'pointerdrag',
        /**
         * Triggered when a pointer is moved. Note that on touch devices this is
         * triggered when the map is panned, so is not the same as mousemove.
         * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
         * @api
         */
        POINTERMOVE: 'pointermove',
        POINTERDOWN: 'pointerdown',
        POINTERUP: 'pointerup',
        POINTEROVER: 'pointerover',
        POINTEROUT: 'pointerout',
        POINTERENTER: 'pointerenter',
        POINTERLEAVE: 'pointerleave',
        POINTERCANCEL: 'pointercancel',
    };

    /**
     * @module ol/pointer/EventType
     */
    /**
     * Constants for event names.
     * @enum {string}
     */
    var PointerEventType = {
        POINTERMOVE: 'pointermove',
        POINTERDOWN: 'pointerdown',
        POINTERUP: 'pointerup',
        POINTEROVER: 'pointerover',
        POINTEROUT: 'pointerout',
        POINTERENTER: 'pointerenter',
        POINTERLEAVE: 'pointerleave',
        POINTERCANCEL: 'pointercancel',
    };

    /**
     * @module ol/MapBrowserEventHandler
     */
    var __extends$u = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var MapBrowserEventHandler = /** @class */ (function (_super) {
        __extends$u(MapBrowserEventHandler, _super);
        /**
         * @param {import("./PluggableMap.js").default} map The map with the viewport to listen to events on.
         * @param {number=} moveTolerance The minimal distance the pointer must travel to trigger a move.
         */
        function MapBrowserEventHandler(map, moveTolerance) {
            var _this = _super.call(this, map) || this;
            /**
             * This is the element that we will listen to the real events on.
             * @type {import("./PluggableMap.js").default}
             * @private
             */
            _this.map_ = map;
            /**
             * @type {any}
             * @private
             */
            _this.clickTimeoutId_;
            /**
             * Emulate dblclick and singleclick. Will be true when only one pointer is active.
             * @type {boolean}
             */
            _this.emulateClicks_ = false;
            /**
             * @type {boolean}
             * @private
             */
            _this.dragging_ = false;
            /**
             * @type {!Array<import("./events.js").EventsKey>}
             * @private
             */
            _this.dragListenerKeys_ = [];
            /**
             * @type {number}
             * @private
             */
            _this.moveTolerance_ = moveTolerance
                ? moveTolerance * DEVICE_PIXEL_RATIO
                : DEVICE_PIXEL_RATIO;
            /**
             * The most recent "down" type event (or null if none have occurred).
             * Set on pointerdown.
             * @type {PointerEvent}
             * @private
             */
            _this.down_ = null;
            var element = _this.map_.getViewport();
            /**
             * @type {number}
             * @private
             */
            _this.activePointers_ = 0;
            /**
             * @type {!Object<number, boolean>}
             * @private
             */
            _this.trackedTouches_ = {};
            _this.element_ = element;
            /**
             * @type {?import("./events.js").EventsKey}
             * @private
             */
            _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _this);
            /**
             * @type {PointerEvent}
             * @private
             */
            _this.originalPointerMoveEvent_;
            /**
             * @type {?import("./events.js").EventsKey}
             * @private
             */
            _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayEvent_, _this);
            /**
             * @private
             */
            _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);
            _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
            return _this;
        }
        /**
         * @param {PointerEvent} pointerEvent Pointer
         * event.
         * @private
         */
        MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {
            var newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
            if (this.clickTimeoutId_ !== undefined) {
                // double-click
                clearTimeout(this.clickTimeoutId_);
                this.clickTimeoutId_ = undefined;
                newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);
                this.dispatchEvent(newEvent);
            }
            else {
                // click
                this.clickTimeoutId_ = setTimeout(
                /** @this {MapBrowserEventHandler} */
                function () {
                    this.clickTimeoutId_ = undefined;
                    var newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);
                    this.dispatchEvent(newEvent);
                }.bind(this), 250);
            }
        };
        /**
         * Keeps track on how many pointers are currently active.
         *
         * @param {PointerEvent} pointerEvent Pointer
         * event.
         * @private
         */
        MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {
            var event = pointerEvent;
            if (event.type == MapBrowserEventType.POINTERUP ||
                event.type == MapBrowserEventType.POINTERCANCEL) {
                delete this.trackedTouches_[event.pointerId];
            }
            else if (event.type == MapBrowserEventType.POINTERDOWN) {
                this.trackedTouches_[event.pointerId] = true;
            }
            this.activePointers_ = Object.keys(this.trackedTouches_).length;
        };
        /**
         * @param {PointerEvent} pointerEvent Pointer
         * event.
         * @private
         */
        MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {
            this.updateActivePointers_(pointerEvent);
            var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
            // We emulate click events on left mouse button click, touch contact, and pen
            // contact. isMouseActionButton returns true in these cases (evt.button is set
            // to 0).
            // See http://www.w3.org/TR/pointerevents/#button-states
            // We only fire click, singleclick, and doubleclick if nobody has called
            // event.stopPropagation() or event.preventDefault().
            if (this.emulateClicks_ &&
                !newEvent.propagationStopped &&
                !this.dragging_ &&
                this.isMouseActionButton_(pointerEvent)) {
                this.emulateClick_(this.down_);
            }
            if (this.activePointers_ === 0) {
                this.dragListenerKeys_.forEach(unlistenByKey);
                this.dragListenerKeys_.length = 0;
                this.dragging_ = false;
                this.down_ = null;
            }
        };
        /**
         * @param {PointerEvent} pointerEvent Pointer
         * event.
         * @return {boolean} If the left mouse button was pressed.
         * @private
         */
        MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {
            return pointerEvent.button === 0;
        };
        /**
         * @param {PointerEvent} pointerEvent Pointer
         * event.
         * @private
         */
        MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {
            this.emulateClicks_ = this.activePointers_ === 0;
            this.updateActivePointers_(pointerEvent);
            var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
            this.down_ = pointerEvent;
            if (this.dragListenerKeys_.length === 0) {
                var doc = this.map_.getOwnerDocument();
                this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this), 
                /* Note that the listener for `pointercancel is set up on
                 * `pointerEventHandler_` and not `documentPointerEventHandler_` like
                 * the `pointerup` and `pointermove` listeners.
                 *
                 * The reason for this is the following: `TouchSource.vacuumTouches_()`
                 * issues `pointercancel` events, when there was no `touchend` for a
                 * `touchstart`. Now, let's say a first `touchstart` is registered on
                 * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
                 * But `documentPointerEventHandler_` doesn't know about the first
                 * `touchstart`. If there is no `touchend` for the `touchstart`, we can
                 * only receive a `touchcancel` from `pointerEventHandler_`, because it is
                 * only registered there.
                 */
                listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));
                if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
                    this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));
                }
            }
        };
        /**
         * @param {PointerEvent} pointerEvent Pointer
         * event.
         * @private
         */
        MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {
            // Between pointerdown and pointerup, pointermove events are triggered.
            // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
            // moved a significant distance.
            if (this.isMoving_(pointerEvent)) {
                this.dragging_ = true;
                var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_);
                this.dispatchEvent(newEvent);
            }
        };
        /**
         * Wrap and relay a pointer event.  Note that this requires that the type
         * string for the MapBrowserEvent matches the PointerEvent type.
         * @param {PointerEvent} pointerEvent Pointer
         * event.
         * @private
         */
        MapBrowserEventHandler.prototype.relayEvent_ = function (pointerEvent) {
            this.originalPointerMoveEvent_ = pointerEvent;
            var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
            this.dispatchEvent(new MapBrowserEvent(pointerEvent.type, this.map_, pointerEvent, dragging));
        };
        /**
         * Flexible handling of a `touch-action: none` css equivalent: because calling
         * `preventDefault()` on a `pointermove` event does not stop native page scrolling
         * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
         * when an interaction (currently `DragPan` handles the event.
         * @param {TouchEvent} event Event.
         * @private
         */
        MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {
            // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
            // may not be initialized yet when we get here on a platform without native pointer events.
            if (!this.originalPointerMoveEvent_ ||
                this.originalPointerMoveEvent_.defaultPrevented) {
                event.preventDefault();
            }
        };
        /**
         * @param {PointerEvent} pointerEvent Pointer
         * event.
         * @return {boolean} Is moving.
         * @private
         */
        MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {
            return (this.dragging_ ||
                Math.abs(pointerEvent.clientX - this.down_.clientX) >
                    this.moveTolerance_ ||
                Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_);
        };
        /**
         * Clean up.
         */
        MapBrowserEventHandler.prototype.disposeInternal = function () {
            if (this.relayedListenerKey_) {
                unlistenByKey(this.relayedListenerKey_);
                this.relayedListenerKey_ = null;
            }
            this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);
            if (this.pointerdownListenerKey_) {
                unlistenByKey(this.pointerdownListenerKey_);
                this.pointerdownListenerKey_ = null;
            }
            this.dragListenerKeys_.forEach(unlistenByKey);
            this.dragListenerKeys_.length = 0;
            this.element_ = null;
            _super.prototype.disposeInternal.call(this);
        };
        return MapBrowserEventHandler;
    }(Target));

    /**
     * @module ol/MapEventType
     */
    /**
     * @enum {string}
     */
    var MapEventType = {
        /**
         * Triggered after a map frame is rendered.
         * @event module:ol/MapEvent~MapEvent#postrender
         * @api
         */
        POSTRENDER: 'postrender',
        /**
         * Triggered when the map starts moving.
         * @event module:ol/MapEvent~MapEvent#movestart
         * @api
         */
        MOVESTART: 'movestart',
        /**
         * Triggered after the map is moved.
         * @event module:ol/MapEvent~MapEvent#moveend
         * @api
         */
        MOVEEND: 'moveend',
    };

    /**
     * @module ol/MapProperty
     */
    /**
     * @enum {string}
     */
    var MapProperty = {
        LAYERGROUP: 'layergroup',
        SIZE: 'size',
        TARGET: 'target',
        VIEW: 'view',
    };

    /**
     * @module ol/structs/PriorityQueue
     */
    /**
     * @type {number}
     */
    var DROP = Infinity;
    /**
     * @classdesc
     * Priority queue.
     *
     * The implementation is inspired from the Closure Library's Heap class and
     * Python's heapq module.
     *
     * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
     * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.
     *
     * @template T
     */
    var PriorityQueue = /** @class */ (function () {
        /**
         * @param {function(T): number} priorityFunction Priority function.
         * @param {function(T): string} keyFunction Key function.
         */
        function PriorityQueue(priorityFunction, keyFunction) {
            /**
             * @type {function(T): number}
             * @private
             */
            this.priorityFunction_ = priorityFunction;
            /**
             * @type {function(T): string}
             * @private
             */
            this.keyFunction_ = keyFunction;
            /**
             * @type {Array<T>}
             * @private
             */
            this.elements_ = [];
            /**
             * @type {Array<number>}
             * @private
             */
            this.priorities_ = [];
            /**
             * @type {!Object<string, boolean>}
             * @private
             */
            this.queuedElements_ = {};
        }
        /**
         * FIXME empty description for jsdoc
         */
        PriorityQueue.prototype.clear = function () {
            this.elements_.length = 0;
            this.priorities_.length = 0;
            clear(this.queuedElements_);
        };
        /**
         * Remove and return the highest-priority element. O(log N).
         * @return {T} Element.
         */
        PriorityQueue.prototype.dequeue = function () {
            var elements = this.elements_;
            var priorities = this.priorities_;
            var element = elements[0];
            if (elements.length == 1) {
                elements.length = 0;
                priorities.length = 0;
            }
            else {
                elements[0] = elements.pop();
                priorities[0] = priorities.pop();
                this.siftUp_(0);
            }
            var elementKey = this.keyFunction_(element);
            delete this.queuedElements_[elementKey];
            return element;
        };
        /**
         * Enqueue an element. O(log N).
         * @param {T} element Element.
         * @return {boolean} The element was added to the queue.
         */
        PriorityQueue.prototype.enqueue = function (element) {
            assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue
            var priority = this.priorityFunction_(element);
            if (priority != DROP) {
                this.elements_.push(element);
                this.priorities_.push(priority);
                this.queuedElements_[this.keyFunction_(element)] = true;
                this.siftDown_(0, this.elements_.length - 1);
                return true;
            }
            return false;
        };
        /**
         * @return {number} Count.
         */
        PriorityQueue.prototype.getCount = function () {
            return this.elements_.length;
        };
        /**
         * Gets the index of the left child of the node at the given index.
         * @param {number} index The index of the node to get the left child for.
         * @return {number} The index of the left child.
         * @private
         */
        PriorityQueue.prototype.getLeftChildIndex_ = function (index) {
            return index * 2 + 1;
        };
        /**
         * Gets the index of the right child of the node at the given index.
         * @param {number} index The index of the node to get the right child for.
         * @return {number} The index of the right child.
         * @private
         */
        PriorityQueue.prototype.getRightChildIndex_ = function (index) {
            return index * 2 + 2;
        };
        /**
         * Gets the index of the parent of the node at the given index.
         * @param {number} index The index of the node to get the parent for.
         * @return {number} The index of the parent.
         * @private
         */
        PriorityQueue.prototype.getParentIndex_ = function (index) {
            return (index - 1) >> 1;
        };
        /**
         * Make this a heap. O(N).
         * @private
         */
        PriorityQueue.prototype.heapify_ = function () {
            var i;
            for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
                this.siftUp_(i);
            }
        };
        /**
         * @return {boolean} Is empty.
         */
        PriorityQueue.prototype.isEmpty = function () {
            return this.elements_.length === 0;
        };
        /**
         * @param {string} key Key.
         * @return {boolean} Is key queued.
         */
        PriorityQueue.prototype.isKeyQueued = function (key) {
            return key in this.queuedElements_;
        };
        /**
         * @param {T} element Element.
         * @return {boolean} Is queued.
         */
        PriorityQueue.prototype.isQueued = function (element) {
            return this.isKeyQueued(this.keyFunction_(element));
        };
        /**
         * @param {number} index The index of the node to move down.
         * @private
         */
        PriorityQueue.prototype.siftUp_ = function (index) {
            var elements = this.elements_;
            var priorities = this.priorities_;
            var count = elements.length;
            var element = elements[index];
            var priority = priorities[index];
            var startIndex = index;
            while (index < count >> 1) {
                var lIndex = this.getLeftChildIndex_(index);
                var rIndex = this.getRightChildIndex_(index);
                var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex]
                    ? rIndex
                    : lIndex;
                elements[index] = elements[smallerChildIndex];
                priorities[index] = priorities[smallerChildIndex];
                index = smallerChildIndex;
            }
            elements[index] = element;
            priorities[index] = priority;
            this.siftDown_(startIndex, index);
        };
        /**
         * @param {number} startIndex The index of the root.
         * @param {number} index The index of the node to move up.
         * @private
         */
        PriorityQueue.prototype.siftDown_ = function (startIndex, index) {
            var elements = this.elements_;
            var priorities = this.priorities_;
            var element = elements[index];
            var priority = priorities[index];
            while (index > startIndex) {
                var parentIndex = this.getParentIndex_(index);
                if (priorities[parentIndex] > priority) {
                    elements[index] = elements[parentIndex];
                    priorities[index] = priorities[parentIndex];
                    index = parentIndex;
                }
                else {
                    break;
                }
            }
            elements[index] = element;
            priorities[index] = priority;
        };
        /**
         * FIXME empty description for jsdoc
         */
        PriorityQueue.prototype.reprioritize = function () {
            var priorityFunction = this.priorityFunction_;
            var elements = this.elements_;
            var priorities = this.priorities_;
            var index = 0;
            var n = elements.length;
            var element, i, priority;
            for (i = 0; i < n; ++i) {
                element = elements[i];
                priority = priorityFunction(element);
                if (priority == DROP) {
                    delete this.queuedElements_[this.keyFunction_(element)];
                }
                else {
                    priorities[index] = priority;
                    elements[index++] = element;
                }
            }
            elements.length = index;
            priorities.length = index;
            this.heapify_();
        };
        return PriorityQueue;
    }());

    var __extends$t = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
     */
    var TileQueue = /** @class */ (function (_super) {
        __extends$t(TileQueue, _super);
        /**
         * @param {PriorityFunction} tilePriorityFunction Tile priority function.
         * @param {function(): ?} tileChangeCallback Function called on each tile change event.
         */
        function TileQueue(tilePriorityFunction, tileChangeCallback) {
            var _this = _super.call(this, 
            /**
             * @param {Array} element Element.
             * @return {number} Priority.
             */
            function (element) {
                return tilePriorityFunction.apply(null, element);
            }, 
            /**
             * @param {Array} element Element.
             * @return {string} Key.
             */
            function (element) {
                return /** @type {import("./Tile.js").default} */ (element[0]).getKey();
            }) || this;
            /** @private */
            _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);
            /**
             * @private
             * @type {function(): ?}
             */
            _this.tileChangeCallback_ = tileChangeCallback;
            /**
             * @private
             * @type {number}
             */
            _this.tilesLoading_ = 0;
            /**
             * @private
             * @type {!Object<string,boolean>}
             */
            _this.tilesLoadingKeys_ = {};
            return _this;
        }
        /**
         * @param {Array} element Element.
         * @return {boolean} The element was added to the queue.
         */
        TileQueue.prototype.enqueue = function (element) {
            var added = _super.prototype.enqueue.call(this, element);
            if (added) {
                var tile = element[0];
                tile.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);
            }
            return added;
        };
        /**
         * @return {number} Number of tiles loading.
         */
        TileQueue.prototype.getTilesLoading = function () {
            return this.tilesLoading_;
        };
        /**
         * @param {import("./events/Event.js").default} event Event.
         * @protected
         */
        TileQueue.prototype.handleTileChange = function (event) {
            var tile = /** @type {import("./Tile.js").default} */ (event.target);
            var state = tile.getState();
            if ((tile.hifi && state === TileState.LOADED) ||
                state === TileState.ERROR ||
                state === TileState.EMPTY) {
                tile.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);
                var tileKey = tile.getKey();
                if (tileKey in this.tilesLoadingKeys_) {
                    delete this.tilesLoadingKeys_[tileKey];
                    --this.tilesLoading_;
                }
                this.tileChangeCallback_();
            }
        };
        /**
         * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
         * @param {number} maxNewLoads Maximum number of new tiles to load.
         */
        TileQueue.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {
            var newLoads = 0;
            var state, tile, tileKey;
            while (this.tilesLoading_ < maxTotalLoading &&
                newLoads < maxNewLoads &&
                this.getCount() > 0) {
                tile = /** @type {import("./Tile.js").default} */ (this.dequeue()[0]);
                tileKey = tile.getKey();
                state = tile.getState();
                if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
                    this.tilesLoadingKeys_[tileKey] = true;
                    ++this.tilesLoading_;
                    ++newLoads;
                    tile.load();
                }
            }
        };
        return TileQueue;
    }(PriorityQueue));
    /**
     * @param {import('./PluggableMap.js').FrameState} frameState Frame state.
     * @param {import("./Tile.js").default} tile Tile.
     * @param {string} tileSourceKey Tile source key.
     * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
     * @param {number} tileResolution Tile resolution.
     * @return {number} Tile priority.
     */
    function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
        // Filter out tiles at higher zoom levels than the current zoom level, or that
        // are outside the visible extent.
        if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
            return DROP;
        }
        if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
            return DROP;
        }
        // Prioritize the highest zoom level tiles closest to the focus.
        // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
        // Within a zoom level, tiles are prioritized by the distance in pixels between
        // the center of the tile and the center of the viewport.  The factor of 65536
        // means that the prioritization should behave as desired for tiles up to
        // 65536 * Math.log(2) = 45426 pixels from the focus.
        var center = frameState.viewState.center;
        var deltaX = tileCenter[0] - center[0];
        var deltaY = tileCenter[1] - center[1];
        return (65536 * Math.log(tileResolution) +
            Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution);
    }

    /**
     * @module ol/ViewProperty
     */
    /**
     * @enum {string}
     */
    var ViewProperty = {
        CENTER: 'center',
        RESOLUTION: 'resolution',
        ROTATION: 'rotation',
    };

    /**
     * @module ol/centerconstraint
     */
    /**
     * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
     */
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
     * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
     * (only during interaction and animation).
     * @return {Type} The constraint.
     */
    function createExtent(extent, onlyCenter, smooth) {
        return (
        /**
         * @param {import("./coordinate.js").Coordinate|undefined} center Center.
         * @param {number} resolution Resolution.
         * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
         * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
         * @param {Array<number>=} opt_centerShift Shift between map center and viewport center.
         * @return {import("./coordinate.js").Coordinate|undefined} Center.
         */
        function (center, resolution, size, opt_isMoving, opt_centerShift) {
            if (center) {
                var viewWidth = onlyCenter ? 0 : size[0] * resolution;
                var viewHeight = onlyCenter ? 0 : size[1] * resolution;
                var shiftX = opt_centerShift ? opt_centerShift[0] : 0;
                var shiftY = opt_centerShift ? opt_centerShift[1] : 0;
                var minX = extent[0] + viewWidth / 2 + shiftX;
                var maxX = extent[2] - viewWidth / 2 + shiftX;
                var minY = extent[1] + viewHeight / 2 + shiftY;
                var maxY = extent[3] - viewHeight / 2 + shiftY;
                // note: when zooming out of bounds, min and max values for x and y may
                // end up inverted (min > max); this has to be accounted for
                if (minX > maxX) {
                    minX = (maxX + minX) / 2;
                    maxX = minX;
                }
                if (minY > maxY) {
                    minY = (maxY + minY) / 2;
                    maxY = minY;
                }
                var x = clamp(center[0], minX, maxX);
                var y = clamp(center[1], minY, maxY);
                var ratio = 30 * resolution;
                // during an interaction, allow some overscroll
                if (opt_isMoving && smooth) {
                    x +=
                        -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +
                            ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
                    y +=
                        -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +
                            ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
                }
                return [x, y];
            }
            else {
                return undefined;
            }
        });
    }
    /**
     * @param {import("./coordinate.js").Coordinate=} center Center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function none$1(center) {
        return center;
    }

    /**
     * @module ol/resolutionconstraint
     */
    /**
     * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
     */
    /**
     * Returns a modified resolution taking into account the viewport size and maximum
     * allowed extent.
     * @param {number} resolution Resolution
     * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
     * @param {import("./size.js").Size} viewportSize Viewport size.
     * @param {boolean} showFullExtent Whether to show the full extent.
     * @return {number} Capped resolution.
     */
    function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
        var xResolution = getWidth(maxExtent) / viewportSize[0];
        var yResolution = getHeight(maxExtent) / viewportSize[1];
        if (showFullExtent) {
            return Math.min(resolution, Math.max(xResolution, yResolution));
        }
        return Math.min(resolution, Math.min(xResolution, yResolution));
    }
    /**
     * Returns a modified resolution to be between maxResolution and minResolution while
     * still allowing the value to be slightly out of bounds.
     * Note: the computation is based on the logarithm function (ln):
     *  - at 1, ln(x) is 0
     *  - above 1, ln(x) keeps increasing but at a much slower pace than x
     * The final result is clamped to prevent getting too far away from bounds.
     * @param {number} resolution Resolution.
     * @param {number} maxResolution Max resolution.
     * @param {number} minResolution Min resolution.
     * @return {number} Smoothed resolution.
     */
    function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
        var result = Math.min(resolution, maxResolution);
        var ratio = 50;
        result *=
            Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +
                1;
        if (minResolution) {
            result = Math.max(result, minResolution);
            result /=
                Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /
                    ratio +
                    1;
        }
        return clamp(result, minResolution / 2, maxResolution * 2);
    }
    /**
     * @param {Array<number>} resolutions Resolutions.
     * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
     * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
     * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
     * @return {Type} Zoom function.
     */
    function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
        return (
        /**
         * @param {number|undefined} resolution Resolution.
         * @param {number} direction Direction.
         * @param {import("./size.js").Size} size Viewport size.
         * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
         * @return {number|undefined} Resolution.
         */
        function (resolution, direction, size, opt_isMoving) {
            if (resolution !== undefined) {
                var maxResolution = resolutions[0];
                var minResolution = resolutions[resolutions.length - 1];
                var cappedMaxRes = opt_maxExtent
                    ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                    : maxResolution;
                // during interacting or animating, allow intermediary values
                if (opt_isMoving) {
                    var smooth = opt_smooth !== undefined ? opt_smooth : true;
                    if (!smooth) {
                        return clamp(resolution, minResolution, cappedMaxRes);
                    }
                    return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
                }
                var capped = Math.min(cappedMaxRes, resolution);
                var z = Math.floor(linearFindNearest(resolutions, capped, direction));
                if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
                    return resolutions[z + 1];
                }
                return resolutions[z];
            }
            else {
                return undefined;
            }
        });
    }
    /**
     * @param {number} power Power.
     * @param {number} maxResolution Maximum resolution.
     * @param {number=} opt_minResolution Minimum resolution.
     * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
     * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
     * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
     * @return {Type} Zoom function.
     */
    function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
        return (
        /**
         * @param {number|undefined} resolution Resolution.
         * @param {number} direction Direction.
         * @param {import("./size.js").Size} size Viewport size.
         * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
         * @return {number|undefined} Resolution.
         */
        function (resolution, direction, size, opt_isMoving) {
            if (resolution !== undefined) {
                var cappedMaxRes = opt_maxExtent
                    ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                    : maxResolution;
                var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;
                // during interacting or animating, allow intermediary values
                if (opt_isMoving) {
                    var smooth = opt_smooth !== undefined ? opt_smooth : true;
                    if (!smooth) {
                        return clamp(resolution, minResolution, cappedMaxRes);
                    }
                    return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
                }
                var tolerance = 1e-9;
                var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
                var offset = -direction * (0.5 - tolerance) + 0.5;
                var capped = Math.min(cappedMaxRes, resolution);
                var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
                var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
                var newResolution = maxResolution / Math.pow(power, zoomLevel);
                return clamp(newResolution, minResolution, cappedMaxRes);
            }
            else {
                return undefined;
            }
        });
    }
    /**
     * @param {number} maxResolution Max resolution.
     * @param {number} minResolution Min resolution.
     * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
     * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
     * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
     * @return {Type} Zoom function.
     */
    function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
        return (
        /**
         * @param {number|undefined} resolution Resolution.
         * @param {number} direction Direction.
         * @param {import("./size.js").Size} size Viewport size.
         * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
         * @return {number|undefined} Resolution.
         */
        function (resolution, direction, size, opt_isMoving) {
            if (resolution !== undefined) {
                var cappedMaxRes = opt_maxExtent
                    ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                    : maxResolution;
                var smooth = opt_smooth !== undefined ? opt_smooth : true;
                if (!smooth || !opt_isMoving) {
                    return clamp(resolution, minResolution, cappedMaxRes);
                }
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            }
            else {
                return undefined;
            }
        });
    }

    /**
     * @module ol/rotationconstraint
     */
    /**
     * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
     */
    /**
     * @param {number|undefined} rotation Rotation.
     * @return {number|undefined} Rotation.
     */
    function disable(rotation) {
        if (rotation !== undefined) {
            return 0;
        }
        else {
            return undefined;
        }
    }
    /**
     * @param {number|undefined} rotation Rotation.
     * @return {number|undefined} Rotation.
     */
    function none(rotation) {
        if (rotation !== undefined) {
            return rotation;
        }
        else {
            return undefined;
        }
    }
    /**
     * @param {number} n N.
     * @return {Type} Rotation constraint.
     */
    function createSnapToN(n) {
        var theta = (2 * Math.PI) / n;
        return (
        /**
         * @param {number|undefined} rotation Rotation.
         * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
         * @return {number|undefined} Rotation.
         */
        function (rotation, opt_isMoving) {
            if (opt_isMoving) {
                return rotation;
            }
            if (rotation !== undefined) {
                rotation = Math.floor(rotation / theta + 0.5) * theta;
                return rotation;
            }
            else {
                return undefined;
            }
        });
    }
    /**
     * @param {number=} opt_tolerance Tolerance.
     * @return {Type} Rotation constraint.
     */
    function createSnapToZero(opt_tolerance) {
        var tolerance = opt_tolerance || toRadians(5);
        return (
        /**
         * @param {number|undefined} rotation Rotation.
         * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
         * @return {number|undefined} Rotation.
         */
        function (rotation, opt_isMoving) {
            if (opt_isMoving) {
                return rotation;
            }
            if (rotation !== undefined) {
                if (Math.abs(rotation) <= tolerance) {
                    return 0;
                }
                else {
                    return rotation;
                }
            }
            else {
                return undefined;
            }
        });
    }

    var __extends$s = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * An animation configuration
     *
     * @typedef {Object} Animation
     * @property {import("./coordinate.js").Coordinate} [sourceCenter]
     * @property {import("./coordinate.js").Coordinate} [targetCenter]
     * @property {number} [sourceResolution]
     * @property {number} [targetResolution]
     * @property {number} [sourceRotation]
     * @property {number} [targetRotation]
     * @property {import("./coordinate.js").Coordinate} [anchor]
     * @property {number} start
     * @property {number} duration
     * @property {boolean} complete
     * @property {function(number):number} easing
     * @property {function(boolean):void} callback
     */
    /**
     * @typedef {Object} Constraints
     * @property {import("./centerconstraint.js").Type} center
     * @property {import("./resolutionconstraint.js").Type} resolution
     * @property {import("./rotationconstraint.js").Type} rotation
     */
    /**
     * @typedef {Object} FitOptions
     * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
     * the extent into. Default is the current size of the first map in the DOM that
     * uses this view, or `[100, 100]` if no such map is found.
     * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
     * cleared inside the view. Values in the array are top, right, bottom and left
     * padding.
     * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
     * get the nearest extent instead of the closest that actually fits the view.
     * @property {number} [minResolution=0] Minimum resolution that we zoom to.
     * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
     * `minResolution` is given, this property is ignored.
     * @property {number} [duration] The duration of the animation in milliseconds.
     * By default, there is no animation to the target extent.
     * @property {function(number):number} [easing] The easing function used during
     * the animation (defaults to {@link module:ol/easing~inAndOut}).
     * The function will be called for each frame with a number representing a
     * fraction of the animation's duration.  The function should return a number
     * between 0 and 1 representing the progress toward the destination state.
     * @property {function(boolean):void} [callback] Function called when the view is in
     * its final position. The callback will be called with `true` if the animation
     * series completed on its own or `false` if it was cancelled.
     */
    /**
     * @typedef {Object} ViewOptions
     * @property {import("./coordinate.js").Coordinate} [center] The initial center for
     * the view. If a user projection is not set, the coordinate system for the center is
     * specified with the `projection` option. Layer sources will not be fetched if this
     * is not set, but the center can be set later with {@link #setCenter}.
     * @property {boolean|number} [constrainRotation=true] Rotation constraint.
     * `false` means no constraint. `true` means no constraint, but snap to zero
     * near zero. A number constrains the rotation to that number of values. For
     * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
     * @property {boolean} [enableRotation=true] Enable rotation.
     * If `false`, a rotation constraint that always sets the rotation to zero is
     * used. The `constrainRotation` option has no effect if `enableRotation` is
     * `false`.
     * @property {import("./extent.js").Extent} [extent] The extent that constrains the
     * view, in other words, nothing outside of this extent can be visible on the map.
     * @property {boolean} [constrainOnlyCenter=false] If true, the extent
     * constraint will only apply to the view center and not the whole extent.
     * @property {boolean} [smoothExtentConstraint=true] If true, the extent
     * constraint will be applied smoothly, i.e. allow the view to go slightly outside
     * of the given `extent`.
     * @property {number} [maxResolution] The maximum resolution used to determine
     * the resolution constraint. It is used together with `minResolution` (or
     * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
     * that the projection's validity extent fits in a 256x256 px tile. If the
     * projection is Spherical Mercator (the default) then `maxResolution` defaults
     * to `40075016.68557849 / 256 = 156543.03392804097`.
     * @property {number} [minResolution] The minimum resolution used to determine
     * the resolution constraint.  It is used together with `maxResolution` (or
     * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
     * zoom levels (with a factor of 2). If the projection is Spherical Mercator
     * (the default) then `minResolution` defaults to
     * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
     * @property {number} [maxZoom=28] The maximum zoom level used to determine the
     * resolution constraint. It is used together with `minZoom` (or
     * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
     * provided, it is given precedence over `maxZoom`.
     * @property {number} [minZoom=0] The minimum zoom level used to determine the
     * resolution constraint. It is used together with `maxZoom` (or
     * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
     * provided, it is given precedence over `minZoom`.
     * @property {boolean} [multiWorld=false] If `false` the view is constrained so
     * only one world is visible, and you cannot pan off the edge.  If `true` the map
     * may show multiple worlds at low zoom levels.  Only used if the `projection` is
     * global.  Note that if `extent` is also provided it is given precedence.
     * @property {boolean} [constrainResolution=false] If true, the view will always
     * animate to the closest zoom level after an interaction; false means
     * intermediary zoom levels are allowed.
     * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
     * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
     * the given resolution or zoom bounds.
     * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
     * show the full configured extent. By default, when a view is configured with an
     * extent, users will not be able to zoom out so the viewport exceeds the extent in
     * either dimension. This means the full extent may not be visible if the viewport
     * is taller or wider than the aspect ratio of the configured extent. If
     * showFullExtent is true, the user will be able to zoom out so that the viewport
     * exceeds the height or width of the configured extent, but not both, allowing the
     * full extent to be shown.
     * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
     * projection. The default is Spherical Mercator.
     * @property {number} [resolution] The initial resolution for the view. The
     * units are `projection` units per pixel (e.g. meters per pixel). An
     * alternative to setting this is to set `zoom`. Layer sources will not be
     * fetched if neither this nor `zoom` are defined, but they can be set later
     * with {@link #setZoom} or {@link #setResolution}.
     * @property {Array<number>} [resolutions] Resolutions to determine the
     * resolution constraint. If set the `maxResolution`, `minResolution`,
     * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
     * @property {number} [rotation=0] The initial rotation for the view in radians
     * (positive rotation clockwise, 0 means North).
     * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
     * level used to calculate the initial resolution for the view.
     * @property {number} [zoomFactor=2] The zoom factor used to compute the
     * corresponding resolution.
     * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
     * If the map viewport is partially covered with other content (overlays) along
     * its edges, this setting allows to shift the center of the viewport away from
     * that content. The order of the values is top, right, bottom, left.
     */
    /**
     * @typedef {Object} AnimationOptions
     * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
     * the animation.
     * @property {number} [zoom] The zoom level of the view at the end of the
     * animation. This takes precedence over `resolution`.
     * @property {number} [resolution] The resolution of the view at the end
     * of the animation.  If `zoom` is also provided, this option will be ignored.
     * @property {number} [rotation] The rotation of the view at the end of
     * the animation.
     * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
     * during a rotation or resolution animation.
     * @property {number} [duration=1000] The duration of the animation in milliseconds.
     * @property {function(number):number} [easing] The easing function used
     * during the animation (defaults to {@link module:ol/easing~inAndOut}).
     * The function will be called for each frame with a number representing a
     * fraction of the animation's duration.  The function should return a number
     * between 0 and 1 representing the progress toward the destination state.
     */
    /**
     * @typedef {Object} State
     * @property {import("./coordinate.js").Coordinate} center
     * @property {import("./proj/Projection.js").default} projection
     * @property {number} resolution
     * @property {number} rotation
     * @property {number} zoom
     */
    /**
     * Default min zoom level for the map view.
     * @type {number}
     */
    var DEFAULT_MIN_ZOOM = 0;
    /**
     * @classdesc
     * A View object represents a simple 2D view of the map.
     *
     * This is the object to act upon to change the center, resolution,
     * and rotation of the map.
     *
     * A View has a `projection`. The projection determines the
     * coordinate system of the center, and its units determine the units of the
     * resolution (projection units per pixel). The default projection is
     * Spherical Mercator (EPSG:3857).
     *
     * ### The view states
     *
     * A View is determined by three states: `center`, `resolution`,
     * and `rotation`. Each state has a corresponding getter and setter, e.g.
     * `getCenter` and `setCenter` for the `center` state.
     *
     * The `zoom` state is actually not saved on the view: all computations
     * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
     * methods are available, as well as `getResolutionForZoom` and
     * `getZoomForResolution` to switch from one system to the other.
     *
     * ### The constraints
     *
     * `setCenter`, `setResolution` and `setRotation` can be used to change the
     * states of the view, but any constraint defined in the constructor will
     * be applied along the way.
     *
     * A View object can have a *resolution constraint*, a *rotation constraint*
     * and a *center constraint*.
     *
     * The *resolution constraint* typically restricts min/max values and
     * snaps to specific resolutions. It is determined by the following
     * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
     * If `resolutions` is set, the other three options are ignored. See
     * documentation for each option for more information. By default, the view
     * only has a min/max restriction and allow intermediary zoom levels when
     * pinch-zooming for example.
     *
     * The *rotation constraint* snaps to specific angles. It is determined
     * by the following options: `enableRotation` and `constrainRotation`.
     * By default rotation is allowed and its value is snapped to zero when approaching the
     * horizontal.
     *
     * The *center constraint* is determined by the `extent` option. By
     * default the view center is not constrained at all.
     *
     * ### Changing the view state
     *
     * It is important to note that `setZoom`, `setResolution`, `setCenter` and
     * `setRotation` are subject to the above mentioned constraints. As such, it
     * may sometimes not be possible to know in advance the resulting state of the
     * View. For example, calling `setResolution(10)` does not guarantee that
     * `getResolution()` will return `10`.
     *
     * A consequence of this is that, when applying a delta on the view state, one
     * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
     * rather than the corresponding setters. This will let view do its internal
     * computations. Besides, the `adjust*` methods also take an `opt_anchor`
     * argument which allows specifying an origin for the transformation.
     *
     * ### Interacting with the view
     *
     * View constraints are usually only applied when the view is *at rest*, meaning that
     * no interaction or animation is ongoing. As such, if the user puts the view in a
     * state that is not equivalent to a constrained one (e.g. rotating the view when
     * the snap angle is 0), an animation will be triggered at the interaction end to
     * put back the view to a stable state;
     *
     * @api
     */
    var View = /** @class */ (function (_super) {
        __extends$s(View, _super);
        /**
         * @param {ViewOptions=} opt_options View options.
         */
        function View(opt_options) {
            var _this = _super.call(this) || this;
            var options = assign({}, opt_options);
            /**
             * @private
             * @type {Array<number>}
             */
            _this.hints_ = [0, 0];
            /**
             * @private
             * @type {Array<Array<Animation>>}
             */
            _this.animations_ = [];
            /**
             * @private
             * @type {number|undefined}
             */
            _this.updateAnimationKey_;
            /**
             * @private
             * @const
             * @type {import("./proj/Projection.js").default}
             */
            _this.projection_ = createProjection(options.projection, 'EPSG:3857');
            /**
             * @private
             * @type {import("./size.js").Size}
             */
            _this.viewportSize_ = [100, 100];
            /**
             * @private
             * @type {import("./coordinate.js").Coordinate|undefined}
             */
            _this.targetCenter_ = null;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.targetResolution_;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.targetRotation_;
            /**
             * @private
             * @type {import("./coordinate.js").Coordinate|undefined}
             */
            _this.cancelAnchor_ = undefined;
            if (options.center) {
                options.center = fromUserCoordinate(options.center, _this.projection_);
            }
            if (options.extent) {
                options.extent = fromUserExtent(options.extent, _this.projection_);
            }
            _this.applyOptions_(options);
            return _this;
        }
        /**
         * Set up the view with the given options.
         * @param {ViewOptions} options View options.
         */
        View.prototype.applyOptions_ = function (options) {
            /**
             * @type {Object<string, *>}
             */
            var properties = {};
            var resolutionConstraintInfo = createResolutionConstraint(options);
            /**
             * @private
             * @type {number}
             */
            this.maxResolution_ = resolutionConstraintInfo.maxResolution;
            /**
             * @private
             * @type {number}
             */
            this.minResolution_ = resolutionConstraintInfo.minResolution;
            /**
             * @private
             * @type {number}
             */
            this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
            /**
             * @private
             * @type {Array<number>|undefined}
             */
            this.resolutions_ = options.resolutions;
            /**
             * Padding (in css pixels).
             * If the map viewport is partially covered with other content (overlays) along
             * its edges, this setting allows to shift the center of the viewport away from that
             * content. The order of the values in the array is top, right, bottom, left.
             * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
             * @type {Array<number>|undefined}
             * @api
             */
            this.padding = options.padding;
            /**
             * @private
             * @type {number}
             */
            this.minZoom_ = resolutionConstraintInfo.minZoom;
            var centerConstraint = createCenterConstraint(options);
            var resolutionConstraint = resolutionConstraintInfo.constraint;
            var rotationConstraint = createRotationConstraint(options);
            /**
             * @private
             * @type {Constraints}
             */
            this.constraints_ = {
                center: centerConstraint,
                resolution: resolutionConstraint,
                rotation: rotationConstraint,
            };
            this.setRotation(options.rotation !== undefined ? options.rotation : 0);
            this.setCenterInternal(options.center !== undefined ? options.center : null);
            if (options.resolution !== undefined) {
                this.setResolution(options.resolution);
            }
            else if (options.zoom !== undefined) {
                this.setZoom(options.zoom);
            }
            this.setProperties(properties);
            /**
             * @private
             * @type {ViewOptions}
             */
            this.options_ = options;
        };
        /**
         * Get an updated version of the view options used to construct the view.  The
         * current resolution (or zoom), center, and rotation are applied to any stored
         * options.  The provided options can be used to apply new min/max zoom or
         * resolution limits.
         * @param {ViewOptions} newOptions New options to be applied.
         * @return {ViewOptions} New options updated with the current view state.
         */
        View.prototype.getUpdatedOptions_ = function (newOptions) {
            var options = assign({}, this.options_);
            // preserve resolution (or zoom)
            if (options.resolution !== undefined) {
                options.resolution = this.getResolution();
            }
            else {
                options.zoom = this.getZoom();
            }
            // preserve center
            options.center = this.getCenterInternal();
            // preserve rotation
            options.rotation = this.getRotation();
            return assign({}, options, newOptions);
        };
        /**
         * Animate the view.  The view's center, zoom (or resolution), and rotation
         * can be animated for smooth transitions between view states.  For example,
         * to animate the view to a new zoom level:
         *
         *     view.animate({zoom: view.getZoom() + 1});
         *
         * By default, the animation lasts one second and uses in-and-out easing.  You
         * can customize this behavior by including `duration` (in milliseconds) and
         * `easing` options (see {@link module:ol/easing}).
         *
         * To chain together multiple animations, call the method with multiple
         * animation objects.  For example, to first zoom and then pan:
         *
         *     view.animate({zoom: 10}, {center: [0, 0]});
         *
         * If you provide a function as the last argument to the animate method, it
         * will get called at the end of an animation series.  The callback will be
         * called with `true` if the animation series completed on its own or `false`
         * if it was cancelled.
         *
         * Animations are cancelled by user interactions (e.g. dragging the map) or by
         * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
         * (or another method that calls one of these).
         *
         * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
         *     options.  Multiple animations can be run in series by passing multiple
         *     options objects.  To run multiple animations in parallel, call the method
         *     multiple times.  An optional callback can be provided as a final
         *     argument.  The callback will be called with a boolean indicating whether
         *     the animation completed without being cancelled.
         * @api
         */
        View.prototype.animate = function (var_args) {
            if (this.isDef() && !this.getAnimating()) {
                this.resolveConstraints(0);
            }
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; ++i) {
                var options = arguments[i];
                if (options.center) {
                    options = assign({}, options);
                    options.center = fromUserCoordinate(options.center, this.getProjection());
                }
                if (options.anchor) {
                    options = assign({}, options);
                    options.anchor = fromUserCoordinate(options.anchor, this.getProjection());
                }
                args[i] = options;
            }
            this.animateInternal.apply(this, args);
        };
        /**
         * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
         */
        View.prototype.animateInternal = function (var_args) {
            var animationCount = arguments.length;
            var callback;
            if (animationCount > 1 &&
                typeof arguments[animationCount - 1] === 'function') {
                callback = arguments[animationCount - 1];
                --animationCount;
            }
            if (!this.isDef()) {
                // if view properties are not yet set, shortcut to the final state
                var state = arguments[animationCount - 1];
                if (state.center) {
                    this.setCenterInternal(state.center);
                }
                if (state.zoom !== undefined) {
                    this.setZoom(state.zoom);
                }
                if (state.rotation !== undefined) {
                    this.setRotation(state.rotation);
                }
                if (callback) {
                    animationCallback(callback, true);
                }
                return;
            }
            var start = Date.now();
            var center = this.targetCenter_.slice();
            var resolution = this.targetResolution_;
            var rotation = this.targetRotation_;
            var series = [];
            for (var i = 0; i < animationCount; ++i) {
                var options = /** @type {AnimationOptions} */ (arguments[i]);
                var animation = {
                    start: start,
                    complete: false,
                    anchor: options.anchor,
                    duration: options.duration !== undefined ? options.duration : 1000,
                    easing: options.easing || inAndOut,
                    callback: callback,
                };
                if (options.center) {
                    animation.sourceCenter = center;
                    animation.targetCenter = options.center.slice();
                    center = animation.targetCenter;
                }
                if (options.zoom !== undefined) {
                    animation.sourceResolution = resolution;
                    animation.targetResolution = this.getResolutionForZoom(options.zoom);
                    resolution = animation.targetResolution;
                }
                else if (options.resolution) {
                    animation.sourceResolution = resolution;
                    animation.targetResolution = options.resolution;
                    resolution = animation.targetResolution;
                }
                if (options.rotation !== undefined) {
                    animation.sourceRotation = rotation;
                    var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
                    animation.targetRotation = rotation + delta;
                    rotation = animation.targetRotation;
                }
                // check if animation is a no-op
                if (isNoopAnimation(animation)) {
                    animation.complete = true;
                    // we still push it onto the series for callback handling
                }
                else {
                    start += animation.duration;
                }
                series.push(animation);
            }
            this.animations_.push(series);
            this.setHint(ViewHint.ANIMATING, 1);
            this.updateAnimations_();
        };
        /**
         * Determine if the view is being animated.
         * @return {boolean} The view is being animated.
         * @api
         */
        View.prototype.getAnimating = function () {
            return this.hints_[ViewHint.ANIMATING] > 0;
        };
        /**
         * Determine if the user is interacting with the view, such as panning or zooming.
         * @return {boolean} The view is being interacted with.
         * @api
         */
        View.prototype.getInteracting = function () {
            return this.hints_[ViewHint.INTERACTING] > 0;
        };
        /**
         * Cancel any ongoing animations.
         * @api
         */
        View.prototype.cancelAnimations = function () {
            this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);
            var anchor;
            for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
                var series = this.animations_[i];
                if (series[0].callback) {
                    animationCallback(series[0].callback, false);
                }
                if (!anchor) {
                    for (var j = 0, jj = series.length; j < jj; ++j) {
                        var animation = series[j];
                        if (!animation.complete) {
                            anchor = animation.anchor;
                            break;
                        }
                    }
                }
            }
            this.animations_.length = 0;
            this.cancelAnchor_ = anchor;
        };
        /**
         * Update all animations.
         */
        View.prototype.updateAnimations_ = function () {
            if (this.updateAnimationKey_ !== undefined) {
                cancelAnimationFrame(this.updateAnimationKey_);
                this.updateAnimationKey_ = undefined;
            }
            if (!this.getAnimating()) {
                return;
            }
            var now = Date.now();
            var more = false;
            for (var i = this.animations_.length - 1; i >= 0; --i) {
                var series = this.animations_[i];
                var seriesComplete = true;
                for (var j = 0, jj = series.length; j < jj; ++j) {
                    var animation = series[j];
                    if (animation.complete) {
                        continue;
                    }
                    var elapsed = now - animation.start;
                    var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
                    if (fraction >= 1) {
                        animation.complete = true;
                        fraction = 1;
                    }
                    else {
                        seriesComplete = false;
                    }
                    var progress = animation.easing(fraction);
                    if (animation.sourceCenter) {
                        var x0 = animation.sourceCenter[0];
                        var y0 = animation.sourceCenter[1];
                        var x1 = animation.targetCenter[0];
                        var y1 = animation.targetCenter[1];
                        var x = x0 + progress * (x1 - x0);
                        var y = y0 + progress * (y1 - y0);
                        this.targetCenter_ = [x, y];
                    }
                    if (animation.sourceResolution && animation.targetResolution) {
                        var resolution = progress === 1
                            ? animation.targetResolution
                            : animation.sourceResolution +
                                progress *
                                    (animation.targetResolution - animation.sourceResolution);
                        if (animation.anchor) {
                            var size = this.getViewportSize_(this.getRotation());
                            var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
                            this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
                        }
                        this.targetResolution_ = resolution;
                        this.applyTargetState_(true);
                    }
                    if (animation.sourceRotation !== undefined &&
                        animation.targetRotation !== undefined) {
                        var rotation = progress === 1
                            ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) -
                                Math.PI
                            : animation.sourceRotation +
                                progress *
                                    (animation.targetRotation - animation.sourceRotation);
                        if (animation.anchor) {
                            var constrainedRotation = this.constraints_.rotation(rotation, true);
                            this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
                        }
                        this.targetRotation_ = rotation;
                    }
                    this.applyTargetState_(true);
                    more = true;
                    if (!animation.complete) {
                        break;
                    }
                }
                if (seriesComplete) {
                    this.animations_[i] = null;
                    this.setHint(ViewHint.ANIMATING, -1);
                    var callback = series[0].callback;
                    if (callback) {
                        animationCallback(callback, true);
                    }
                }
            }
            // prune completed series
            this.animations_ = this.animations_.filter(Boolean);
            if (more && this.updateAnimationKey_ === undefined) {
                this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
            }
        };
        /**
         * @param {number} rotation Target rotation.
         * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
         * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
         */
        View.prototype.calculateCenterRotate = function (rotation, anchor) {
            var center;
            var currentCenter = this.getCenterInternal();
            if (currentCenter !== undefined) {
                center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
                rotate$1(center, rotation - this.getRotation());
                add(center, anchor);
            }
            return center;
        };
        /**
         * @param {number} resolution Target resolution.
         * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
         * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
         */
        View.prototype.calculateCenterZoom = function (resolution, anchor) {
            var center;
            var currentCenter = this.getCenterInternal();
            var currentResolution = this.getResolution();
            if (currentCenter !== undefined && currentResolution !== undefined) {
                var x = anchor[0] -
                    (resolution * (anchor[0] - currentCenter[0])) / currentResolution;
                var y = anchor[1] -
                    (resolution * (anchor[1] - currentCenter[1])) / currentResolution;
                center = [x, y];
            }
            return center;
        };
        /**
         * Returns the current viewport size.
         * @private
         * @param {number=} opt_rotation Take into account the rotation of the viewport when giving the size
         * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
         */
        View.prototype.getViewportSize_ = function (opt_rotation) {
            var size = this.viewportSize_;
            if (opt_rotation) {
                var w = size[0];
                var h = size[1];
                return [
                    Math.abs(w * Math.cos(opt_rotation)) +
                        Math.abs(h * Math.sin(opt_rotation)),
                    Math.abs(w * Math.sin(opt_rotation)) +
                        Math.abs(h * Math.cos(opt_rotation)),
                ];
            }
            else {
                return size;
            }
        };
        /**
         * Stores the viewport size on the view. The viewport size is not read every time from the DOM
         * to avoid performance hit and layout reflow.
         * This should be done on map size change.
         * Note: the constraints are not resolved during an animation to avoid stopping it
         * @param {import("./size.js").Size=} opt_size Viewport size; if undefined, [100, 100] is assumed
         */
        View.prototype.setViewportSize = function (opt_size) {
            this.viewportSize_ = Array.isArray(opt_size)
                ? opt_size.slice()
                : [100, 100];
            if (!this.getAnimating()) {
                this.resolveConstraints(0);
            }
        };
        /**
         * Get the view center.
         * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
         * @observable
         * @api
         */
        View.prototype.getCenter = function () {
            var center = this.getCenterInternal();
            if (!center) {
                return center;
            }
            return toUserCoordinate(center, this.getProjection());
        };
        /**
         * Get the view center without transforming to user projection.
         * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
         */
        View.prototype.getCenterInternal = function () {
            return /** @type {import("./coordinate.js").Coordinate|undefined} */ (this.get(ViewProperty.CENTER));
        };
        /**
         * @return {Constraints} Constraints.
         */
        View.prototype.getConstraints = function () {
            return this.constraints_;
        };
        /**
         * @return {boolean} Resolution constraint is set
         */
        View.prototype.getConstrainResolution = function () {
            return this.options_.constrainResolution;
        };
        /**
         * @param {Array<number>=} opt_hints Destination array.
         * @return {Array<number>} Hint.
         */
        View.prototype.getHints = function (opt_hints) {
            if (opt_hints !== undefined) {
                opt_hints[0] = this.hints_[0];
                opt_hints[1] = this.hints_[1];
                return opt_hints;
            }
            else {
                return this.hints_.slice();
            }
        };
        /**
         * Calculate the extent for the current view state and the passed size.
         * The size is the pixel dimensions of the box into which the calculated extent
         * should fit. In most cases you want to get the extent of the entire map,
         * that is `map.getSize()`.
         * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided, the size
         * of the map that uses this view will be used.
         * @return {import("./extent.js").Extent} Extent.
         * @api
         */
        View.prototype.calculateExtent = function (opt_size) {
            var extent = this.calculateExtentInternal(opt_size);
            return toUserExtent(extent, this.getProjection());
        };
        /**
         * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided,
         * the map's last known viewport size will be used.
         * @return {import("./extent.js").Extent} Extent.
         */
        View.prototype.calculateExtentInternal = function (opt_size) {
            var size = opt_size || this.getViewportSize_();
            var center = /** @type {!import("./coordinate.js").Coordinate} */ (this.getCenterInternal());
            assert(center, 1); // The view center is not defined
            var resolution = /** @type {!number} */ (this.getResolution());
            assert(resolution !== undefined, 2); // The view resolution is not defined
            var rotation = /** @type {!number} */ (this.getRotation());
            assert(rotation !== undefined, 3); // The view rotation is not defined
            return getForViewAndSize(center, resolution, rotation, size);
        };
        /**
         * Get the maximum resolution of the view.
         * @return {number} The maximum resolution of the view.
         * @api
         */
        View.prototype.getMaxResolution = function () {
            return this.maxResolution_;
        };
        /**
         * Get the minimum resolution of the view.
         * @return {number} The minimum resolution of the view.
         * @api
         */
        View.prototype.getMinResolution = function () {
            return this.minResolution_;
        };
        /**
         * Get the maximum zoom level for the view.
         * @return {number} The maximum zoom level.
         * @api
         */
        View.prototype.getMaxZoom = function () {
            return /** @type {number} */ (this.getZoomForResolution(this.minResolution_));
        };
        /**
         * Set a new maximum zoom level for the view.
         * @param {number} zoom The maximum zoom level.
         * @api
         */
        View.prototype.setMaxZoom = function (zoom) {
            this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
        };
        /**
         * Get the minimum zoom level for the view.
         * @return {number} The minimum zoom level.
         * @api
         */
        View.prototype.getMinZoom = function () {
            return /** @type {number} */ (this.getZoomForResolution(this.maxResolution_));
        };
        /**
         * Set a new minimum zoom level for the view.
         * @param {number} zoom The minimum zoom level.
         * @api
         */
        View.prototype.setMinZoom = function (zoom) {
            this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
        };
        /**
         * Set whether the view shoud allow intermediary zoom levels.
         * @param {boolean} enabled Whether the resolution is constrained.
         * @api
         */
        View.prototype.setConstrainResolution = function (enabled) {
            this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
        };
        /**
         * Get the view projection.
         * @return {import("./proj/Projection.js").default} The projection of the view.
         * @api
         */
        View.prototype.getProjection = function () {
            return this.projection_;
        };
        /**
         * Get the view resolution.
         * @return {number|undefined} The resolution of the view.
         * @observable
         * @api
         */
        View.prototype.getResolution = function () {
            return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));
        };
        /**
         * Get the resolutions for the view. This returns the array of resolutions
         * passed to the constructor of the View, or undefined if none were given.
         * @return {Array<number>|undefined} The resolutions of the view.
         * @api
         */
        View.prototype.getResolutions = function () {
            return this.resolutions_;
        };
        /**
         * Get the resolution for a provided extent (in map units) and size (in pixels).
         * @param {import("./extent.js").Extent} extent Extent.
         * @param {import("./size.js").Size=} opt_size Box pixel size.
         * @return {number} The resolution at which the provided extent will render at
         *     the given size.
         * @api
         */
        View.prototype.getResolutionForExtent = function (extent, opt_size) {
            return this.getResolutionForExtentInternal(fromUserExtent(extent, this.getProjection()), opt_size);
        };
        /**
         * Get the resolution for a provided extent (in map units) and size (in pixels).
         * @param {import("./extent.js").Extent} extent Extent.
         * @param {import("./size.js").Size=} opt_size Box pixel size.
         * @return {number} The resolution at which the provided extent will render at
         *     the given size.
         */
        View.prototype.getResolutionForExtentInternal = function (extent, opt_size) {
            var size = opt_size || this.getViewportSize_();
            var xResolution = getWidth(extent) / size[0];
            var yResolution = getHeight(extent) / size[1];
            return Math.max(xResolution, yResolution);
        };
        /**
         * Return a function that returns a value between 0 and 1 for a
         * resolution. Exponential scaling is assumed.
         * @param {number=} opt_power Power.
         * @return {function(number): number} Resolution for value function.
         */
        View.prototype.getResolutionForValueFunction = function (opt_power) {
            var power = opt_power || 2;
            var maxResolution = this.getConstrainedResolution(this.maxResolution_);
            var minResolution = this.minResolution_;
            var max = Math.log(maxResolution / minResolution) / Math.log(power);
            return (
            /**
             * @param {number} value Value.
             * @return {number} Resolution.
             */
            function (value) {
                var resolution = maxResolution / Math.pow(power, value * max);
                return resolution;
            });
        };
        /**
         * Get the view rotation.
         * @return {number} The rotation of the view in radians.
         * @observable
         * @api
         */
        View.prototype.getRotation = function () {
            return /** @type {number} */ (this.get(ViewProperty.ROTATION));
        };
        /**
         * Return a function that returns a resolution for a value between
         * 0 and 1. Exponential scaling is assumed.
         * @param {number=} opt_power Power.
         * @return {function(number): number} Value for resolution function.
         */
        View.prototype.getValueForResolutionFunction = function (opt_power) {
            var logPower = Math.log(opt_power || 2);
            var maxResolution = this.getConstrainedResolution(this.maxResolution_);
            var minResolution = this.minResolution_;
            var max = Math.log(maxResolution / minResolution) / logPower;
            return (
            /**
             * @param {number} resolution Resolution.
             * @return {number} Value.
             */
            function (resolution) {
                var value = Math.log(maxResolution / resolution) / logPower / max;
                return value;
            });
        };
        /**
         * Returns the size of the viewport minus padding.
         * @private
         * @param {number=} opt_rotation Take into account the rotation of the viewport when giving the size
         * @return {import("./size.js").Size} Viewport size reduced by the padding.
         */
        View.prototype.getViewportSizeMinusPadding_ = function (opt_rotation) {
            var size = this.getViewportSize_(opt_rotation);
            var padding = this.padding;
            if (padding) {
                size = [
                    size[0] - padding[1] - padding[3],
                    size[1] - padding[0] - padding[2],
                ];
            }
            return size;
        };
        /**
         * @return {State} View state.
         */
        View.prototype.getState = function () {
            var projection = this.getProjection();
            var resolution = /** @type {number} */ (this.getResolution());
            var rotation = this.getRotation();
            var center = /** @type {import("./coordinate.js").Coordinate} */ (this.getCenterInternal());
            var padding = this.padding;
            if (padding) {
                var reducedSize = this.getViewportSizeMinusPadding_();
                center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
            }
            return {
                center: center.slice(0),
                projection: projection !== undefined ? projection : null,
                resolution: resolution,
                rotation: rotation,
                zoom: this.getZoom(),
            };
        };
        /**
         * Get the current zoom level. This method may return non-integer zoom levels
         * if the view does not constrain the resolution, or if an interaction or
         * animation is underway.
         * @return {number|undefined} Zoom.
         * @api
         */
        View.prototype.getZoom = function () {
            var zoom;
            var resolution = this.getResolution();
            if (resolution !== undefined) {
                zoom = this.getZoomForResolution(resolution);
            }
            return zoom;
        };
        /**
         * Get the zoom level for a resolution.
         * @param {number} resolution The resolution.
         * @return {number|undefined} The zoom level for the provided resolution.
         * @api
         */
        View.prototype.getZoomForResolution = function (resolution) {
            var offset = this.minZoom_ || 0;
            var max, zoomFactor;
            if (this.resolutions_) {
                var nearest = linearFindNearest(this.resolutions_, resolution, 1);
                offset = nearest;
                max = this.resolutions_[nearest];
                if (nearest == this.resolutions_.length - 1) {
                    zoomFactor = 2;
                }
                else {
                    zoomFactor = max / this.resolutions_[nearest + 1];
                }
            }
            else {
                max = this.maxResolution_;
                zoomFactor = this.zoomFactor_;
            }
            return offset + Math.log(max / resolution) / Math.log(zoomFactor);
        };
        /**
         * Get the resolution for a zoom level.
         * @param {number} zoom Zoom level.
         * @return {number} The view resolution for the provided zoom level.
         * @api
         */
        View.prototype.getResolutionForZoom = function (zoom) {
            if (this.resolutions_) {
                if (this.resolutions_.length <= 1) {
                    return 0;
                }
                var baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);
                var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
                return (this.resolutions_[baseLevel] /
                    Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1)));
            }
            else {
                return (this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_));
            }
        };
        /**
         * Fit the given geometry or extent based on the given map size and border.
         * The size is pixel dimensions of the box to fit the extent into.
         * In most cases you will want to use the map size, that is `map.getSize()`.
         * Takes care of the map angle.
         * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
         *     extent to fit the view to.
         * @param {FitOptions=} opt_options Options.
         * @api
         */
        View.prototype.fit = function (geometryOrExtent, opt_options) {
            /** @type {import("./geom/SimpleGeometry.js").default} */
            var geometry;
            assert(Array.isArray(geometryOrExtent) ||
                typeof ( /** @type {?} */(geometryOrExtent).getSimplifiedGeometry) ===
                    'function', 24); // Invalid extent or geometry provided as `geometry`
            if (Array.isArray(geometryOrExtent)) {
                assert(!isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`
                var extent = fromUserExtent(geometryOrExtent, this.getProjection());
                geometry = fromExtent(extent);
            }
            else if (geometryOrExtent.getType() === GeometryType.CIRCLE) {
                var extent = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());
                geometry = fromExtent(extent);
                geometry.rotate(this.getRotation(), getCenter(extent));
            }
            else {
                var userProjection = getUserProjection();
                if (userProjection) {
                    geometry = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometryOrExtent
                        .clone()
                        .transform(userProjection, this.getProjection()));
                }
                else {
                    geometry = geometryOrExtent;
                }
            }
            this.fitInternal(geometry, opt_options);
        };
        /**
         * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
         * @param {FitOptions=} opt_options Options.
         */
        View.prototype.fitInternal = function (geometry, opt_options) {
            var options = opt_options || {};
            var size = options.size;
            if (!size) {
                size = this.getViewportSizeMinusPadding_();
            }
            var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
            var nearest = options.nearest !== undefined ? options.nearest : false;
            var minResolution;
            if (options.minResolution !== undefined) {
                minResolution = options.minResolution;
            }
            else if (options.maxZoom !== undefined) {
                minResolution = this.getResolutionForZoom(options.maxZoom);
            }
            else {
                minResolution = 0;
            }
            var coords = geometry.getFlatCoordinates();
            // calculate rotated extent
            var rotation = this.getRotation();
            var cosAngle = Math.cos(-rotation);
            var sinAngle = Math.sin(-rotation);
            var minRotX = +Infinity;
            var minRotY = +Infinity;
            var maxRotX = -Infinity;
            var maxRotY = -Infinity;
            var stride = geometry.getStride();
            for (var i = 0, ii = coords.length; i < ii; i += stride) {
                var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
                var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
                minRotX = Math.min(minRotX, rotX);
                minRotY = Math.min(minRotY, rotY);
                maxRotX = Math.max(maxRotX, rotX);
                maxRotY = Math.max(maxRotY, rotY);
            }
            // calculate resolution
            var resolution = this.getResolutionForExtentInternal([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
            resolution = isNaN(resolution)
                ? minResolution
                : Math.max(resolution, minResolution);
            resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
            // calculate center
            sinAngle = -sinAngle; // go back to original rotation
            var centerRotX = (minRotX + maxRotX) / 2;
            var centerRotY = (minRotY + maxRotY) / 2;
            centerRotX += ((padding[1] - padding[3]) / 2) * resolution;
            centerRotY += ((padding[0] - padding[2]) / 2) * resolution;
            var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
            var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
            var center = this.getConstrainedCenter([centerX, centerY], resolution);
            var callback = options.callback ? options.callback : VOID;
            if (options.duration !== undefined) {
                this.animateInternal({
                    resolution: resolution,
                    center: center,
                    duration: options.duration,
                    easing: options.easing,
                }, callback);
            }
            else {
                this.targetResolution_ = resolution;
                this.targetCenter_ = center;
                this.applyTargetState_(false, true);
                animationCallback(callback, true);
            }
        };
        /**
         * Center on coordinate and view position.
         * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
         * @param {import("./size.js").Size} size Box pixel size.
         * @param {import("./pixel.js").Pixel} position Position on the view to center on.
         * @api
         */
        View.prototype.centerOn = function (coordinate, size, position) {
            this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position);
        };
        /**
         * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
         * @param {import("./size.js").Size} size Box pixel size.
         * @param {import("./pixel.js").Pixel} position Position on the view to center on.
         */
        View.prototype.centerOnInternal = function (coordinate, size, position) {
            this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
        };
        /**
         * Calculates the shift between map and viewport center.
         * @param {import("./coordinate.js").Coordinate} center Center.
         * @param {number} resolution Resolution.
         * @param {number} rotation Rotation.
         * @param {import("./size.js").Size} size Size.
         * @return {Array<number>|undefined} Center shift.
         */
        View.prototype.calculateCenterShift = function (center, resolution, rotation, size) {
            var centerShift;
            var padding = this.padding;
            if (padding && center) {
                var reducedSize = this.getViewportSizeMinusPadding_(-rotation);
                var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
                centerShift = [
                    center[0] - shiftedCenter[0],
                    center[1] - shiftedCenter[1],
                ];
            }
            return centerShift;
        };
        /**
         * @return {boolean} Is defined.
         */
        View.prototype.isDef = function () {
            return !!this.getCenterInternal() && this.getResolution() !== undefined;
        };
        /**
         * Adds relative coordinates to the center of the view. Any extent constraint will apply.
         * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
         * @api
         */
        View.prototype.adjustCenter = function (deltaCoordinates) {
            var center = toUserCoordinate(this.targetCenter_, this.getProjection());
            this.setCenter([
                center[0] + deltaCoordinates[0],
                center[1] + deltaCoordinates[1],
            ]);
        };
        /**
         * Adds relative coordinates to the center of the view. Any extent constraint will apply.
         * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
         */
        View.prototype.adjustCenterInternal = function (deltaCoordinates) {
            var center = this.targetCenter_;
            this.setCenterInternal([
                center[0] + deltaCoordinates[0],
                center[1] + deltaCoordinates[1],
            ]);
        };
        /**
         * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
         * constraint will apply.
         * @param {number} ratio The ratio to apply on the view resolution.
         * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
         * @api
         */
        View.prototype.adjustResolution = function (ratio, opt_anchor) {
            var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
            this.adjustResolutionInternal(ratio, anchor);
        };
        /**
         * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
         * constraint will apply.
         * @param {number} ratio The ratio to apply on the view resolution.
         * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
         */
        View.prototype.adjustResolutionInternal = function (ratio, opt_anchor) {
            var isMoving = this.getAnimating() || this.getInteracting();
            var size = this.getViewportSize_(this.getRotation());
            var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
            if (opt_anchor) {
                this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
            }
            this.targetResolution_ *= ratio;
            this.applyTargetState_();
        };
        /**
         * Adds a value to the view zoom level, optionally using an anchor. Any resolution
         * constraint will apply.
         * @param {number} delta Relative value to add to the zoom level.
         * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
         * @api
         */
        View.prototype.adjustZoom = function (delta, opt_anchor) {
            this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
        };
        /**
         * Adds a value to the view rotation, optionally using an anchor. Any rotation
         * constraint will apply.
         * @param {number} delta Relative value to add to the zoom rotation, in radians.
         * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
         * @api
         */
        View.prototype.adjustRotation = function (delta, opt_anchor) {
            if (opt_anchor) {
                opt_anchor = fromUserCoordinate(opt_anchor, this.getProjection());
            }
            this.adjustRotationInternal(delta, opt_anchor);
        };
        /**
         * @param {number} delta Relative value to add to the zoom rotation, in radians.
         * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
         */
        View.prototype.adjustRotationInternal = function (delta, opt_anchor) {
            var isMoving = this.getAnimating() || this.getInteracting();
            var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
            if (opt_anchor) {
                this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
            }
            this.targetRotation_ += delta;
            this.applyTargetState_();
        };
        /**
         * Set the center of the current view. Any extent constraint will apply.
         * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
         * @observable
         * @api
         */
        View.prototype.setCenter = function (center) {
            this.setCenterInternal(fromUserCoordinate(center, this.getProjection()));
        };
        /**
         * Set the center using the view projection (not the user projection).
         * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
         */
        View.prototype.setCenterInternal = function (center) {
            this.targetCenter_ = center;
            this.applyTargetState_();
        };
        /**
         * @param {import("./ViewHint.js").default} hint Hint.
         * @param {number} delta Delta.
         * @return {number} New value.
         */
        View.prototype.setHint = function (hint, delta) {
            this.hints_[hint] += delta;
            this.changed();
            return this.hints_[hint];
        };
        /**
         * Set the resolution for this view. Any resolution constraint will apply.
         * @param {number|undefined} resolution The resolution of the view.
         * @observable
         * @api
         */
        View.prototype.setResolution = function (resolution) {
            this.targetResolution_ = resolution;
            this.applyTargetState_();
        };
        /**
         * Set the rotation for this view. Any rotation constraint will apply.
         * @param {number} rotation The rotation of the view in radians.
         * @observable
         * @api
         */
        View.prototype.setRotation = function (rotation) {
            this.targetRotation_ = rotation;
            this.applyTargetState_();
        };
        /**
         * Zoom to a specific zoom level. Any resolution constrain will apply.
         * @param {number} zoom Zoom level.
         * @api
         */
        View.prototype.setZoom = function (zoom) {
            this.setResolution(this.getResolutionForZoom(zoom));
        };
        /**
         * Recompute rotation/resolution/center based on target values.
         * Note: we have to compute rotation first, then resolution and center considering that
         * parameters can influence one another in case a view extent constraint is present.
         * @param {boolean=} opt_doNotCancelAnims Do not cancel animations.
         * @param {boolean=} opt_forceMoving Apply constraints as if the view is moving.
         * @private
         */
        View.prototype.applyTargetState_ = function (opt_doNotCancelAnims, opt_forceMoving) {
            var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving;
            // compute rotation
            var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
            var size = this.getViewportSize_(newRotation);
            var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
            var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
            if (this.get(ViewProperty.ROTATION) !== newRotation) {
                this.set(ViewProperty.ROTATION, newRotation);
            }
            if (this.get(ViewProperty.RESOLUTION) !== newResolution) {
                this.set(ViewProperty.RESOLUTION, newResolution);
            }
            if (!this.get(ViewProperty.CENTER) ||
                !equals(this.get(ViewProperty.CENTER), newCenter)) {
                this.set(ViewProperty.CENTER, newCenter);
            }
            if (this.getAnimating() && !opt_doNotCancelAnims) {
                this.cancelAnimations();
            }
            this.cancelAnchor_ = undefined;
        };
        /**
         * If any constraints need to be applied, an animation will be triggered.
         * This is typically done on interaction end.
         * Note: calling this with a duration of 0 will apply the constrained values straight away,
         * without animation.
         * @param {number=} opt_duration The animation duration in ms.
         * @param {number=} opt_resolutionDirection Which direction to zoom.
         * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
         */
        View.prototype.resolveConstraints = function (opt_duration, opt_resolutionDirection, opt_anchor) {
            var duration = opt_duration !== undefined ? opt_duration : 200;
            var direction = opt_resolutionDirection || 0;
            var newRotation = this.constraints_.rotation(this.targetRotation_);
            var size = this.getViewportSize_(newRotation);
            var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
            var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
            if (duration === 0 && !this.cancelAnchor_) {
                this.targetResolution_ = newResolution;
                this.targetRotation_ = newRotation;
                this.targetCenter_ = newCenter;
                this.applyTargetState_();
                return;
            }
            var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
            this.cancelAnchor_ = undefined;
            if (this.getResolution() !== newResolution ||
                this.getRotation() !== newRotation ||
                !this.getCenterInternal() ||
                !equals(this.getCenterInternal(), newCenter)) {
                if (this.getAnimating()) {
                    this.cancelAnimations();
                }
                this.animateInternal({
                    rotation: newRotation,
                    center: newCenter,
                    resolution: newResolution,
                    duration: duration,
                    easing: easeOut,
                    anchor: anchor,
                });
            }
        };
        /**
         * Notify the View that an interaction has started.
         * The view state will be resolved to a stable one if needed
         * (depending on its constraints).
         * @api
         */
        View.prototype.beginInteraction = function () {
            this.resolveConstraints(0);
            this.setHint(ViewHint.INTERACTING, 1);
        };
        /**
         * Notify the View that an interaction has ended. The view state will be resolved
         * to a stable one if needed (depending on its constraints).
         * @param {number=} opt_duration Animation duration in ms.
         * @param {number=} opt_resolutionDirection Which direction to zoom.
         * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
         * @api
         */
        View.prototype.endInteraction = function (opt_duration, opt_resolutionDirection, opt_anchor) {
            var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
            this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
        };
        /**
         * Notify the View that an interaction has ended. The view state will be resolved
         * to a stable one if needed (depending on its constraints).
         * @param {number=} opt_duration Animation duration in ms.
         * @param {number=} opt_resolutionDirection Which direction to zoom.
         * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
         */
        View.prototype.endInteractionInternal = function (opt_duration, opt_resolutionDirection, opt_anchor) {
            this.setHint(ViewHint.INTERACTING, -1);
            this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
        };
        /**
         * Get a valid position for the view center according to the current constraints.
         * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
         * @param {number=} opt_targetResolution Target resolution. If not supplied, the current one will be used.
         * This is useful to guess a valid center position at a different zoom level.
         * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
         */
        View.prototype.getConstrainedCenter = function (targetCenter, opt_targetResolution) {
            var size = this.getViewportSize_(this.getRotation());
            return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
        };
        /**
         * Get a valid zoom level according to the current view constraints.
         * @param {number|undefined} targetZoom Target zoom.
         * @param {number=} [opt_direction=0] Indicate which resolution should be used
         * by a renderer if the view resolution does not match any resolution of the tile source.
         * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
         * will be used. If -1, the nearest higher resolution will be used.
         * @return {number|undefined} Valid zoom level.
         */
        View.prototype.getConstrainedZoom = function (targetZoom, opt_direction) {
            var targetRes = this.getResolutionForZoom(targetZoom);
            return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
        };
        /**
         * Get a valid resolution according to the current view constraints.
         * @param {number|undefined} targetResolution Target resolution.
         * @param {number=} [opt_direction=0] Indicate which resolution should be used
         * by a renderer if the view resolution does not match any resolution of the tile source.
         * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
         * will be used. If -1, the nearest higher resolution will be used.
         * @return {number|undefined} Valid resolution.
         */
        View.prototype.getConstrainedResolution = function (targetResolution, opt_direction) {
            var direction = opt_direction || 0;
            var size = this.getViewportSize_(this.getRotation());
            return this.constraints_.resolution(targetResolution, direction, size);
        };
        return View;
    }(BaseObject));
    /**
     * @param {Function} callback Callback.
     * @param {*} returnValue Return value.
     */
    function animationCallback(callback, returnValue) {
        setTimeout(function () {
            callback(returnValue);
        }, 0);
    }
    /**
     * @param {ViewOptions} options View options.
     * @return {import("./centerconstraint.js").Type} The constraint.
     */
    function createCenterConstraint(options) {
        if (options.extent !== undefined) {
            var smooth = options.smoothExtentConstraint !== undefined
                ? options.smoothExtentConstraint
                : true;
            return createExtent(options.extent, options.constrainOnlyCenter, smooth);
        }
        var projection = createProjection(options.projection, 'EPSG:3857');
        if (options.multiWorld !== true && projection.isGlobal()) {
            var extent = projection.getExtent().slice();
            extent[0] = -Infinity;
            extent[2] = Infinity;
            return createExtent(extent, false, false);
        }
        return none$1;
    }
    /**
     * @param {ViewOptions} options View options.
     * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
     *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
     */
    function createResolutionConstraint(options) {
        var resolutionConstraint;
        var maxResolution;
        var minResolution;
        // TODO: move these to be ol constants
        // see https://github.com/openlayers/openlayers/issues/2076
        var defaultMaxZoom = 28;
        var defaultZoomFactor = 2;
        var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
        var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
        var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
        var multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
        var smooth = options.smoothResolutionConstraint !== undefined
            ? options.smoothResolutionConstraint
            : true;
        var showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
        var projection = createProjection(options.projection, 'EPSG:3857');
        var projExtent = projection.getExtent();
        var constrainOnlyCenter = options.constrainOnlyCenter;
        var extent = options.extent;
        if (!multiWorld && !extent && projection.isGlobal()) {
            constrainOnlyCenter = false;
            extent = projExtent;
        }
        if (options.resolutions !== undefined) {
            var resolutions = options.resolutions;
            maxResolution = resolutions[minZoom];
            minResolution =
                resolutions[maxZoom] !== undefined
                    ? resolutions[maxZoom]
                    : resolutions[resolutions.length - 1];
            if (options.constrainResolution) {
                resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
            }
            else {
                resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
            }
        }
        else {
            // calculate the default min and max resolution
            var size = !projExtent
                ? // use an extent that can fit the whole world if need be
                    (360 * METERS_PER_UNIT$1[Units.DEGREES]) / projection.getMetersPerUnit()
                : Math.max(getWidth(projExtent), getHeight(projExtent));
            var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
            var defaultMinResolution = defaultMaxResolution /
                Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
            // user provided maxResolution takes precedence
            maxResolution = options.maxResolution;
            if (maxResolution !== undefined) {
                minZoom = 0;
            }
            else {
                maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
            }
            // user provided minResolution takes precedence
            minResolution = options.minResolution;
            if (minResolution === undefined) {
                if (options.maxZoom !== undefined) {
                    if (options.maxResolution !== undefined) {
                        minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
                    }
                    else {
                        minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
                    }
                }
                else {
                    minResolution = defaultMinResolution;
                }
            }
            // given discrete zoom levels, minResolution may be different than provided
            maxZoom =
                minZoom +
                    Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
            minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
            if (options.constrainResolution) {
                resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
            }
            else {
                resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
            }
        }
        return {
            constraint: resolutionConstraint,
            maxResolution: maxResolution,
            minResolution: minResolution,
            minZoom: minZoom,
            zoomFactor: zoomFactor,
        };
    }
    /**
     * @param {ViewOptions} options View options.
     * @return {import("./rotationconstraint.js").Type} Rotation constraint.
     */
    function createRotationConstraint(options) {
        var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
        if (enableRotation) {
            var constrainRotation = options.constrainRotation;
            if (constrainRotation === undefined || constrainRotation === true) {
                return createSnapToZero();
            }
            else if (constrainRotation === false) {
                return none;
            }
            else if (typeof constrainRotation === 'number') {
                return createSnapToN(constrainRotation);
            }
            else {
                return none;
            }
        }
        else {
            return disable;
        }
    }
    /**
     * Determine if an animation involves no view change.
     * @param {Animation} animation The animation.
     * @return {boolean} The animation involves no view change.
     */
    function isNoopAnimation(animation) {
        if (animation.sourceCenter && animation.targetCenter) {
            if (!equals(animation.sourceCenter, animation.targetCenter)) {
                return false;
            }
        }
        if (animation.sourceResolution !== animation.targetResolution) {
            return false;
        }
        if (animation.sourceRotation !== animation.targetRotation) {
            return false;
        }
        return true;
    }
    /**
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @return {import("./coordinate.js").Coordinate} Shifted center.
     */
    function calculateCenterOn(coordinate, size, position, resolution, rotation) {
        // calculate rotated position
        var cosAngle = Math.cos(-rotation);
        var sinAngle = Math.sin(-rotation);
        var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
        var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
        rotX += (size[0] / 2 - position[0]) * resolution;
        rotY += (position[1] - size[1] / 2) * resolution;
        // go back to original angle
        sinAngle = -sinAngle; // go back to original rotation
        var centerX = rotX * cosAngle - rotY * sinAngle;
        var centerY = rotY * cosAngle + rotX * sinAngle;
        return [centerX, centerY];
    }

    var __extends$r = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
     * be used in applications.
     * @typedef {Object} FrameState
     * @property {number} pixelRatio The pixel ratio of the frame.
     * @property {number} time The time when rendering of the frame was requested.
     * @property {import("./View.js").State} viewState The state of the current view.
     * @property {boolean} animate
     * @property {import("./transform.js").Transform} coordinateToPixelTransform
     * @property {import("rbush").default} declutterTree
     * @property {null|import("./extent.js").Extent} extent
     * @property {number} index
     * @property {Array<import("./layer/Layer.js").State>} layerStatesArray
     * @property {number} layerIndex
     * @property {import("./transform.js").Transform} pixelToCoordinateTransform
     * @property {Array<PostRenderFunction>} postRenderFunctions
     * @property {import("./size.js").Size} size
     * @property {TileQueue} tileQueue
     * @property {!Object<string, Object<string, boolean>>} usedTiles
     * @property {Array<number>} viewHints
     * @property {!Object<string, Object<string, boolean>>} wantedTiles
     */
    /**
     * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction
     */
    /**
     * @typedef {Object} AtPixelOptions
     * @property {undefined|function(import("./layer/Layer.js").default): boolean} [layerFilter] Layer filter
     * function. The filter function will receive one argument, the
     * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.
     * Only layers which are visible and for which this function returns `true`
     * will be tested for features. By default, all visible layers will be tested.
     * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels
     * inside the radius around the given position will be checked for features.
     * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of
     *   +/- 1 world width. Works only if a projection is used that can be wrapped.
     */
    /**
     * @typedef {Object} MapOptionsInternal
     * @property {Collection<import("./control/Control.js").default>} [controls]
     * @property {Collection<import("./interaction/Interaction.js").default>} [interactions]
     * @property {HTMLElement|Document} keyboardEventTarget
     * @property {Collection<import("./Overlay.js").default>} overlays
     * @property {Object<string, *>} values
     */
    /**
     * Object literal with config options for the map.
     * @typedef {Object} MapOptions
     * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
     * Controls initially added to the map. If not specified,
     * {@link module:ol/control~defaults} is used.
     * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
     * physical pixels and device-independent pixels (dips) on the device.
     * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
     * Interactions that are initially added to the map. If not specified,
     * {@link module:ol/interaction~defaults} is used.
     * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
     * listen to keyboard events on. This determines when the `KeyboardPan` and
     * `KeyboardZoom` interactions trigger. For example, if this option is set to
     * `document` the keyboard interactions will always trigger. If this option is
     * not specified, the element the library listens to keyboard events on is the
     * map target (i.e. the user-provided div for the map). If this is not
     * `document`, the target element needs to be focused for key events to be
     * emitted, requiring that the target element has a `tabindex` attribute.
     * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
     * Layers. If this is not defined, a map with no layers will be rendered. Note
     * that layers are rendered in the order supplied, so if you want, for example,
     * a vector layer to appear on top of a tile layer, it must come after the tile
     * layer.
     * @property {number} [maxTilesLoading=16] Maximum number tiles to load
     * simultaneously.
     * @property {number} [moveTolerance=1] The minimum distance in pixels the
     * cursor must move to be detected as a map move event instead of a click.
     * Increasing this value can make it easier to click on the map.
     * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
     * Overlays initially added to the map. By default, no overlays are added.
     * @property {HTMLElement|string} [target] The container for the map, either the
     * element itself or the `id` of the element. If not specified at construction
     * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
     * rendered. If passed by element, the container can be in a secondary document.
     * @property {View} [view] The map's view.  No layer sources will be
     * fetched unless this is specified at construction time or through
     * {@link module:ol/Map~Map#setView}.
     */
    /**
     * @fires import("./MapBrowserEvent.js").MapBrowserEvent
     * @fires import("./MapEvent.js").MapEvent
     * @fires import("./render/Event.js").default#precompose
     * @fires import("./render/Event.js").default#postcompose
     * @fires import("./render/Event.js").default#rendercomplete
     * @api
     */
    var PluggableMap = /** @class */ (function (_super) {
        __extends$r(PluggableMap, _super);
        /**
         * @param {MapOptions} options Map options.
         */
        function PluggableMap(options) {
            var _this = _super.call(this) || this;
            var optionsInternal = createOptionsInternal(options);
            /** @private */
            _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);
            /**
             * @type {number}
             * @private
             */
            _this.maxTilesLoading_ =
                options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
            /**
             * @private
             * @type {number}
             */
            _this.pixelRatio_ =
                options.pixelRatio !== undefined
                    ? options.pixelRatio
                    : DEVICE_PIXEL_RATIO;
            /**
             * @private
             * @type {*}
             */
            _this.postRenderTimeoutHandle_;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.animationDelayKey_;
            /**
             * @private
             */
            _this.animationDelay_ = /** @this {PluggableMap} */ function () {
                this.animationDelayKey_ = undefined;
                this.renderFrame_(Date.now());
            }.bind(_this);
            /**
             * @private
             * @type {import("./transform.js").Transform}
             */
            _this.coordinateToPixelTransform_ = create();
            /**
             * @private
             * @type {import("./transform.js").Transform}
             */
            _this.pixelToCoordinateTransform_ = create();
            /**
             * @private
             * @type {number}
             */
            _this.frameIndex_ = 0;
            /**
             * @private
             * @type {?FrameState}
             */
            _this.frameState_ = null;
            /**
             * The extent at the previous 'moveend' event.
             * @private
             * @type {import("./extent.js").Extent}
             */
            _this.previousExtent_ = null;
            /**
             * @private
             * @type {?import("./events.js").EventsKey}
             */
            _this.viewPropertyListenerKey_ = null;
            /**
             * @private
             * @type {?import("./events.js").EventsKey}
             */
            _this.viewChangeListenerKey_ = null;
            /**
             * @private
             * @type {?Array<import("./events.js").EventsKey>}
             */
            _this.layerGroupPropertyListenerKeys_ = null;
            /**
             * @private
             * @type {!HTMLElement}
             */
            _this.viewport_ = document.createElement('div');
            _this.viewport_.className =
                'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
            _this.viewport_.style.position = 'relative';
            _this.viewport_.style.overflow = 'hidden';
            _this.viewport_.style.width = '100%';
            _this.viewport_.style.height = '100%';
            /**
             * @private
             * @type {!HTMLElement}
             */
            _this.overlayContainer_ = document.createElement('div');
            _this.overlayContainer_.style.position = 'absolute';
            _this.overlayContainer_.style.zIndex = '0';
            _this.overlayContainer_.style.width = '100%';
            _this.overlayContainer_.style.height = '100%';
            _this.overlayContainer_.style.pointerEvents = 'none';
            _this.overlayContainer_.className = 'ol-overlaycontainer';
            _this.viewport_.appendChild(_this.overlayContainer_);
            /**
             * @private
             * @type {!HTMLElement}
             */
            _this.overlayContainerStopEvent_ = document.createElement('div');
            _this.overlayContainerStopEvent_.style.position = 'absolute';
            _this.overlayContainerStopEvent_.style.zIndex = '0';
            _this.overlayContainerStopEvent_.style.width = '100%';
            _this.overlayContainerStopEvent_.style.height = '100%';
            _this.overlayContainerStopEvent_.style.pointerEvents = 'none';
            _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
            _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
            /**
             * @private
             * @type {MapBrowserEventHandler}
             */
            _this.mapBrowserEventHandler_ = null;
            /**
             * @private
             * @type {number}
             */
            _this.moveTolerance_ = options.moveTolerance;
            /**
             * @private
             * @type {HTMLElement|Document}
             */
            _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
            /**
             * @private
             * @type {?Array<import("./events.js").EventsKey>}
             */
            _this.keyHandlerKeys_ = null;
            /**
             * @type {Collection<import("./control/Control.js").default>}
             * @protected
             */
            _this.controls = optionsInternal.controls || new Collection();
            /**
             * @type {Collection<import("./interaction/Interaction.js").default>}
             * @protected
             */
            _this.interactions = optionsInternal.interactions || new Collection();
            /**
             * @type {Collection<import("./Overlay.js").default>}
             * @private
             */
            _this.overlays_ = optionsInternal.overlays;
            /**
             * A lookup of overlays by id.
             * @private
             * @type {Object<string, import("./Overlay.js").default>}
             */
            _this.overlayIdIndex_ = {};
            /**
             * @type {import("./renderer/Map.js").default}
             * @private
             */
            _this.renderer_ = null;
            /**
             * @type {undefined|function(Event): void}
             * @private
             */
            _this.handleResize_;
            /**
             * @private
             * @type {!Array<PostRenderFunction>}
             */
            _this.postRenderFunctions_ = [];
            /**
             * @private
             * @type {TileQueue}
             */
            _this.tileQueue_ = new TileQueue(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));
            _this.addEventListener(getChangeEventType(MapProperty.LAYERGROUP), _this.handleLayerGroupChanged_);
            _this.addEventListener(getChangeEventType(MapProperty.VIEW), _this.handleViewChanged_);
            _this.addEventListener(getChangeEventType(MapProperty.SIZE), _this.handleSizeChanged_);
            _this.addEventListener(getChangeEventType(MapProperty.TARGET), _this.handleTargetChanged_);
            // setProperties will trigger the rendering of the map if the map
            // is "defined" already.
            _this.setProperties(optionsInternal.values);
            _this.controls.forEach(
            /**
             * @param {import("./control/Control.js").default} control Control.
             * @this {PluggableMap}
             */
            function (control) {
                control.setMap(this);
            }.bind(_this));
            _this.controls.addEventListener(CollectionEventType.ADD, 
            /**
             * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
             */
            function (event) {
                event.element.setMap(this);
            }.bind(_this));
            _this.controls.addEventListener(CollectionEventType.REMOVE, 
            /**
             * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
             */
            function (event) {
                event.element.setMap(null);
            }.bind(_this));
            _this.interactions.forEach(
            /**
             * @param {import("./interaction/Interaction.js").default} interaction Interaction.
             * @this {PluggableMap}
             */
            function (interaction) {
                interaction.setMap(this);
            }.bind(_this));
            _this.interactions.addEventListener(CollectionEventType.ADD, 
            /**
             * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
             */
            function (event) {
                event.element.setMap(this);
            }.bind(_this));
            _this.interactions.addEventListener(CollectionEventType.REMOVE, 
            /**
             * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
             */
            function (event) {
                event.element.setMap(null);
            }.bind(_this));
            _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));
            _this.overlays_.addEventListener(CollectionEventType.ADD, 
            /**
             * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
             */
            function (event) {
                this.addOverlayInternal_(
                /** @type {import("./Overlay.js").default} */ (event.element));
            }.bind(_this));
            _this.overlays_.addEventListener(CollectionEventType.REMOVE, 
            /**
             * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
             */
            function (event) {
                var overlay = /** @type {import("./Overlay.js").default} */ (event.element);
                var id = overlay.getId();
                if (id !== undefined) {
                    delete this.overlayIdIndex_[id.toString()];
                }
                event.element.setMap(null);
            }.bind(_this));
            return _this;
        }
        /**
         * @abstract
         * @return {import("./renderer/Map.js").default} The map renderer
         */
        PluggableMap.prototype.createRenderer = function () {
            throw new Error('Use a map type that has a createRenderer method');
        };
        /**
         * Add the given control to the map.
         * @param {import("./control/Control.js").default} control Control.
         * @api
         */
        PluggableMap.prototype.addControl = function (control) {
            this.getControls().push(control);
        };
        /**
         * Add the given interaction to the map. If you want to add an interaction
         * at another point of the collection use `getInteraction()` and the methods
         * available on {@link module:ol/Collection~Collection}. This can be used to
         * stop the event propagation from the handleEvent function. The interactions
         * get to handle the events in the reverse order of this collection.
         * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
         * @api
         */
        PluggableMap.prototype.addInteraction = function (interaction) {
            this.getInteractions().push(interaction);
        };
        /**
         * Adds the given layer to the top of this map. If you want to add a layer
         * elsewhere in the stack, use `getLayers()` and the methods available on
         * {@link module:ol/Collection~Collection}.
         * @param {import("./layer/Base.js").default} layer Layer.
         * @api
         */
        PluggableMap.prototype.addLayer = function (layer) {
            var layers = this.getLayerGroup().getLayers();
            layers.push(layer);
        };
        /**
         * Add the given overlay to the map.
         * @param {import("./Overlay.js").default} overlay Overlay.
         * @api
         */
        PluggableMap.prototype.addOverlay = function (overlay) {
            this.getOverlays().push(overlay);
        };
        /**
         * This deals with map's overlay collection changes.
         * @param {import("./Overlay.js").default} overlay Overlay.
         * @private
         */
        PluggableMap.prototype.addOverlayInternal_ = function (overlay) {
            var id = overlay.getId();
            if (id !== undefined) {
                this.overlayIdIndex_[id.toString()] = overlay;
            }
            overlay.setMap(this);
        };
        /**
         *
         * Clean up.
         */
        PluggableMap.prototype.disposeInternal = function () {
            this.setTarget(null);
            _super.prototype.disposeInternal.call(this);
        };
        /**
         * Detect features that intersect a pixel on the viewport, and execute a
         * callback with each intersecting feature. Layers included in the detection can
         * be configured through the `layerFilter` option in `opt_options`.
         * @param {import("./pixel.js").Pixel} pixel Pixel.
         * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
         *     called with two arguments. The first argument is one
         *     {@link module:ol/Feature feature} or
         *     {@link module:ol/render/Feature render feature} at the pixel, the second is
         *     the {@link module:ol/layer/Layer layer} of the feature and will be null for
         *     unmanaged layers. To stop detection, callback functions can return a
         *     truthy value.
         * @param {AtPixelOptions=} opt_options Optional options.
         * @return {T|undefined} Callback result, i.e. the return value of last
         * callback execution, or the first truthy callback return value.
         * @template S,T
         * @api
         */
        PluggableMap.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {
            if (!this.frameState_) {
                return;
            }
            var coordinate = this.getCoordinateFromPixelInternal(pixel);
            opt_options = opt_options !== undefined ? opt_options : {};
            var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;
            var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;
            var checkWrapped = opt_options.checkWrapped !== false;
            return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
        };
        /**
         * Get all features that intersect a pixel on the viewport.
         * @param {import("./pixel.js").Pixel} pixel Pixel.
         * @param {AtPixelOptions=} opt_options Optional options.
         * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
         * an empty array if none were found.
         * @api
         */
        PluggableMap.prototype.getFeaturesAtPixel = function (pixel, opt_options) {
            var features = [];
            this.forEachFeatureAtPixel(pixel, function (feature) {
                features.push(feature);
            }, opt_options);
            return features;
        };
        /**
         * Detect layers that have a color value at a pixel on the viewport, and
         * execute a callback with each matching layer. Layers included in the
         * detection can be configured through `opt_layerFilter`.
         *
         * Note: this may give false positives unless the map layers have had different `className`
         * properties assigned to them.
         *
         * @param {import("./pixel.js").Pixel} pixel Pixel.
         * @param {function(this: S, import("./layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback
         *     Layer callback. This callback will receive two arguments: first is the
         *     {@link module:ol/layer/Layer layer}, second argument is an array representing
         *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
         *     that do not currently support this argument. To stop detection, callback
         *     functions can return a truthy value.
         * @param {AtPixelOptions=} opt_options Configuration options.
         * @return {T|undefined} Callback result, i.e. the return value of last
         * callback execution, or the first truthy callback return value.
         * @template S,T
         * @api
         */
        PluggableMap.prototype.forEachLayerAtPixel = function (pixel, callback, opt_options) {
            if (!this.frameState_) {
                return;
            }
            var options = opt_options || {};
            var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
            var layerFilter = options.layerFilter || TRUE;
            return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);
        };
        /**
         * Detect if features intersect a pixel on the viewport. Layers included in the
         * detection can be configured through `opt_layerFilter`.
         * @param {import("./pixel.js").Pixel} pixel Pixel.
         * @param {AtPixelOptions=} opt_options Optional options.
         * @return {boolean} Is there a feature at the given pixel?
         * @api
         */
        PluggableMap.prototype.hasFeatureAtPixel = function (pixel, opt_options) {
            if (!this.frameState_) {
                return false;
            }
            var coordinate = this.getCoordinateFromPixelInternal(pixel);
            opt_options = opt_options !== undefined ? opt_options : {};
            var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;
            var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;
            var checkWrapped = opt_options.checkWrapped !== false;
            return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
        };
        /**
         * Returns the coordinate in user projection for a browser event.
         * @param {MouseEvent} event Event.
         * @return {import("./coordinate.js").Coordinate} Coordinate.
         * @api
         */
        PluggableMap.prototype.getEventCoordinate = function (event) {
            return this.getCoordinateFromPixel(this.getEventPixel(event));
        };
        /**
         * Returns the coordinate in view projection for a browser event.
         * @param {MouseEvent} event Event.
         * @return {import("./coordinate.js").Coordinate} Coordinate.
         */
        PluggableMap.prototype.getEventCoordinateInternal = function (event) {
            return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
        };
        /**
         * Returns the map pixel position for a browser event relative to the viewport.
         * @param {UIEvent} event Event.
         * @return {import("./pixel.js").Pixel} Pixel.
         * @api
         */
        PluggableMap.prototype.getEventPixel = function (event) {
            var viewportPosition = this.viewport_.getBoundingClientRect();
            var eventPosition = 
            //FIXME Are we really calling this with a TouchEvent anywhere?
            'changedTouches' in event
                ? /** @type {TouchEvent} */ (event).changedTouches[0]
                : /** @type {MouseEvent} */ (event);
            return [
                eventPosition.clientX - viewportPosition.left,
                eventPosition.clientY - viewportPosition.top,
            ];
        };
        /**
         * Get the target in which this map is rendered.
         * Note that this returns what is entered as an option or in setTarget:
         * if that was an element, it returns an element; if a string, it returns that.
         * @return {HTMLElement|string|undefined} The Element or id of the Element that the
         *     map is rendered in.
         * @observable
         * @api
         */
        PluggableMap.prototype.getTarget = function () {
            return /** @type {HTMLElement|string|undefined} */ (this.get(MapProperty.TARGET));
        };
        /**
         * Get the DOM element into which this map is rendered. In contrast to
         * `getTarget` this method always return an `Element`, or `null` if the
         * map has no target.
         * @return {HTMLElement} The element that the map is rendered in.
         * @api
         */
        PluggableMap.prototype.getTargetElement = function () {
            var target = this.getTarget();
            if (target !== undefined) {
                return typeof target === 'string'
                    ? document.getElementById(target)
                    : target;
            }
            else {
                return null;
            }
        };
        /**
         * Get the coordinate for a given pixel.  This returns a coordinate in the
         * user projection.
         * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
         * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
         * @api
         */
        PluggableMap.prototype.getCoordinateFromPixel = function (pixel) {
            return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
        };
        /**
         * Get the coordinate for a given pixel.  This returns a coordinate in the
         * map view projection.
         * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
         * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
         */
        PluggableMap.prototype.getCoordinateFromPixelInternal = function (pixel) {
            var frameState = this.frameState_;
            if (!frameState) {
                return null;
            }
            else {
                return apply(frameState.pixelToCoordinateTransform, pixel.slice());
            }
        };
        /**
         * Get the map controls. Modifying this collection changes the controls
         * associated with the map.
         * @return {Collection<import("./control/Control.js").default>} Controls.
         * @api
         */
        PluggableMap.prototype.getControls = function () {
            return this.controls;
        };
        /**
         * Get the map overlays. Modifying this collection changes the overlays
         * associated with the map.
         * @return {Collection<import("./Overlay.js").default>} Overlays.
         * @api
         */
        PluggableMap.prototype.getOverlays = function () {
            return this.overlays_;
        };
        /**
         * Get an overlay by its identifier (the value returned by overlay.getId()).
         * Note that the index treats string and numeric identifiers as the same. So
         * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
         * @param {string|number} id Overlay identifier.
         * @return {import("./Overlay.js").default} Overlay.
         * @api
         */
        PluggableMap.prototype.getOverlayById = function (id) {
            var overlay = this.overlayIdIndex_[id.toString()];
            return overlay !== undefined ? overlay : null;
        };
        /**
         * Get the map interactions. Modifying this collection changes the interactions
         * associated with the map.
         *
         * Interactions are used for e.g. pan, zoom and rotate.
         * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
         * @api
         */
        PluggableMap.prototype.getInteractions = function () {
            return this.interactions;
        };
        /**
         * Get the layergroup associated with this map.
         * @return {LayerGroup} A layer group containing the layers in this map.
         * @observable
         * @api
         */
        PluggableMap.prototype.getLayerGroup = function () {
            return /** @type {LayerGroup} */ (this.get(MapProperty.LAYERGROUP));
        };
        /**
         * Get the collection of layers associated with this map.
         * @return {!Collection<import("./layer/Base.js").default>} Layers.
         * @api
         */
        PluggableMap.prototype.getLayers = function () {
            var layers = this.getLayerGroup().getLayers();
            return layers;
        };
        /**
         * @return {boolean} Layers have sources that are still loading.
         */
        PluggableMap.prototype.getLoading = function () {
            var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
            for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
                var layer = layerStatesArray[i].layer;
                var source = /** @type {import("./layer/Layer.js").default} */ (layer).getSource();
                if (source && source.loading) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Get the pixel for a coordinate.  This takes a coordinate in the user
         * projection and returns the corresponding pixel.
         * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
         * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
         * @api
         */
        PluggableMap.prototype.getPixelFromCoordinate = function (coordinate) {
            var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());
            return this.getPixelFromCoordinateInternal(viewCoordinate);
        };
        /**
         * Get the pixel for a coordinate.  This takes a coordinate in the map view
         * projection and returns the corresponding pixel.
         * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
         * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
         */
        PluggableMap.prototype.getPixelFromCoordinateInternal = function (coordinate) {
            var frameState = this.frameState_;
            if (!frameState) {
                return null;
            }
            else {
                return apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
            }
        };
        /**
         * Get the map renderer.
         * @return {import("./renderer/Map.js").default} Renderer
         */
        PluggableMap.prototype.getRenderer = function () {
            return this.renderer_;
        };
        /**
         * Get the size of this map.
         * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
         * @observable
         * @api
         */
        PluggableMap.prototype.getSize = function () {
            return /** @type {import("./size.js").Size|undefined} */ (this.get(MapProperty.SIZE));
        };
        /**
         * Get the view associated with this map. A view manages properties such as
         * center and resolution.
         * @return {View} The view that controls this map.
         * @observable
         * @api
         */
        PluggableMap.prototype.getView = function () {
            return /** @type {View} */ (this.get(MapProperty.VIEW));
        };
        /**
         * Get the element that serves as the map viewport.
         * @return {HTMLElement} Viewport.
         * @api
         */
        PluggableMap.prototype.getViewport = function () {
            return this.viewport_;
        };
        /**
         * Get the element that serves as the container for overlays.  Elements added to
         * this container will let mousedown and touchstart events through to the map,
         * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
         * events.
         * @return {!HTMLElement} The map's overlay container.
         */
        PluggableMap.prototype.getOverlayContainer = function () {
            return this.overlayContainer_;
        };
        /**
         * Get the element that serves as a container for overlays that don't allow
         * event propagation. Elements added to this container won't let mousedown and
         * touchstart events through to the map, so clicks and gestures on an overlay
         * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
         * @return {!HTMLElement} The map's overlay container that stops events.
         */
        PluggableMap.prototype.getOverlayContainerStopEvent = function () {
            return this.overlayContainerStopEvent_;
        };
        /**
         * @return {!Document} The document where the map is displayed.
         */
        PluggableMap.prototype.getOwnerDocument = function () {
            return this.getTargetElement()
                ? this.getTargetElement().ownerDocument
                : document;
        };
        /**
         * @param {import("./Tile.js").default} tile Tile.
         * @param {string} tileSourceKey Tile source key.
         * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
         * @param {number} tileResolution Tile resolution.
         * @return {number} Tile priority.
         */
        PluggableMap.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {
            return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
        };
        /**
         * @param {UIEvent} browserEvent Browser event.
         * @param {string=} opt_type Type.
         */
        PluggableMap.prototype.handleBrowserEvent = function (browserEvent, opt_type) {
            var type = opt_type || browserEvent.type;
            var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);
            this.handleMapBrowserEvent(mapBrowserEvent);
        };
        /**
         * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
         */
        PluggableMap.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {
            if (!this.frameState_) {
                // With no view defined, we cannot translate pixels into geographical
                // coordinates so interactions cannot be used.
                return;
            }
            var originalEvent = /** @type {PointerEvent} */ (mapBrowserEvent.originalEvent);
            var eventType = originalEvent.type;
            if (eventType === PointerEventType.POINTERDOWN ||
                eventType === EventType.WHEEL ||
                eventType === EventType.KEYDOWN) {
                var doc = this.getOwnerDocument();
                var rootNode = this.viewport_.getRootNode
                    ? this.viewport_.getRootNode()
                    : doc;
                var target = 'host' in rootNode // ShadowRoot
                    ? /** @type {ShadowRoot} */ (rootNode).elementFromPoint(originalEvent.clientX, originalEvent.clientY)
                    : /** @type {Node} */ (originalEvent.target);
                if (
                // Abort if the target is a child of the container for elements whose events are not meant
                // to be handled by map interactions.
                this.overlayContainerStopEvent_.contains(target) ||
                    // Abort if the event target is a child of the container that is no longer in the page.
                    // It's possible for the target to no longer be in the page if it has been removed in an
                    // event listener, this might happen in a Control that recreates it's content based on
                    // user interaction either manually or via a render in something like https://reactjs.org/
                    !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {
                    return;
                }
            }
            mapBrowserEvent.frameState = this.frameState_;
            if (this.dispatchEvent(mapBrowserEvent) !== false) {
                var interactionsArray = this.getInteractions().getArray().slice();
                for (var i = interactionsArray.length - 1; i >= 0; i--) {
                    var interaction = interactionsArray[i];
                    if (interaction.getMap() !== this ||
                        !interaction.getActive() ||
                        !this.getTargetElement()) {
                        continue;
                    }
                    var cont = interaction.handleEvent(mapBrowserEvent);
                    if (!cont || mapBrowserEvent.propagationStopped) {
                        break;
                    }
                }
            }
        };
        /**
         * @protected
         */
        PluggableMap.prototype.handlePostRender = function () {
            var frameState = this.frameState_;
            // Manage the tile queue
            // Image loads are expensive and a limited resource, so try to use them
            // efficiently:
            // * When the view is static we allow a large number of parallel tile loads
            //   to complete the frame as quickly as possible.
            // * When animating or interacting, image loads can cause janks, so we reduce
            //   the maximum number of loads per frame and limit the number of parallel
            //   tile loads to remain reactive to view changes and to reduce the chance of
            //   loading tiles that will quickly disappear from view.
            var tileQueue = this.tileQueue_;
            if (!tileQueue.isEmpty()) {
                var maxTotalLoading = this.maxTilesLoading_;
                var maxNewLoads = maxTotalLoading;
                if (frameState) {
                    var hints = frameState.viewHints;
                    if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {
                        var lowOnFrameBudget = !IMAGE_DECODE && Date.now() - frameState.time > 8;
                        maxTotalLoading = lowOnFrameBudget ? 0 : 8;
                        maxNewLoads = lowOnFrameBudget ? 0 : 2;
                    }
                }
                if (tileQueue.getTilesLoading() < maxTotalLoading) {
                    tileQueue.reprioritize(); // FIXME only call if view has changed
                    tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
                }
            }
            if (frameState &&
                this.hasListener(RenderEventType.RENDERCOMPLETE) &&
                !frameState.animate &&
                !this.tileQueue_.getTilesLoading() &&
                !this.getLoading()) {
                this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);
            }
            var postRenderFunctions = this.postRenderFunctions_;
            for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
                postRenderFunctions[i](this, frameState);
            }
            postRenderFunctions.length = 0;
        };
        /**
         * @private
         */
        PluggableMap.prototype.handleSizeChanged_ = function () {
            if (this.getView() && !this.getView().getAnimating()) {
                this.getView().resolveConstraints(0);
            }
            this.render();
        };
        /**
         * @private
         */
        PluggableMap.prototype.handleTargetChanged_ = function () {
            // target may be undefined, null, a string or an Element.
            // If it's a string we convert it to an Element before proceeding.
            // If it's not now an Element we remove the viewport from the DOM.
            // If it's an Element we append the viewport element to it.
            var targetElement;
            if (this.getTarget()) {
                targetElement = this.getTargetElement();
            }
            if (this.mapBrowserEventHandler_) {
                for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
                    unlistenByKey(this.keyHandlerKeys_[i]);
                }
                this.keyHandlerKeys_ = null;
                this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);
                this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);
                if (this.handleResize_ !== undefined) {
                    removeEventListener(EventType.RESIZE, this.handleResize_, false);
                    this.handleResize_ = undefined;
                }
                this.mapBrowserEventHandler_.dispose();
                this.mapBrowserEventHandler_ = null;
                removeNode(this.viewport_);
            }
            if (!targetElement) {
                if (this.renderer_) {
                    clearTimeout(this.postRenderTimeoutHandle_);
                    this.postRenderTimeoutHandle_ = undefined;
                    this.postRenderFunctions_.length = 0;
                    this.renderer_.dispose();
                    this.renderer_ = null;
                }
                if (this.animationDelayKey_) {
                    cancelAnimationFrame(this.animationDelayKey_);
                    this.animationDelayKey_ = undefined;
                }
            }
            else {
                targetElement.appendChild(this.viewport_);
                if (!this.renderer_) {
                    this.renderer_ = this.createRenderer();
                }
                this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, this.moveTolerance_);
                for (var key in MapBrowserEventType) {
                    this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));
                }
                this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);
                this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
                var keyboardEventTarget = !this.keyboardEventTarget_
                    ? targetElement
                    : this.keyboardEventTarget_;
                this.keyHandlerKeys_ = [
                    listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),
                    listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this),
                ];
                if (!this.handleResize_) {
                    this.handleResize_ = this.updateSize.bind(this);
                    window.addEventListener(EventType.RESIZE, this.handleResize_, false);
                }
            }
            this.updateSize();
            // updateSize calls setSize, so no need to call this.render
            // ourselves here.
        };
        /**
         * @private
         */
        PluggableMap.prototype.handleTileChange_ = function () {
            this.render();
        };
        /**
         * @private
         */
        PluggableMap.prototype.handleViewPropertyChanged_ = function () {
            this.render();
        };
        /**
         * @private
         */
        PluggableMap.prototype.handleViewChanged_ = function () {
            if (this.viewPropertyListenerKey_) {
                unlistenByKey(this.viewPropertyListenerKey_);
                this.viewPropertyListenerKey_ = null;
            }
            if (this.viewChangeListenerKey_) {
                unlistenByKey(this.viewChangeListenerKey_);
                this.viewChangeListenerKey_ = null;
            }
            var view = this.getView();
            if (view) {
                this.updateViewportSize_();
                this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
                this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);
                view.resolveConstraints(0);
            }
            this.render();
        };
        /**
         * @private
         */
        PluggableMap.prototype.handleLayerGroupChanged_ = function () {
            if (this.layerGroupPropertyListenerKeys_) {
                this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
                this.layerGroupPropertyListenerKeys_ = null;
            }
            var layerGroup = this.getLayerGroup();
            if (layerGroup) {
                this.layerGroupPropertyListenerKeys_ = [
                    listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this),
                    listen(layerGroup, EventType.CHANGE, this.render, this),
                ];
            }
            this.render();
        };
        /**
         * @return {boolean} Is rendered.
         */
        PluggableMap.prototype.isRendered = function () {
            return !!this.frameState_;
        };
        /**
         * Requests an immediate render in a synchronous manner.
         * @api
         */
        PluggableMap.prototype.renderSync = function () {
            if (this.animationDelayKey_) {
                cancelAnimationFrame(this.animationDelayKey_);
            }
            this.animationDelay_();
        };
        /**
         * Redraws all text after new fonts have loaded
         */
        PluggableMap.prototype.redrawText = function () {
            var layerStates = this.getLayerGroup().getLayerStatesArray();
            for (var i = 0, ii = layerStates.length; i < ii; ++i) {
                var layer = layerStates[i].layer;
                if (layer.hasRenderer()) {
                    layer.getRenderer().handleFontsChanged();
                }
            }
        };
        /**
         * Request a map rendering (at the next animation frame).
         * @api
         */
        PluggableMap.prototype.render = function () {
            if (this.renderer_ && this.animationDelayKey_ === undefined) {
                this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
            }
        };
        /**
         * Remove the given control from the map.
         * @param {import("./control/Control.js").default} control Control.
         * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
         *     if the control was not found).
         * @api
         */
        PluggableMap.prototype.removeControl = function (control) {
            return this.getControls().remove(control);
        };
        /**
         * Remove the given interaction from the map.
         * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
         * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
         *     undefined if the interaction was not found).
         * @api
         */
        PluggableMap.prototype.removeInteraction = function (interaction) {
            return this.getInteractions().remove(interaction);
        };
        /**
         * Removes the given layer from the map.
         * @param {import("./layer/Base.js").default} layer Layer.
         * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
         *     layer was not found).
         * @api
         */
        PluggableMap.prototype.removeLayer = function (layer) {
            var layers = this.getLayerGroup().getLayers();
            return layers.remove(layer);
        };
        /**
         * Remove the given overlay from the map.
         * @param {import("./Overlay.js").default} overlay Overlay.
         * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
         *     if the overlay was not found).
         * @api
         */
        PluggableMap.prototype.removeOverlay = function (overlay) {
            return this.getOverlays().remove(overlay);
        };
        /**
         * @param {number} time Time.
         * @private
         */
        PluggableMap.prototype.renderFrame_ = function (time) {
            var _this = this;
            var size = this.getSize();
            var view = this.getView();
            var previousFrameState = this.frameState_;
            /** @type {?FrameState} */
            var frameState = null;
            if (size !== undefined && hasArea(size) && view && view.isDef()) {
                var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
                var viewState = view.getState();
                frameState = {
                    animate: false,
                    coordinateToPixelTransform: this.coordinateToPixelTransform_,
                    declutterTree: null,
                    extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),
                    index: this.frameIndex_++,
                    layerIndex: 0,
                    layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                    pixelRatio: this.pixelRatio_,
                    pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                    postRenderFunctions: [],
                    size: size,
                    tileQueue: this.tileQueue_,
                    time: time,
                    usedTiles: {},
                    viewState: viewState,
                    viewHints: viewHints,
                    wantedTiles: {},
                };
            }
            this.frameState_ = frameState;
            this.renderer_.renderFrame(frameState);
            if (frameState) {
                if (frameState.animate) {
                    this.render();
                }
                Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
                if (previousFrameState) {
                    var moveStart = !this.previousExtent_ ||
                        (!isEmpty(this.previousExtent_) &&
                            !equals$1(frameState.extent, this.previousExtent_));
                    if (moveStart) {
                        this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));
                        this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
                    }
                }
                var idle = this.previousExtent_ &&
                    !frameState.viewHints[ViewHint.ANIMATING] &&
                    !frameState.viewHints[ViewHint.INTERACTING] &&
                    !equals$1(frameState.extent, this.previousExtent_);
                if (idle) {
                    this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));
                    clone(frameState.extent, this.previousExtent_);
                }
            }
            this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));
            if (!this.postRenderTimeoutHandle_) {
                this.postRenderTimeoutHandle_ = setTimeout(function () {
                    _this.postRenderTimeoutHandle_ = undefined;
                    _this.handlePostRender();
                }, 0);
            }
        };
        /**
         * Sets the layergroup of this map.
         * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
         * @observable
         * @api
         */
        PluggableMap.prototype.setLayerGroup = function (layerGroup) {
            this.set(MapProperty.LAYERGROUP, layerGroup);
        };
        /**
         * Set the size of this map.
         * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
         * @observable
         * @api
         */
        PluggableMap.prototype.setSize = function (size) {
            this.set(MapProperty.SIZE, size);
        };
        /**
         * Set the target element to render this map into.
         * @param {HTMLElement|string|undefined} target The Element or id of the Element
         *     that the map is rendered in.
         * @observable
         * @api
         */
        PluggableMap.prototype.setTarget = function (target) {
            this.set(MapProperty.TARGET, target);
        };
        /**
         * Set the view for this map.
         * @param {View} view The view that controls this map.
         * @observable
         * @api
         */
        PluggableMap.prototype.setView = function (view) {
            this.set(MapProperty.VIEW, view);
        };
        /**
         * Force a recalculation of the map viewport size.  This should be called when
         * third-party code changes the size of the map viewport.
         * @api
         */
        PluggableMap.prototype.updateSize = function () {
            var targetElement = this.getTargetElement();
            if (!targetElement) {
                this.setSize(undefined);
            }
            else {
                var computedStyle = getComputedStyle(targetElement);
                this.setSize([
                    targetElement.offsetWidth -
                        parseFloat(computedStyle['borderLeftWidth']) -
                        parseFloat(computedStyle['paddingLeft']) -
                        parseFloat(computedStyle['paddingRight']) -
                        parseFloat(computedStyle['borderRightWidth']),
                    targetElement.offsetHeight -
                        parseFloat(computedStyle['borderTopWidth']) -
                        parseFloat(computedStyle['paddingTop']) -
                        parseFloat(computedStyle['paddingBottom']) -
                        parseFloat(computedStyle['borderBottomWidth']),
                ]);
            }
            this.updateViewportSize_();
        };
        /**
         * Recomputes the viewport size and save it on the view object (if any)
         * @private
         */
        PluggableMap.prototype.updateViewportSize_ = function () {
            var view = this.getView();
            if (view) {
                var size = undefined;
                var computedStyle = getComputedStyle(this.viewport_);
                if (computedStyle.width && computedStyle.height) {
                    size = [
                        parseInt(computedStyle.width, 10),
                        parseInt(computedStyle.height, 10),
                    ];
                }
                view.setViewportSize(size);
            }
        };
        return PluggableMap;
    }(BaseObject));
    /**
     * @param {MapOptions} options Map options.
     * @return {MapOptionsInternal} Internal map options.
     */
    function createOptionsInternal(options) {
        /**
         * @type {HTMLElement|Document}
         */
        var keyboardEventTarget = null;
        if (options.keyboardEventTarget !== undefined) {
            keyboardEventTarget =
                typeof options.keyboardEventTarget === 'string'
                    ? document.getElementById(options.keyboardEventTarget)
                    : options.keyboardEventTarget;
        }
        /**
         * @type {Object<string, *>}
         */
        var values = {};
        var layerGroup = options.layers &&
            typeof ( /** @type {?} */(options.layers).getLayers) === 'function'
            ? /** @type {LayerGroup} */ (options.layers)
            : new LayerGroup({ layers: /** @type {Collection} */ (options.layers) });
        values[MapProperty.LAYERGROUP] = layerGroup;
        values[MapProperty.TARGET] = options.target;
        values[MapProperty.VIEW] =
            options.view !== undefined ? options.view : new View();
        var controls;
        if (options.controls !== undefined) {
            if (Array.isArray(options.controls)) {
                controls = new Collection(options.controls.slice());
            }
            else {
                assert(typeof ( /** @type {?} */(options.controls).getArray) === 'function', 47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`
                controls = /** @type {Collection} */ (options.controls);
            }
        }
        var interactions;
        if (options.interactions !== undefined) {
            if (Array.isArray(options.interactions)) {
                interactions = new Collection(options.interactions.slice());
            }
            else {
                assert(typeof ( /** @type {?} */(options.interactions).getArray) ===
                    'function', 48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`
                interactions = /** @type {Collection} */ (options.interactions);
            }
        }
        var overlays;
        if (options.overlays !== undefined) {
            if (Array.isArray(options.overlays)) {
                overlays = new Collection(options.overlays.slice());
            }
            else {
                assert(typeof ( /** @type {?} */(options.overlays).getArray) === 'function', 49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`
                overlays = options.overlays;
            }
        }
        else {
            overlays = new Collection();
        }
        return {
            controls: controls,
            interactions: interactions,
            keyboardEventTarget: keyboardEventTarget,
            overlays: overlays,
            values: values,
        };
    }

    var __extends$q = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {HTMLElement} [element] The element is the control's
     * container element. This only needs to be specified if you're developing
     * a custom control.
     * @property {function(import("../MapEvent.js").default):void} [render] Function called when
     * the control should be re-rendered. This is called in a `requestAnimationFrame`
     * callback.
     * @property {HTMLElement|string} [target] Specify a target if you want
     * the control to be rendered outside of the map's viewport.
     */
    /**
     * @classdesc
     * A control is a visible widget with a DOM element in a fixed position on the
     * screen. They can involve user input (buttons), or be informational only;
     * the position is determined using CSS. By default these are placed in the
     * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
     * any outside DOM element.
     *
     * This is the base class for controls. You can use it for simple custom
     * controls by creating the element with listeners, creating an instance:
     * ```js
     * var myControl = new Control({element: myElement});
     * ```
     * and then adding this to the map.
     *
     * The main advantage of having this as a control rather than a simple separate
     * DOM element is that preventing propagation is handled for you. Controls
     * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
     *
     * You can also extend this base for your own control class. See
     * examples/custom-controls for an example of how to do this.
     *
     * @api
     */
    var Control = /** @class */ (function (_super) {
        __extends$q(Control, _super);
        /**
         * @param {Options} options Control options.
         */
        function Control(options) {
            var _this = _super.call(this) || this;
            var element = options.element;
            if (element && !options.target && !element.style.pointerEvents) {
                element.style.pointerEvents = 'auto';
            }
            /**
             * @protected
             * @type {HTMLElement}
             */
            _this.element = element ? element : null;
            /**
             * @private
             * @type {HTMLElement}
             */
            _this.target_ = null;
            /**
             * @private
             * @type {import("../PluggableMap.js").default}
             */
            _this.map_ = null;
            /**
             * @protected
             * @type {!Array<import("../events.js").EventsKey>}
             */
            _this.listenerKeys = [];
            if (options.render) {
                _this.render = options.render;
            }
            if (options.target) {
                _this.setTarget(options.target);
            }
            return _this;
        }
        /**
         * Clean up.
         */
        Control.prototype.disposeInternal = function () {
            removeNode(this.element);
            _super.prototype.disposeInternal.call(this);
        };
        /**
         * Get the map associated with this control.
         * @return {import("../PluggableMap.js").default} Map.
         * @api
         */
        Control.prototype.getMap = function () {
            return this.map_;
        };
        /**
         * Remove the control from its current map and attach it to the new map.
         * Subclasses may set up event handlers to get notified about changes to
         * the map here.
         * @param {import("../PluggableMap.js").default} map Map.
         * @api
         */
        Control.prototype.setMap = function (map) {
            if (this.map_) {
                removeNode(this.element);
            }
            for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
                unlistenByKey(this.listenerKeys[i]);
            }
            this.listenerKeys.length = 0;
            this.map_ = map;
            if (this.map_) {
                var target = this.target_
                    ? this.target_
                    : map.getOverlayContainerStopEvent();
                target.appendChild(this.element);
                if (this.render !== VOID) {
                    this.listenerKeys.push(listen(map, MapEventType.POSTRENDER, this.render, this));
                }
                map.render();
            }
        };
        /**
         * Renders the control.
         * @param {import("../MapEvent.js").default} mapEvent Map event.
         * @api
         */
        Control.prototype.render = function (mapEvent) { };
        /**
         * This function is used to set a target element for the control. It has no
         * effect if it is called after the control has been added to the map (i.e.
         * after `setMap` is called on the control). If no `target` is set in the
         * options passed to the control constructor and if `setTarget` is not called
         * then the control is added to the map's overlay container.
         * @param {HTMLElement|string} target Target.
         * @api
         */
        Control.prototype.setTarget = function (target) {
            this.target_ =
                typeof target === 'string' ? document.getElementById(target) : target;
        };
        return Control;
    }(BaseObject));

    var __extends$p = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {string} [className='ol-attribution'] CSS class name.
     * @property {HTMLElement|string} [target] Specify a target if you
     * want the control to be rendered outside of the map's
     * viewport.
     * @property {boolean} [collapsible] Specify if attributions can
     * be collapsed. If not specified, sources control this behavior with their
     * `attributionsCollapsible` setting.
     * @property {boolean} [collapsed=true] Specify if attributions should
     * be collapsed at startup.
     * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
     * @property {string} [label='i'] Text label to use for the
     * collapsed attributions button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     * @property {string} [expandClassName=className + '-expand'] CSS class name for the
     * collapsed attributions button.
     * @property {string|HTMLElement} [collapseLabel='»'] Text label to use
     * for the expanded attributions button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
     * expanded attributions button.
     * @property {function(import("../MapEvent.js").default):void} [render] Function called when
     * the control should be re-rendered. This is called in a `requestAnimationFrame`
     * callback.
     */
    /**
     * @classdesc
     * Control to show all the attributions associated with the layer sources
     * in the map. This control is one of the default controls included in maps.
     * By default it will show in the bottom right portion of the map, but this can
     * be changed by using a css selector for `.ol-attribution`.
     *
     * @api
     */
    var Attribution = /** @class */ (function (_super) {
        __extends$p(Attribution, _super);
        /**
         * @param {Options=} opt_options Attribution options.
         */
        function Attribution(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
                element: document.createElement('div'),
                render: options.render,
                target: options.target,
            }) || this;
            /**
             * @private
             * @type {HTMLElement}
             */
            _this.ulElement_ = document.createElement('ul');
            /**
             * @private
             * @type {boolean}
             */
            _this.collapsed_ =
                options.collapsed !== undefined ? options.collapsed : true;
            /**
             * @private
             * @type {boolean}
             */
            _this.userCollapsed_ = _this.collapsed_;
            /**
             * @private
             * @type {boolean}
             */
            _this.overrideCollapsible_ = options.collapsible !== undefined;
            /**
             * @private
             * @type {boolean}
             */
            _this.collapsible_ =
                options.collapsible !== undefined ? options.collapsible : true;
            if (!_this.collapsible_) {
                _this.collapsed_ = false;
            }
            var className = options.className !== undefined ? options.className : 'ol-attribution';
            var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
            var expandClassName = options.expandClassName !== undefined
                ? options.expandClassName
                : className + '-expand';
            var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00BB';
            var collapseClassName = options.collapseClassName !== undefined
                ? options.collapseClassName
                : className + '-collpase';
            if (typeof collapseLabel === 'string') {
                /**
                 * @private
                 * @type {HTMLElement}
                 */
                _this.collapseLabel_ = document.createElement('span');
                _this.collapseLabel_.textContent = collapseLabel;
                _this.collapseLabel_.className = collapseClassName;
            }
            else {
                _this.collapseLabel_ = collapseLabel;
            }
            var label = options.label !== undefined ? options.label : 'i';
            if (typeof label === 'string') {
                /**
                 * @private
                 * @type {HTMLElement}
                 */
                _this.label_ = document.createElement('span');
                _this.label_.textContent = label;
                _this.label_.className = expandClassName;
            }
            else {
                _this.label_ = label;
            }
            var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
            var button = document.createElement('button');
            button.setAttribute('type', 'button');
            button.title = tipLabel;
            button.appendChild(activeLabel);
            button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
            var cssClasses = className +
                ' ' +
                CLASS_UNSELECTABLE +
                ' ' +
                CLASS_CONTROL +
                (_this.collapsed_ && _this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') +
                (_this.collapsible_ ? '' : ' ol-uncollapsible');
            var element = _this.element;
            element.className = cssClasses;
            element.appendChild(_this.ulElement_);
            element.appendChild(button);
            /**
             * A list of currently rendered resolutions.
             * @type {Array<string>}
             * @private
             */
            _this.renderedAttributions_ = [];
            /**
             * @private
             * @type {boolean}
             */
            _this.renderedVisible_ = true;
            return _this;
        }
        /**
         * Collect a list of visible attributions and set the collapsible state.
         * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
         * @return {Array<string>} Attributions.
         * @private
         */
        Attribution.prototype.collectSourceAttributions_ = function (frameState) {
            /**
             * Used to determine if an attribution already exists.
             * @type {!Object<string, boolean>}
             */
            var lookup = {};
            /**
             * A list of visible attributions.
             * @type {Array<string>}
             */
            var visibleAttributions = [];
            var collapsible = true;
            var layerStatesArray = frameState.layerStatesArray;
            for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
                var layerState = layerStatesArray[i];
                if (!inView(layerState, frameState.viewState)) {
                    continue;
                }
                var source = /** @type {import("../layer/Layer.js").default} */ (layerState.layer).getSource();
                if (!source) {
                    continue;
                }
                var attributionGetter = source.getAttributions();
                if (!attributionGetter) {
                    continue;
                }
                var attributions = attributionGetter(frameState);
                if (!attributions) {
                    continue;
                }
                collapsible =
                    collapsible && source.getAttributionsCollapsible() !== false;
                if (Array.isArray(attributions)) {
                    for (var j = 0, jj = attributions.length; j < jj; ++j) {
                        if (!(attributions[j] in lookup)) {
                            visibleAttributions.push(attributions[j]);
                            lookup[attributions[j]] = true;
                        }
                    }
                }
                else {
                    if (!(attributions in lookup)) {
                        visibleAttributions.push(attributions);
                        lookup[attributions] = true;
                    }
                }
            }
            if (!this.overrideCollapsible_) {
                this.setCollapsible(collapsible);
            }
            return visibleAttributions;
        };
        /**
         * @private
         * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
         */
        Attribution.prototype.updateElement_ = function (frameState) {
            if (!frameState) {
                if (this.renderedVisible_) {
                    this.element.style.display = 'none';
                    this.renderedVisible_ = false;
                }
                return;
            }
            var attributions = this.collectSourceAttributions_(frameState);
            var visible = attributions.length > 0;
            if (this.renderedVisible_ != visible) {
                this.element.style.display = visible ? '' : 'none';
                this.renderedVisible_ = visible;
            }
            if (equals$2(attributions, this.renderedAttributions_)) {
                return;
            }
            removeChildren(this.ulElement_);
            // append the attributions
            for (var i = 0, ii = attributions.length; i < ii; ++i) {
                var element = document.createElement('li');
                element.innerHTML = attributions[i];
                this.ulElement_.appendChild(element);
            }
            this.renderedAttributions_ = attributions;
        };
        /**
         * @param {MouseEvent} event The event to handle
         * @private
         */
        Attribution.prototype.handleClick_ = function (event) {
            event.preventDefault();
            this.handleToggle_();
            this.userCollapsed_ = this.collapsed_;
        };
        /**
         * @private
         */
        Attribution.prototype.handleToggle_ = function () {
            this.element.classList.toggle(CLASS_COLLAPSED);
            if (this.collapsed_) {
                replaceNode(this.collapseLabel_, this.label_);
            }
            else {
                replaceNode(this.label_, this.collapseLabel_);
            }
            this.collapsed_ = !this.collapsed_;
        };
        /**
         * Return `true` if the attribution is collapsible, `false` otherwise.
         * @return {boolean} True if the widget is collapsible.
         * @api
         */
        Attribution.prototype.getCollapsible = function () {
            return this.collapsible_;
        };
        /**
         * Set whether the attribution should be collapsible.
         * @param {boolean} collapsible True if the widget is collapsible.
         * @api
         */
        Attribution.prototype.setCollapsible = function (collapsible) {
            if (this.collapsible_ === collapsible) {
                return;
            }
            this.collapsible_ = collapsible;
            this.element.classList.toggle('ol-uncollapsible');
            if (this.userCollapsed_) {
                this.handleToggle_();
            }
        };
        /**
         * Collapse or expand the attribution according to the passed parameter. Will
         * not do anything if the attribution isn't collapsible or if the current
         * collapsed state is already the one requested.
         * @param {boolean} collapsed True if the widget is collapsed.
         * @api
         */
        Attribution.prototype.setCollapsed = function (collapsed) {
            this.userCollapsed_ = collapsed;
            if (!this.collapsible_ || this.collapsed_ === collapsed) {
                return;
            }
            this.handleToggle_();
        };
        /**
         * Return `true` when the attribution is currently collapsed or `false`
         * otherwise.
         * @return {boolean} True if the widget is collapsed.
         * @api
         */
        Attribution.prototype.getCollapsed = function () {
            return this.collapsed_;
        };
        /**
         * Update the attribution element.
         * @param {import("../MapEvent.js").default} mapEvent Map event.
         * @override
         */
        Attribution.prototype.render = function (mapEvent) {
            this.updateElement_(mapEvent.frameState);
        };
        return Attribution;
    }(Control));

    var __extends$o = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {string} [className='ol-rotate'] CSS class name.
     * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
     * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.
     * @property {number} [duration=250] Animation duration in milliseconds.
     * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
     * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
     * be re-rendered. This is called in a `requestAnimationFrame` callback.
     * @property {function():void} [resetNorth] Function called when the control is clicked.
     * This will override the default `resetNorth`.
     * @property {HTMLElement|string} [target] Specify a target if you want the control to be
     * rendered outside of the map's viewport.
     */
    /**
     * @classdesc
     * A button control to reset rotation to 0.
     * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
     * selector is added to the button when the rotation is 0.
     *
     * @api
     */
    var Rotate = /** @class */ (function (_super) {
        __extends$o(Rotate, _super);
        /**
         * @param {Options=} opt_options Rotate options.
         */
        function Rotate(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
                element: document.createElement('div'),
                render: options.render,
                target: options.target,
            }) || this;
            var className = options.className !== undefined ? options.className : 'ol-rotate';
            var label = options.label !== undefined ? options.label : '\u21E7';
            var compassClassName = options.compassClassName !== undefined
                ? options.compassClassName
                : 'ol-compass';
            /**
             * @type {HTMLElement}
             * @private
             */
            _this.label_ = null;
            if (typeof label === 'string') {
                _this.label_ = document.createElement('span');
                _this.label_.className = compassClassName;
                _this.label_.textContent = label;
            }
            else {
                _this.label_ = label;
                _this.label_.classList.add(compassClassName);
            }
            var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
            var button = document.createElement('button');
            button.className = className + '-reset';
            button.setAttribute('type', 'button');
            button.title = tipLabel;
            button.appendChild(_this.label_);
            button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
            var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
            var element = _this.element;
            element.className = cssClasses;
            element.appendChild(button);
            _this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
            /**
             * @type {number}
             * @private
             */
            _this.duration_ = options.duration !== undefined ? options.duration : 250;
            /**
             * @type {boolean}
             * @private
             */
            _this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.rotation_ = undefined;
            if (_this.autoHide_) {
                _this.element.classList.add(CLASS_HIDDEN);
            }
            return _this;
        }
        /**
         * @param {MouseEvent} event The event to handle
         * @private
         */
        Rotate.prototype.handleClick_ = function (event) {
            event.preventDefault();
            if (this.callResetNorth_ !== undefined) {
                this.callResetNorth_();
            }
            else {
                this.resetNorth_();
            }
        };
        /**
         * @private
         */
        Rotate.prototype.resetNorth_ = function () {
            var map = this.getMap();
            var view = map.getView();
            if (!view) {
                // the map does not have a view, so we can't act
                // upon it
                return;
            }
            var rotation = view.getRotation();
            if (rotation !== undefined) {
                if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
                    view.animate({
                        rotation: 0,
                        duration: this.duration_,
                        easing: easeOut,
                    });
                }
                else {
                    view.setRotation(0);
                }
            }
        };
        /**
         * Update the rotate control element.
         * @param {import("../MapEvent.js").default} mapEvent Map event.
         * @override
         */
        Rotate.prototype.render = function (mapEvent) {
            var frameState = mapEvent.frameState;
            if (!frameState) {
                return;
            }
            var rotation = frameState.viewState.rotation;
            if (rotation != this.rotation_) {
                var transform = 'rotate(' + rotation + 'rad)';
                if (this.autoHide_) {
                    var contains = this.element.classList.contains(CLASS_HIDDEN);
                    if (!contains && rotation === 0) {
                        this.element.classList.add(CLASS_HIDDEN);
                    }
                    else if (contains && rotation !== 0) {
                        this.element.classList.remove(CLASS_HIDDEN);
                    }
                }
                this.label_.style.transform = transform;
            }
            this.rotation_ = rotation;
        };
        return Rotate;
    }(Control));

    var __extends$n = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {number} [duration=250] Animation duration in milliseconds.
     * @property {string} [className='ol-zoom'] CSS class name.
     * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
     * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
     * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
     * button. Instead of text, also an element (e.g. a `span` element) can be used.
     * @property {string|HTMLElement} [zoomOutLabel='-'] Text label to use for the zoom-out button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
     * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
     * @property {number} [delta=1] The zoom delta applied on each click.
     * @property {HTMLElement|string} [target] Specify a target if you want the control to be
     * rendered outside of the map's viewport.
     */
    /**
     * @classdesc
     * A control with 2 buttons, one for zoom in and one for zoom out.
     * This control is one of the default controls of a map. To style this control
     * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
     *
     * @api
     */
    var Zoom = /** @class */ (function (_super) {
        __extends$n(Zoom, _super);
        /**
         * @param {Options=} opt_options Zoom options.
         */
        function Zoom(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
                element: document.createElement('div'),
                target: options.target,
            }) || this;
            var className = options.className !== undefined ? options.className : 'ol-zoom';
            var delta = options.delta !== undefined ? options.delta : 1;
            var zoomInClassName = options.zoomInClassName !== undefined
                ? options.zoomInClassName
                : className + '-in';
            var zoomOutClassName = options.zoomOutClassName !== undefined
                ? options.zoomOutClassName
                : className + '-out';
            var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
            var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';
            var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
            var zoomOutTipLabel = options.zoomOutTipLabel !== undefined
                ? options.zoomOutTipLabel
                : 'Zoom out';
            var inElement = document.createElement('button');
            inElement.className = zoomInClassName;
            inElement.setAttribute('type', 'button');
            inElement.title = zoomInTipLabel;
            inElement.appendChild(typeof zoomInLabel === 'string'
                ? document.createTextNode(zoomInLabel)
                : zoomInLabel);
            inElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, delta), false);
            var outElement = document.createElement('button');
            outElement.className = zoomOutClassName;
            outElement.setAttribute('type', 'button');
            outElement.title = zoomOutTipLabel;
            outElement.appendChild(typeof zoomOutLabel === 'string'
                ? document.createTextNode(zoomOutLabel)
                : zoomOutLabel);
            outElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, -delta), false);
            var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
            var element = _this.element;
            element.className = cssClasses;
            element.appendChild(inElement);
            element.appendChild(outElement);
            /**
             * @type {number}
             * @private
             */
            _this.duration_ = options.duration !== undefined ? options.duration : 250;
            return _this;
        }
        /**
         * @param {number} delta Zoom delta.
         * @param {MouseEvent} event The event to handle
         * @private
         */
        Zoom.prototype.handleClick_ = function (delta, event) {
            event.preventDefault();
            this.zoomByDelta_(delta);
        };
        /**
         * @param {number} delta Zoom delta.
         * @private
         */
        Zoom.prototype.zoomByDelta_ = function (delta) {
            var map = this.getMap();
            var view = map.getView();
            if (!view) {
                // the map does not have a view, so we can't act
                // upon it
                return;
            }
            var currentZoom = view.getZoom();
            if (currentZoom !== undefined) {
                var newZoom = view.getConstrainedZoom(currentZoom + delta);
                if (this.duration_ > 0) {
                    if (view.getAnimating()) {
                        view.cancelAnimations();
                    }
                    view.animate({
                        zoom: newZoom,
                        duration: this.duration_,
                        easing: easeOut,
                    });
                }
                else {
                    view.setZoom(newZoom);
                }
            }
        };
        return Zoom;
    }(Control));

    /**
     * @module ol/control
     */
    /**
     * @typedef {Object} DefaultsOptions
     * @property {boolean} [attribution=true] Include
     * {@link module:ol/control/Attribution~Attribution}.
     * @property {import("./control/Attribution.js").Options} [attributionOptions]
     * Options for {@link module:ol/control/Attribution~Attribution}.
     * @property {boolean} [rotate=true] Include
     * {@link module:ol/control/Rotate~Rotate}.
     * @property {import("./control/Rotate.js").Options} [rotateOptions] Options
     * for {@link module:ol/control/Rotate~Rotate}.
     * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
     * @property {import("./control/Zoom.js").Options} [zoomOptions] Options for
     * {@link module:ol/control/Zoom~Zoom}.
     * @api
     */
    /**
     * Set of controls included in maps by default. Unless configured otherwise,
     * this returns a collection containing an instance of each of the following
     * controls:
     * * {@link module:ol/control/Zoom~Zoom}
     * * {@link module:ol/control/Rotate~Rotate}
     * * {@link module:ol/control/Attribution~Attribution}
     *
     * @param {DefaultsOptions=} opt_options
     * Defaults options.
     * @return {Collection<import("./control/Control.js").default>}
     * Controls.
     * @api
     */
    function defaults$2(opt_options) {
        var options = opt_options ? opt_options : {};
        var controls = new Collection();
        var zoomControl = options.zoom !== undefined ? options.zoom : true;
        if (zoomControl) {
            controls.push(new Zoom(options.zoomOptions));
        }
        var rotateControl = options.rotate !== undefined ? options.rotate : true;
        if (rotateControl) {
            controls.push(new Rotate(options.rotateOptions));
        }
        var attributionControl = options.attribution !== undefined ? options.attribution : true;
        if (attributionControl) {
            controls.push(new Attribution(options.attributionOptions));
        }
        return controls;
    }

    var __extends$m = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {number} [duration=250] Animation duration in milliseconds.
     * @property {number} [delta=1] The zoom delta applied on each double click.
     */
    /**
     * @classdesc
     * Allows the user to zoom by double-clicking on the map.
     * @api
     */
    var DoubleClickZoom = /** @class */ (function (_super) {
        __extends$m(DoubleClickZoom, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function DoubleClickZoom(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            /**
             * @private
             * @type {number}
             */
            _this.delta_ = options.delta ? options.delta : 1;
            /**
             * @private
             * @type {number}
             */
            _this.duration_ = options.duration !== undefined ? options.duration : 250;
            return _this;
        }
        /**
         * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a
         * doubleclick) and eventually zooms the map.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
         * @return {boolean} `false` to stop event propagation.
         */
        DoubleClickZoom.prototype.handleEvent = function (mapBrowserEvent) {
            var stopEvent = false;
            if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {
                var browserEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
                var map = mapBrowserEvent.map;
                var anchor = mapBrowserEvent.coordinate;
                var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
                var view = map.getView();
                zoomByDelta(view, delta, anchor, this.duration_);
                browserEvent.preventDefault();
                stopEvent = true;
            }
            return !stopEvent;
        };
        return DoubleClickZoom;
    }(Interaction));

    var __extends$l = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
     * Function handling "down" events. If the function returns `true` then a drag
     * sequence is started.
     * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
     * Function handling "drag" events. This function is called on "move" events
     * during a drag sequence.
     * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
     * Method called by the map to notify the interaction that a browser event was
     * dispatched to the map. The function may return `false` to prevent the
     * propagation of the event to other interactions in the map's interactions
     * chain.
     * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
     * Function handling "move" events. This function is called on "move" events.
     * This functions is also called during a drag sequence, so during a drag
     * sequence both the `handleDragEvent` function and this function are called.
     * If `handleDownEvent` is defined and it returns true this function will not
     * be called during a drag sequence.
     * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
     *  Function handling "up" events. If the function returns `false` then the
     * current drag sequence is stopped.
     * @property {function(boolean):boolean} [stopDown]
     * Should the down event be propagated to other interactions, or should be
     * stopped?
     */
    /**
     * @classdesc
     * Base class that calls user-defined functions on `down`, `move` and `up`
     * events. This class also manages "drag sequences".
     *
     * When the `handleDownEvent` user function returns `true` a drag sequence is
     * started. During a drag sequence the `handleDragEvent` user function is
     * called on `move` events. The drag sequence ends when the `handleUpEvent`
     * user function is called and returns `false`.
     * @api
     */
    var PointerInteraction = /** @class */ (function (_super) {
        __extends$l(PointerInteraction, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function PointerInteraction(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, 
            /** @type {import("./Interaction.js").InteractionOptions} */ (options)) || this;
            if (options.handleDownEvent) {
                _this.handleDownEvent = options.handleDownEvent;
            }
            if (options.handleDragEvent) {
                _this.handleDragEvent = options.handleDragEvent;
            }
            if (options.handleMoveEvent) {
                _this.handleMoveEvent = options.handleMoveEvent;
            }
            if (options.handleUpEvent) {
                _this.handleUpEvent = options.handleUpEvent;
            }
            if (options.stopDown) {
                _this.stopDown = options.stopDown;
            }
            /**
             * @type {boolean}
             * @protected
             */
            _this.handlingDownUpSequence = false;
            /**
             * @type {!Object<string, PointerEvent>}
             * @private
             */
            _this.trackedPointers_ = {};
            /**
             * @type {Array<PointerEvent>}
             * @protected
             */
            _this.targetPointers = [];
            return _this;
        }
        /**
         * Returns the current number of pointers involved in the interaction,
         * e.g. `2` when two fingers are used.
         * @return {number} The number of pointers.
         * @api
         */
        PointerInteraction.prototype.getPointerCount = function () {
            return this.targetPointers.length;
        };
        /**
         * Handle pointer down events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @return {boolean} If the event was consumed.
         * @protected
         */
        PointerInteraction.prototype.handleDownEvent = function (mapBrowserEvent) {
            return false;
        };
        /**
         * Handle pointer drag events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @protected
         */
        PointerInteraction.prototype.handleDragEvent = function (mapBrowserEvent) { };
        /**
         * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into
         * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
         * detected.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
         * @return {boolean} `false` to stop event propagation.
         * @api
         */
        PointerInteraction.prototype.handleEvent = function (mapBrowserEvent) {
            if (!mapBrowserEvent.originalEvent) {
                return true;
            }
            var stopEvent = false;
            this.updateTrackedPointers_(mapBrowserEvent);
            if (this.handlingDownUpSequence) {
                if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {
                    this.handleDragEvent(mapBrowserEvent);
                    // prevent page scrolling during dragging
                    mapBrowserEvent.originalEvent.preventDefault();
                }
                else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
                    var handledUp = this.handleUpEvent(mapBrowserEvent);
                    this.handlingDownUpSequence =
                        handledUp && this.targetPointers.length > 0;
                }
            }
            else {
                if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
                    var handled = this.handleDownEvent(mapBrowserEvent);
                    this.handlingDownUpSequence = handled;
                    stopEvent = this.stopDown(handled);
                }
                else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {
                    this.handleMoveEvent(mapBrowserEvent);
                }
            }
            return !stopEvent;
        };
        /**
         * Handle pointer move events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @protected
         */
        PointerInteraction.prototype.handleMoveEvent = function (mapBrowserEvent) { };
        /**
         * Handle pointer up events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @return {boolean} If the event was consumed.
         * @protected
         */
        PointerInteraction.prototype.handleUpEvent = function (mapBrowserEvent) {
            return false;
        };
        /**
         * This function is used to determine if "down" events should be propagated
         * to other interactions or should be stopped.
         * @param {boolean} handled Was the event handled by the interaction?
         * @return {boolean} Should the `down` event be stopped?
         */
        PointerInteraction.prototype.stopDown = function (handled) {
            return handled;
        };
        /**
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @private
         */
        PointerInteraction.prototype.updateTrackedPointers_ = function (mapBrowserEvent) {
            if (isPointerDraggingEvent(mapBrowserEvent)) {
                var event_1 = mapBrowserEvent.originalEvent;
                var id = event_1.pointerId.toString();
                if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
                    delete this.trackedPointers_[id];
                }
                else if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
                    this.trackedPointers_[id] = event_1;
                }
                else if (id in this.trackedPointers_) {
                    // update only when there was a pointerdown event for this pointer
                    this.trackedPointers_[id] = event_1;
                }
                this.targetPointers = getValues(this.trackedPointers_);
            }
        };
        return PointerInteraction;
    }(Interaction));
    /**
     * @param {Array<PointerEvent>} pointerEvents List of events.
     * @return {import("../pixel.js").Pixel} Centroid pixel.
     */
    function centroid(pointerEvents) {
        var length = pointerEvents.length;
        var clientX = 0;
        var clientY = 0;
        for (var i = 0; i < length; i++) {
            clientX += pointerEvents[i].clientX;
            clientY += pointerEvents[i].clientY;
        }
        return [clientX / length, clientY / length];
    }
    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} Whether the event is a pointerdown, pointerdrag
     *     or pointerup event.
     */
    function isPointerDraggingEvent(mapBrowserEvent) {
        var type = mapBrowserEvent.type;
        return (type === MapBrowserEventType.POINTERDOWN ||
            type === MapBrowserEventType.POINTERDRAG ||
            type === MapBrowserEventType.POINTERUP);
    }

    /**
     * @module ol/events/condition
     */
    /**
     * A function that takes an {@link module:ol/MapBrowserEvent} and returns a
     * `{boolean}`. If the condition is met, true should be returned.
     *
     * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
     */
    /**
     * Creates a condition function that passes when all provided conditions pass.
     * @param {...Condition} var_args Conditions to check.
     * @return {Condition} Condition function.
     */
    function all(var_args) {
        var conditions = arguments;
        /**
         * @param {import("../MapBrowserEvent.js").default} event Event.
         * @return {boolean} All conditions passed.
         */
        return function (event) {
            var pass = true;
            for (var i = 0, ii = conditions.length; i < ii; ++i) {
                pass = pass && conditions[i](event);
                if (!pass) {
                    break;
                }
            }
            return pass;
        };
    }
    /**
     * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
     * (e.g. when additionally the platform-modifier-key is pressed).
     *
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} True if only the alt and shift keys are pressed.
     * @api
     */
    var altShiftKeysOnly = function (mapBrowserEvent) {
        var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
        return (originalEvent.altKey &&
            !(originalEvent.metaKey || originalEvent.ctrlKey) &&
            originalEvent.shiftKey);
    };
    /**
     * Return `true` if the map has the focus. This condition requires a map target
     * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
     *
     * @param {import("../MapBrowserEvent.js").default} event Map browser event.
     * @return {boolean} The map has the focus.
     * @api
     */
    var focus = function (event) {
        return event.target.getTargetElement().contains(document.activeElement);
    };
    /**
     * Return `true` if the map has the focus or no 'tabindex' attribute set.
     *
     * @param {import("../MapBrowserEvent.js").default} event Map browser event.
     * @return {boolean} The map container has the focus or no 'tabindex' attribute.
     */
    var focusWithTabindex = function (event) {
        return event.map.getTargetElement().hasAttribute('tabindex')
            ? focus(event)
            : true;
    };
    /**
     * Return always true.
     *
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} True.
     * @api
     */
    var always = TRUE;
    /**
     * Return `true` if the event has an "action"-producing mouse button.
     *
     * By definition, this includes left-click on windows/linux, and left-click
     * without the ctrl key on Macs.
     *
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} The result.
     */
    var mouseActionButton = function (mapBrowserEvent) {
        var originalEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
        return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
    };
    /**
     * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
     * pressed.
     *
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} True only if there no modifier keys are pressed.
     * @api
     */
    var noModifierKeys = function (mapBrowserEvent) {
        var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
        return (!originalEvent.altKey &&
            !(originalEvent.metaKey || originalEvent.ctrlKey) &&
            !originalEvent.shiftKey);
    };
    /**
     * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
     * additionally the alt-key is pressed).
     *
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} True if only the shift key is pressed.
     * @api
     */
    var shiftKeyOnly = function (mapBrowserEvent) {
        var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
        return (!originalEvent.altKey &&
            !(originalEvent.metaKey || originalEvent.ctrlKey) &&
            originalEvent.shiftKey);
    };
    /**
     * Return `true` if the target element is not editable, i.e. not a `<input>`-,
     * `<select>`- or `<textarea>`-element, `false` otherwise.
     *
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} True only if the target element is not editable.
     * @api
     */
    var targetNotEditable = function (mapBrowserEvent) {
        var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
        var tagName = /** @type {Element} */ (originalEvent.target).tagName;
        return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';
    };
    /**
     * Return `true` if the event originates from a mouse device.
     *
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} True if the event originates from a mouse device.
     * @api
     */
    var mouseOnly = function (mapBrowserEvent) {
        var pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (mapBrowserEvent)
            .originalEvent;
        assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
        // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
        return pointerEvent.pointerType == 'mouse';
    };
    /**
     * Return `true` if the event originates from a primary pointer in
     * contact with the surface or if the left mouse button is pressed.
     * See http://www.w3.org/TR/pointerevents/#button-states.
     *
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} True if the event originates from a primary pointer.
     * @api
     */
    var primaryAction = function (mapBrowserEvent) {
        var pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (mapBrowserEvent)
            .originalEvent;
        assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
        return pointerEvent.isPrimary && pointerEvent.button === 0;
    };

    var __extends$k = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
     * to indicate whether that event should be handled.
     * Default is {@link module:ol/events/condition~noModifierKeys} and {@link module:ol/events/condition~primaryAction}.
     * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
     * the interaction will only handle events when the map has the focus.
     * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
     */
    /**
     * @classdesc
     * Allows the user to pan the map by dragging the map.
     * @api
     */
    var DragPan = /** @class */ (function (_super) {
        __extends$k(DragPan, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function DragPan(opt_options) {
            var _this = _super.call(this, {
                stopDown: FALSE,
            }) || this;
            var options = opt_options ? opt_options : {};
            /**
             * @private
             * @type {import("../Kinetic.js").default|undefined}
             */
            _this.kinetic_ = options.kinetic;
            /**
             * @type {import("../pixel.js").Pixel}
             */
            _this.lastCentroid = null;
            /**
             * @type {number}
             */
            _this.lastPointersCount_;
            /**
             * @type {boolean}
             */
            _this.panning_ = false;
            var condition = options.condition
                ? options.condition
                : all(noModifierKeys, primaryAction);
            /**
             * @private
             * @type {import("../events/condition.js").Condition}
             */
            _this.condition_ = options.onFocusOnly
                ? all(focusWithTabindex, condition)
                : condition;
            /**
             * @private
             * @type {boolean}
             */
            _this.noKinetic_ = false;
            return _this;
        }
        /**
         * Handle pointer drag events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         */
        DragPan.prototype.handleDragEvent = function (mapBrowserEvent) {
            if (!this.panning_) {
                this.panning_ = true;
                this.getMap().getView().beginInteraction();
            }
            var targetPointers = this.targetPointers;
            var centroid$1 = centroid(targetPointers);
            if (targetPointers.length == this.lastPointersCount_) {
                if (this.kinetic_) {
                    this.kinetic_.update(centroid$1[0], centroid$1[1]);
                }
                if (this.lastCentroid) {
                    var delta = [
                        this.lastCentroid[0] - centroid$1[0],
                        centroid$1[1] - this.lastCentroid[1],
                    ];
                    var map = mapBrowserEvent.map;
                    var view = map.getView();
                    scale$2(delta, view.getResolution());
                    rotate$1(delta, view.getRotation());
                    view.adjustCenterInternal(delta);
                }
            }
            else if (this.kinetic_) {
                // reset so we don't overestimate the kinetic energy after
                // after one finger down, tiny drag, second finger down
                this.kinetic_.begin();
            }
            this.lastCentroid = centroid$1;
            this.lastPointersCount_ = targetPointers.length;
            mapBrowserEvent.originalEvent.preventDefault();
        };
        /**
         * Handle pointer up events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @return {boolean} If the event was consumed.
         */
        DragPan.prototype.handleUpEvent = function (mapBrowserEvent) {
            var map = mapBrowserEvent.map;
            var view = map.getView();
            if (this.targetPointers.length === 0) {
                if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
                    var distance = this.kinetic_.getDistance();
                    var angle = this.kinetic_.getAngle();
                    var center = view.getCenterInternal();
                    var centerpx = map.getPixelFromCoordinateInternal(center);
                    var dest = map.getCoordinateFromPixelInternal([
                        centerpx[0] - distance * Math.cos(angle),
                        centerpx[1] - distance * Math.sin(angle),
                    ]);
                    view.animateInternal({
                        center: view.getConstrainedCenter(dest),
                        duration: 500,
                        easing: easeOut,
                    });
                }
                if (this.panning_) {
                    this.panning_ = false;
                    view.endInteraction();
                }
                return false;
            }
            else {
                if (this.kinetic_) {
                    // reset so we don't overestimate the kinetic energy after
                    // after one finger up, tiny drag, second finger up
                    this.kinetic_.begin();
                }
                this.lastCentroid = null;
                return true;
            }
        };
        /**
         * Handle pointer down events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @return {boolean} If the event was consumed.
         */
        DragPan.prototype.handleDownEvent = function (mapBrowserEvent) {
            if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
                var map = mapBrowserEvent.map;
                var view = map.getView();
                this.lastCentroid = null;
                // stop any current animation
                if (view.getAnimating()) {
                    view.cancelAnimations();
                }
                if (this.kinetic_) {
                    this.kinetic_.begin();
                }
                // No kinetic as soon as more than one pointer on the screen is
                // detected. This is to prevent nasty pans after pinch.
                this.noKinetic_ = this.targetPointers.length > 1;
                return true;
            }
            else {
                return false;
            }
        };
        return DragPan;
    }(PointerInteraction));

    var __extends$j = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {import("../events/condition.js").Condition} [condition] A function that takes an
     * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
     * to indicate whether that event should be handled.
     * Default is {@link module:ol/events/condition~altShiftKeysOnly}.
     * @property {number} [duration=250] Animation duration in milliseconds.
     */
    /**
     * @classdesc
     * Allows the user to rotate the map by clicking and dragging on the map,
     * normally combined with an {@link module:ol/events/condition} that limits
     * it to when the alt and shift keys are held down.
     *
     * This interaction is only supported for mouse devices.
     * @api
     */
    var DragRotate = /** @class */ (function (_super) {
        __extends$j(DragRotate, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function DragRotate(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
                stopDown: FALSE,
            }) || this;
            /**
             * @private
             * @type {import("../events/condition.js").Condition}
             */
            _this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.lastAngle_ = undefined;
            /**
             * @private
             * @type {number}
             */
            _this.duration_ = options.duration !== undefined ? options.duration : 250;
            return _this;
        }
        /**
         * Handle pointer drag events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         */
        DragRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
            if (!mouseOnly(mapBrowserEvent)) {
                return;
            }
            var map = mapBrowserEvent.map;
            var view = map.getView();
            if (view.getConstraints().rotation === disable) {
                return;
            }
            var size = map.getSize();
            var offset = mapBrowserEvent.pixel;
            var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
            if (this.lastAngle_ !== undefined) {
                var delta = theta - this.lastAngle_;
                view.adjustRotationInternal(-delta);
            }
            this.lastAngle_ = theta;
        };
        /**
         * Handle pointer up events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @return {boolean} If the event was consumed.
         */
        DragRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
            if (!mouseOnly(mapBrowserEvent)) {
                return true;
            }
            var map = mapBrowserEvent.map;
            var view = map.getView();
            view.endInteraction(this.duration_);
            return false;
        };
        /**
         * Handle pointer down events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @return {boolean} If the event was consumed.
         */
        DragRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
            if (!mouseOnly(mapBrowserEvent)) {
                return false;
            }
            if (mouseActionButton(mapBrowserEvent) &&
                this.condition_(mapBrowserEvent)) {
                var map = mapBrowserEvent.map;
                map.getView().beginInteraction();
                this.lastAngle_ = undefined;
                return true;
            }
            else {
                return false;
            }
        };
        return DragRotate;
    }(PointerInteraction));

    /**
     * @module ol/render/Box
     */
    var __extends$i = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var RenderBox = /** @class */ (function (_super) {
        __extends$i(RenderBox, _super);
        /**
         * @param {string} className CSS class name.
         */
        function RenderBox(className) {
            var _this = _super.call(this) || this;
            /**
             * @type {import("../geom/Polygon.js").default}
             * @private
             */
            _this.geometry_ = null;
            /**
             * @type {HTMLDivElement}
             * @private
             */
            _this.element_ = document.createElement('div');
            _this.element_.style.position = 'absolute';
            _this.element_.style.pointerEvents = 'auto';
            _this.element_.className = 'ol-box ' + className;
            /**
             * @private
             * @type {import("../PluggableMap.js").default}
             */
            _this.map_ = null;
            /**
             * @private
             * @type {import("../pixel.js").Pixel}
             */
            _this.startPixel_ = null;
            /**
             * @private
             * @type {import("../pixel.js").Pixel}
             */
            _this.endPixel_ = null;
            return _this;
        }
        /**
         * Clean up.
         */
        RenderBox.prototype.disposeInternal = function () {
            this.setMap(null);
        };
        /**
         * @private
         */
        RenderBox.prototype.render_ = function () {
            var startPixel = this.startPixel_;
            var endPixel = this.endPixel_;
            var px = 'px';
            var style = this.element_.style;
            style.left = Math.min(startPixel[0], endPixel[0]) + px;
            style.top = Math.min(startPixel[1], endPixel[1]) + px;
            style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
            style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
        };
        /**
         * @param {import("../PluggableMap.js").default} map Map.
         */
        RenderBox.prototype.setMap = function (map) {
            if (this.map_) {
                this.map_.getOverlayContainer().removeChild(this.element_);
                var style = this.element_.style;
                style.left = 'inherit';
                style.top = 'inherit';
                style.width = 'inherit';
                style.height = 'inherit';
            }
            this.map_ = map;
            if (this.map_) {
                this.map_.getOverlayContainer().appendChild(this.element_);
            }
        };
        /**
         * @param {import("../pixel.js").Pixel} startPixel Start pixel.
         * @param {import("../pixel.js").Pixel} endPixel End pixel.
         */
        RenderBox.prototype.setPixels = function (startPixel, endPixel) {
            this.startPixel_ = startPixel;
            this.endPixel_ = endPixel;
            this.createOrUpdateGeometry();
            this.render_();
        };
        /**
         * Creates or updates the cached geometry.
         */
        RenderBox.prototype.createOrUpdateGeometry = function () {
            var startPixel = this.startPixel_;
            var endPixel = this.endPixel_;
            var pixels = [
                startPixel,
                [startPixel[0], endPixel[1]],
                endPixel,
                [endPixel[0], startPixel[1]],
            ];
            var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
            // close the polygon
            coordinates[4] = coordinates[0].slice();
            if (!this.geometry_) {
                this.geometry_ = new Polygon([coordinates]);
            }
            else {
                this.geometry_.setCoordinates([coordinates]);
            }
        };
        /**
         * @return {import("../geom/Polygon.js").default} Geometry.
         */
        RenderBox.prototype.getGeometry = function () {
            return this.geometry_;
        };
        return RenderBox;
    }(Disposable));

    var __extends$h = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A function that takes a {@link module:ol/MapBrowserEvent} and two
     * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
     * true should be returned.
     * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
     */
    /**
     * @typedef {Object} Options
     * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
     * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
     * to indicate whether that event should be handled.
     * Default is {@link ol/events/condition~mouseActionButton}.
     * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
     * `boxEndCondition` function.
     * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
     * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
     * Default is `true` if the area of the box is bigger than the `minArea` option.
     * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
     * before `boxend` is fired.
     */
    /**
     * @enum {string}
     */
    var DragBoxEventType = {
        /**
         * Triggered upon drag box start.
         * @event DragBoxEvent#boxstart
         * @api
         */
        BOXSTART: 'boxstart',
        /**
         * Triggered on drag when box is active.
         * @event DragBoxEvent#boxdrag
         * @api
         */
        BOXDRAG: 'boxdrag',
        /**
         * Triggered upon drag box end.
         * @event DragBoxEvent#boxend
         * @api
         */
        BOXEND: 'boxend',
        /**
         * Triggered upon drag box canceled.
         * @event DragBoxEvent#boxcancel
         * @api
         */
        BOXCANCEL: 'boxcancel',
    };
    /**
     * @classdesc
     * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
     * this type.
     */
    var DragBoxEvent = /** @class */ (function (_super) {
        __extends$h(DragBoxEvent, _super);
        /**
         * @param {string} type The event type.
         * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
         */
        function DragBoxEvent(type, coordinate, mapBrowserEvent) {
            var _this = _super.call(this, type) || this;
            /**
             * The coordinate of the drag event.
             * @const
             * @type {import("../coordinate.js").Coordinate}
             * @api
             */
            _this.coordinate = coordinate;
            /**
             * @const
             * @type {import("../MapBrowserEvent.js").default}
             * @api
             */
            _this.mapBrowserEvent = mapBrowserEvent;
            return _this;
        }
        return DragBoxEvent;
    }(BaseEvent));
    /**
     * @classdesc
     * Allows the user to draw a vector box by clicking and dragging on the map,
     * normally combined with an {@link module:ol/events/condition} that limits
     * it to when the shift or other key is held down. This is used, for example,
     * for zooming to a specific area of the map
     * (see {@link module:ol/interaction/DragZoom~DragZoom} and
     * {@link module:ol/interaction/DragRotateAndZoom}).
     *
     * @fires DragBoxEvent
     * @api
     */
    var DragBox = /** @class */ (function (_super) {
        __extends$h(DragBox, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function DragBox(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            /**
             * @type {import("../render/Box.js").default}
             * @private
             */
            _this.box_ = new RenderBox(options.className || 'ol-dragbox');
            /**
             * @type {number}
             * @private
             */
            _this.minArea_ = options.minArea !== undefined ? options.minArea : 64;
            if (options.onBoxEnd) {
                _this.onBoxEnd = options.onBoxEnd;
            }
            /**
             * @type {import("../pixel.js").Pixel}
             * @private
             */
            _this.startPixel_ = null;
            /**
             * @private
             * @type {import("../events/condition.js").Condition}
             */
            _this.condition_ = options.condition ? options.condition : mouseActionButton;
            /**
             * @private
             * @type {EndCondition}
             */
            _this.boxEndCondition_ = options.boxEndCondition
                ? options.boxEndCondition
                : _this.defaultBoxEndCondition;
            return _this;
        }
        /**
         * The default condition for determining whether the boxend event
         * should fire.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
         *     leading to the box end.
         * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
         * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
         * @return {boolean} Whether or not the boxend condition should be fired.
         */
        DragBox.prototype.defaultBoxEndCondition = function (mapBrowserEvent, startPixel, endPixel) {
            var width = endPixel[0] - startPixel[0];
            var height = endPixel[1] - startPixel[1];
            return width * width + height * height >= this.minArea_;
        };
        /**
         * Returns geometry of last drawn box.
         * @return {import("../geom/Polygon.js").default} Geometry.
         * @api
         */
        DragBox.prototype.getGeometry = function () {
            return this.box_.getGeometry();
        };
        /**
         * Handle pointer drag events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         */
        DragBox.prototype.handleDragEvent = function (mapBrowserEvent) {
            this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
            this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
        };
        /**
         * Handle pointer up events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @return {boolean} If the event was consumed.
         */
        DragBox.prototype.handleUpEvent = function (mapBrowserEvent) {
            this.box_.setMap(null);
            var completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);
            if (completeBox) {
                this.onBoxEnd(mapBrowserEvent);
            }
            this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
            return false;
        };
        /**
         * Handle pointer down events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @return {boolean} If the event was consumed.
         */
        DragBox.prototype.handleDownEvent = function (mapBrowserEvent) {
            if (this.condition_(mapBrowserEvent)) {
                this.startPixel_ = mapBrowserEvent.pixel;
                this.box_.setMap(mapBrowserEvent.map);
                this.box_.setPixels(this.startPixel_, this.startPixel_);
                this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
                return true;
            }
            else {
                return false;
            }
        };
        /**
         * Function to execute just before `onboxend` is fired
         * @param {import("../MapBrowserEvent.js").default} event Event.
         */
        DragBox.prototype.onBoxEnd = function (event) { };
        return DragBox;
    }(PointerInteraction));

    var __extends$g = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {string} [className='ol-dragzoom'] CSS class name for styling the
     * box.
     * @property {import("../events/condition.js").Condition} [condition] A function that
     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled.
     * Default is {@link module:ol/events/condition~shiftKeyOnly}.
     * @property {number} [duration=200] Animation duration in milliseconds.
     * @property {boolean} [out=false] Use interaction for zooming out.
     * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
     * `boxEndCondition` function.
     */
    /**
     * @classdesc
     * Allows the user to zoom the map by clicking and dragging on the map,
     * normally combined with an {@link module:ol/events/condition} that limits
     * it to when a key, shift by default, is held down.
     *
     * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
     * your custom one configured with `className`.
     * @api
     */
    var DragZoom = /** @class */ (function (_super) {
        __extends$g(DragZoom, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function DragZoom(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var condition = options.condition ? options.condition : shiftKeyOnly;
            _this = _super.call(this, {
                condition: condition,
                className: options.className || 'ol-dragzoom',
                minArea: options.minArea,
            }) || this;
            /**
             * @private
             * @type {number}
             */
            _this.duration_ = options.duration !== undefined ? options.duration : 200;
            /**
             * @private
             * @type {boolean}
             */
            _this.out_ = options.out !== undefined ? options.out : false;
            return _this;
        }
        /**
         * Function to execute just before `onboxend` is fired
         * @param {import("../MapBrowserEvent.js").default} event Event.
         */
        DragZoom.prototype.onBoxEnd = function (event) {
            var map = this.getMap();
            var view = /** @type {!import("../View.js").default} */ (map.getView());
            var size = /** @type {!import("../size.js").Size} */ (map.getSize());
            var extent = this.getGeometry().getExtent();
            if (this.out_) {
                var mapExtent = view.calculateExtentInternal(size);
                var boxPixelExtent = createOrUpdateFromCoordinates([
                    map.getPixelFromCoordinateInternal(getBottomLeft(extent)),
                    map.getPixelFromCoordinateInternal(getTopRight(extent)),
                ]);
                var factor = view.getResolutionForExtentInternal(boxPixelExtent, size);
                scaleFromCenter(mapExtent, 1 / factor);
                extent = mapExtent;
            }
            var resolution = view.getConstrainedResolution(view.getResolutionForExtentInternal(extent, size));
            var center = view.getConstrainedCenter(getCenter(extent), resolution);
            view.animateInternal({
                resolution: resolution,
                center: center,
                duration: this.duration_,
                easing: easeOut,
            });
        };
        return DragZoom;
    }(DragBox));

    /**
     * @module ol/events/KeyCode
     */
    /**
     * @enum {number}
     * @const
     */
    var KeyCode = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
    };

    var __extends$f = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {import("../events/condition.js").Condition} [condition] A function that
     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. Default is
     * {@link module:ol/events/condition~noModifierKeys} and
     * {@link module:ol/events/condition~targetNotEditable}.
     * @property {number} [duration=100] Animation duration in milliseconds.
     * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
     * press.
     */
    /**
     * @classdesc
     * Allows the user to pan the map using keyboard arrows.
     * Note that, although this interaction is by default included in maps,
     * the keys can only be used when browser focus is on the element to which
     * the keyboard events are attached. By default, this is the map div,
     * though you can change this with the `keyboardEventTarget` in
     * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
     * element, focus will have to be on, and returned to, this element if the keys
     * are to function.
     * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
     * @api
     */
    var KeyboardPan = /** @class */ (function (_super) {
        __extends$f(KeyboardPan, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function KeyboardPan(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options || {};
            /**
             * @private
             * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
             * @return {boolean} Combined condition result.
             */
            _this.defaultCondition_ = function (mapBrowserEvent) {
                return (noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent));
            };
            /**
             * @private
             * @type {import("../events/condition.js").Condition}
             */
            _this.condition_ =
                options.condition !== undefined
                    ? options.condition
                    : _this.defaultCondition_;
            /**
             * @private
             * @type {number}
             */
            _this.duration_ = options.duration !== undefined ? options.duration : 100;
            /**
             * @private
             * @type {number}
             */
            _this.pixelDelta_ =
                options.pixelDelta !== undefined ? options.pixelDelta : 128;
            return _this;
        }
        /**
         * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
         * `KeyEvent`, and decides the direction to pan to (if an arrow key was
         * pressed).
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
         * @return {boolean} `false` to stop event propagation.
         * @this {KeyboardPan}
         */
        KeyboardPan.prototype.handleEvent = function (mapBrowserEvent) {
            var stopEvent = false;
            if (mapBrowserEvent.type == EventType.KEYDOWN) {
                var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
                var keyCode = keyEvent.keyCode;
                if (this.condition_(mapBrowserEvent) &&
                    (keyCode == KeyCode.DOWN ||
                        keyCode == KeyCode.LEFT ||
                        keyCode == KeyCode.RIGHT ||
                        keyCode == KeyCode.UP)) {
                    var map = mapBrowserEvent.map;
                    var view = map.getView();
                    var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
                    var deltaX = 0, deltaY = 0;
                    if (keyCode == KeyCode.DOWN) {
                        deltaY = -mapUnitsDelta;
                    }
                    else if (keyCode == KeyCode.LEFT) {
                        deltaX = -mapUnitsDelta;
                    }
                    else if (keyCode == KeyCode.RIGHT) {
                        deltaX = mapUnitsDelta;
                    }
                    else {
                        deltaY = mapUnitsDelta;
                    }
                    var delta = [deltaX, deltaY];
                    rotate$1(delta, view.getRotation());
                    pan(view, delta, this.duration_);
                    keyEvent.preventDefault();
                    stopEvent = true;
                }
            }
            return !stopEvent;
        };
        return KeyboardPan;
    }(Interaction));

    var __extends$e = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {number} [duration=100] Animation duration in milliseconds.
     * @property {import("../events/condition.js").Condition} [condition] A function that
     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. Default is
     * {@link module:ol/events/condition~targetNotEditable}.
     * @property {number} [delta=1] The zoom level delta on each key press.
     */
    /**
     * @classdesc
     * Allows the user to zoom the map using keyboard + and -.
     * Note that, although this interaction is by default included in maps,
     * the keys can only be used when browser focus is on the element to which
     * the keyboard events are attached. By default, this is the map div,
     * though you can change this with the `keyboardEventTarget` in
     * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
     * element, focus will have to be on, and returned to, this element if the keys
     * are to function.
     * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
     * @api
     */
    var KeyboardZoom = /** @class */ (function (_super) {
        __extends$e(KeyboardZoom, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function KeyboardZoom(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            /**
             * @private
             * @type {import("../events/condition.js").Condition}
             */
            _this.condition_ = options.condition ? options.condition : targetNotEditable;
            /**
             * @private
             * @type {number}
             */
            _this.delta_ = options.delta ? options.delta : 1;
            /**
             * @private
             * @type {number}
             */
            _this.duration_ = options.duration !== undefined ? options.duration : 100;
            return _this;
        }
        /**
         * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
         * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
         * key pressed was '+' or '-').
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
         * @return {boolean} `false` to stop event propagation.
         * @this {KeyboardZoom}
         */
        KeyboardZoom.prototype.handleEvent = function (mapBrowserEvent) {
            var stopEvent = false;
            if (mapBrowserEvent.type == EventType.KEYDOWN ||
                mapBrowserEvent.type == EventType.KEYPRESS) {
                var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
                var charCode = keyEvent.charCode;
                if (this.condition_(mapBrowserEvent) &&
                    (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
                    var map = mapBrowserEvent.map;
                    var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
                    var view = map.getView();
                    zoomByDelta(view, delta, undefined, this.duration_);
                    keyEvent.preventDefault();
                    stopEvent = true;
                }
            }
            return !stopEvent;
        };
        return KeyboardZoom;
    }(Interaction));

    /**
     * @module ol/Kinetic
     */
    /**
     * @classdesc
     * Implementation of inertial deceleration for map movement.
     *
     * @api
     */
    var Kinetic = /** @class */ (function () {
        /**
         * @param {number} decay Rate of decay (must be negative).
         * @param {number} minVelocity Minimum velocity (pixels/millisecond).
         * @param {number} delay Delay to consider to calculate the kinetic
         *     initial values (milliseconds).
         */
        function Kinetic(decay, minVelocity, delay) {
            /**
             * @private
             * @type {number}
             */
            this.decay_ = decay;
            /**
             * @private
             * @type {number}
             */
            this.minVelocity_ = minVelocity;
            /**
             * @private
             * @type {number}
             */
            this.delay_ = delay;
            /**
             * @private
             * @type {Array<number>}
             */
            this.points_ = [];
            /**
             * @private
             * @type {number}
             */
            this.angle_ = 0;
            /**
             * @private
             * @type {number}
             */
            this.initialVelocity_ = 0;
        }
        /**
         * FIXME empty description for jsdoc
         */
        Kinetic.prototype.begin = function () {
            this.points_.length = 0;
            this.angle_ = 0;
            this.initialVelocity_ = 0;
        };
        /**
         * @param {number} x X.
         * @param {number} y Y.
         */
        Kinetic.prototype.update = function (x, y) {
            this.points_.push(x, y, Date.now());
        };
        /**
         * @return {boolean} Whether we should do kinetic animation.
         */
        Kinetic.prototype.end = function () {
            if (this.points_.length < 6) {
                // at least 2 points are required (i.e. there must be at least 6 elements
                // in the array)
                return false;
            }
            var delay = Date.now() - this.delay_;
            var lastIndex = this.points_.length - 3;
            if (this.points_[lastIndex + 2] < delay) {
                // the last tracked point is too old, which means that the user stopped
                // panning before releasing the map
                return false;
            }
            // get the first point which still falls into the delay time
            var firstIndex = lastIndex - 3;
            while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
                firstIndex -= 3;
            }
            var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
            // we don't want a duration of 0 (divide by zero)
            // we also make sure the user panned for a duration of at least one frame
            // (1/60s) to compute sane displacement values
            if (duration < 1000 / 60) {
                return false;
            }
            var dx = this.points_[lastIndex] - this.points_[firstIndex];
            var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
            this.angle_ = Math.atan2(dy, dx);
            this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
            return this.initialVelocity_ > this.minVelocity_;
        };
        /**
         * @return {number} Total distance travelled (pixels).
         */
        Kinetic.prototype.getDistance = function () {
            return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
        };
        /**
         * @return {number} Angle of the kinetic panning animation (radians).
         */
        Kinetic.prototype.getAngle = function () {
            return this.angle_;
        };
        return Kinetic;
    }());

    var __extends$d = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @enum {string}
     */
    var Mode = {
        TRACKPAD: 'trackpad',
        WHEEL: 'wheel',
    };
    /**
     * @typedef {Object} Options
     * @property {import("../events/condition.js").Condition} [condition] A function that
     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. Default is
     * {@link module:ol/events/condition~always}.
     * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
     * the interaction will only handle events when the map has the focus.
     * @property {number} [maxDelta=1] Maximum mouse wheel delta.
     * @property {number} [duration=250] Animation duration in milliseconds.
     * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
     * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
     * location as the anchor. When set to `false`, zooming in and out will zoom to
     * the center of the screen instead of zooming on the mouse's location.
     * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
     * event will always animate to the closest zoom level after an interaction;
     * false means intermediary zoom levels are allowed.
     */
    /**
     * @classdesc
     * Allows the user to zoom the map by scrolling the mouse wheel.
     * @api
     */
    var MouseWheelZoom = /** @class */ (function (_super) {
        __extends$d(MouseWheelZoom, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function MouseWheelZoom(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, 
            /** @type {import("./Interaction.js").InteractionOptions} */ (options)) || this;
            /**
             * @private
             * @type {number}
             */
            _this.totalDelta_ = 0;
            /**
             * @private
             * @type {number}
             */
            _this.lastDelta_ = 0;
            /**
             * @private
             * @type {number}
             */
            _this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
            /**
             * @private
             * @type {number}
             */
            _this.duration_ = options.duration !== undefined ? options.duration : 250;
            /**
             * @private
             * @type {number}
             */
            _this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
            /**
             * @private
             * @type {boolean}
             */
            _this.useAnchor_ =
                options.useAnchor !== undefined ? options.useAnchor : true;
            /**
             * @private
             * @type {boolean}
             */
            _this.constrainResolution_ =
                options.constrainResolution !== undefined
                    ? options.constrainResolution
                    : false;
            var condition = options.condition ? options.condition : always;
            /**
             * @private
             * @type {import("../events/condition.js").Condition}
             */
            _this.condition_ = options.onFocusOnly
                ? all(focusWithTabindex, condition)
                : condition;
            /**
             * @private
             * @type {?import("../coordinate.js").Coordinate}
             */
            _this.lastAnchor_ = null;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.startTime_ = undefined;
            /**
             * @private
             * @type {?}
             */
            _this.timeoutId_;
            /**
             * @private
             * @type {Mode|undefined}
             */
            _this.mode_ = undefined;
            /**
             * Trackpad events separated by this delay will be considered separate
             * interactions.
             * @type {number}
             */
            _this.trackpadEventGap_ = 400;
            /**
             * @type {?}
             */
            _this.trackpadTimeoutId_;
            /**
             * The number of delta values per zoom level
             * @private
             * @type {number}
             */
            _this.deltaPerZoom_ = 300;
            return _this;
        }
        /**
         * @private
         */
        MouseWheelZoom.prototype.endInteraction_ = function () {
            this.trackpadTimeoutId_ = undefined;
            var view = this.getMap().getView();
            view.endInteraction(undefined, this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0, this.lastAnchor_);
        };
        /**
         * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
         * zooms the map.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
         * @return {boolean} `false` to stop event propagation.
         */
        MouseWheelZoom.prototype.handleEvent = function (mapBrowserEvent) {
            if (!this.condition_(mapBrowserEvent)) {
                return true;
            }
            var type = mapBrowserEvent.type;
            if (type !== EventType.WHEEL) {
                return true;
            }
            var map = mapBrowserEvent.map;
            var wheelEvent = /** @type {WheelEvent} */ (mapBrowserEvent.originalEvent);
            wheelEvent.preventDefault();
            if (this.useAnchor_) {
                this.lastAnchor_ = mapBrowserEvent.coordinate;
            }
            // Delta normalisation inspired by
            // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
            var delta;
            if (mapBrowserEvent.type == EventType.WHEEL) {
                delta = wheelEvent.deltaY;
                if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
                    delta /= DEVICE_PIXEL_RATIO;
                }
                if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
                    delta *= 40;
                }
            }
            if (delta === 0) {
                return false;
            }
            else {
                this.lastDelta_ = delta;
            }
            var now = Date.now();
            if (this.startTime_ === undefined) {
                this.startTime_ = now;
            }
            if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
                this.mode_ = Math.abs(delta) < 4 ? Mode.TRACKPAD : Mode.WHEEL;
            }
            var view = map.getView();
            if (this.mode_ === Mode.TRACKPAD &&
                !(view.getConstrainResolution() || this.constrainResolution_)) {
                if (this.trackpadTimeoutId_) {
                    clearTimeout(this.trackpadTimeoutId_);
                }
                else {
                    if (view.getAnimating()) {
                        view.cancelAnimations();
                    }
                    view.beginInteraction();
                }
                this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
                view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
                this.startTime_ = now;
                return false;
            }
            this.totalDelta_ += delta;
            var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
            clearTimeout(this.timeoutId_);
            this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
            return false;
        };
        /**
         * @private
         * @param {import("../PluggableMap.js").default} map Map.
         */
        MouseWheelZoom.prototype.handleWheelZoom_ = function (map) {
            var view = map.getView();
            if (view.getAnimating()) {
                view.cancelAnimations();
            }
            var delta = -clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
            if (view.getConstrainResolution() || this.constrainResolution_) {
                // view has a zoom constraint, zoom by 1
                delta = delta ? (delta > 0 ? 1 : -1) : 0;
            }
            zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
            this.mode_ = undefined;
            this.totalDelta_ = 0;
            this.lastAnchor_ = null;
            this.startTime_ = undefined;
            this.timeoutId_ = undefined;
        };
        /**
         * Enable or disable using the mouse's location as an anchor when zooming
         * @param {boolean} useAnchor true to zoom to the mouse's location, false
         * to zoom to the center of the map
         * @api
         */
        MouseWheelZoom.prototype.setMouseAnchor = function (useAnchor) {
            this.useAnchor_ = useAnchor;
            if (!useAnchor) {
                this.lastAnchor_ = null;
            }
        };
        return MouseWheelZoom;
    }(Interaction));

    var __extends$c = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {number} [duration=250] The duration of the animation in
     * milliseconds.
     * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
     */
    /**
     * @classdesc
     * Allows the user to rotate the map by twisting with two fingers
     * on a touch screen.
     * @api
     */
    var PinchRotate = /** @class */ (function (_super) {
        __extends$c(PinchRotate, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function PinchRotate(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
            if (!pointerOptions.stopDown) {
                pointerOptions.stopDown = FALSE;
            }
            _this = _super.call(this, pointerOptions) || this;
            /**
             * @private
             * @type {import("../coordinate.js").Coordinate}
             */
            _this.anchor_ = null;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.lastAngle_ = undefined;
            /**
             * @private
             * @type {boolean}
             */
            _this.rotating_ = false;
            /**
             * @private
             * @type {number}
             */
            _this.rotationDelta_ = 0.0;
            /**
             * @private
             * @type {number}
             */
            _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
            /**
             * @private
             * @type {number}
             */
            _this.duration_ = options.duration !== undefined ? options.duration : 250;
            return _this;
        }
        /**
         * Handle pointer drag events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         */
        PinchRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
            var rotationDelta = 0.0;
            var touch0 = this.targetPointers[0];
            var touch1 = this.targetPointers[1];
            // angle between touches
            var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
            if (this.lastAngle_ !== undefined) {
                var delta = angle - this.lastAngle_;
                this.rotationDelta_ += delta;
                if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
                    this.rotating_ = true;
                }
                rotationDelta = delta;
            }
            this.lastAngle_ = angle;
            var map = mapBrowserEvent.map;
            var view = map.getView();
            if (view.getConstraints().rotation === disable) {
                return;
            }
            // rotate anchor point.
            // FIXME: should be the intersection point between the lines:
            //     touch0,touch1 and previousTouch0,previousTouch1
            var viewportPosition = map.getViewport().getBoundingClientRect();
            var centroid$1 = centroid(this.targetPointers);
            centroid$1[0] -= viewportPosition.left;
            centroid$1[1] -= viewportPosition.top;
            this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1);
            // rotate
            if (this.rotating_) {
                map.render();
                view.adjustRotationInternal(rotationDelta, this.anchor_);
            }
        };
        /**
         * Handle pointer up events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @return {boolean} If the event was consumed.
         */
        PinchRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
            if (this.targetPointers.length < 2) {
                var map = mapBrowserEvent.map;
                var view = map.getView();
                view.endInteraction(this.duration_);
                return false;
            }
            else {
                return true;
            }
        };
        /**
         * Handle pointer down events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @return {boolean} If the event was consumed.
         */
        PinchRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
            if (this.targetPointers.length >= 2) {
                var map = mapBrowserEvent.map;
                this.anchor_ = null;
                this.lastAngle_ = undefined;
                this.rotating_ = false;
                this.rotationDelta_ = 0.0;
                if (!this.handlingDownUpSequence) {
                    map.getView().beginInteraction();
                }
                return true;
            }
            else {
                return false;
            }
        };
        return PinchRotate;
    }(PointerInteraction));

    var __extends$b = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {number} [duration=400] Animation duration in milliseconds.
     */
    /**
     * @classdesc
     * Allows the user to zoom the map by pinching with two fingers
     * on a touch screen.
     * @api
     */
    var PinchZoom = /** @class */ (function (_super) {
        __extends$b(PinchZoom, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function PinchZoom(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
            if (!pointerOptions.stopDown) {
                pointerOptions.stopDown = FALSE;
            }
            _this = _super.call(this, pointerOptions) || this;
            /**
             * @private
             * @type {import("../coordinate.js").Coordinate}
             */
            _this.anchor_ = null;
            /**
             * @private
             * @type {number}
             */
            _this.duration_ = options.duration !== undefined ? options.duration : 400;
            /**
             * @private
             * @type {number|undefined}
             */
            _this.lastDistance_ = undefined;
            /**
             * @private
             * @type {number}
             */
            _this.lastScaleDelta_ = 1;
            return _this;
        }
        /**
         * Handle pointer drag events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         */
        PinchZoom.prototype.handleDragEvent = function (mapBrowserEvent) {
            var scaleDelta = 1.0;
            var touch0 = this.targetPointers[0];
            var touch1 = this.targetPointers[1];
            var dx = touch0.clientX - touch1.clientX;
            var dy = touch0.clientY - touch1.clientY;
            // distance between touches
            var distance = Math.sqrt(dx * dx + dy * dy);
            if (this.lastDistance_ !== undefined) {
                scaleDelta = this.lastDistance_ / distance;
            }
            this.lastDistance_ = distance;
            var map = mapBrowserEvent.map;
            var view = map.getView();
            if (scaleDelta != 1.0) {
                this.lastScaleDelta_ = scaleDelta;
            }
            // scale anchor point.
            var viewportPosition = map.getViewport().getBoundingClientRect();
            var centroid$1 = centroid(this.targetPointers);
            centroid$1[0] -= viewportPosition.left;
            centroid$1[1] -= viewportPosition.top;
            this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1);
            // scale, bypass the resolution constraint
            map.render();
            view.adjustResolutionInternal(scaleDelta, this.anchor_);
        };
        /**
         * Handle pointer up events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @return {boolean} If the event was consumed.
         */
        PinchZoom.prototype.handleUpEvent = function (mapBrowserEvent) {
            if (this.targetPointers.length < 2) {
                var map = mapBrowserEvent.map;
                var view = map.getView();
                var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
                view.endInteraction(this.duration_, direction);
                return false;
            }
            else {
                return true;
            }
        };
        /**
         * Handle pointer down events.
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
         * @return {boolean} If the event was consumed.
         */
        PinchZoom.prototype.handleDownEvent = function (mapBrowserEvent) {
            if (this.targetPointers.length >= 2) {
                var map = mapBrowserEvent.map;
                this.anchor_ = null;
                this.lastDistance_ = undefined;
                this.lastScaleDelta_ = 1;
                if (!this.handlingDownUpSequence) {
                    map.getView().beginInteraction();
                }
                return true;
            }
            else {
                return false;
            }
        };
        return PinchZoom;
    }(PointerInteraction));

    /**
     * @module ol/interaction
     */
    /**
     * @typedef {Object} DefaultsOptions
     * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
     * desired.
     * @property {boolean} [onFocusOnly=false] Interact only when the map has the
     * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
     * useful when page scroll is desired for maps that do not have the browser's
     * focus.
     * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
     * desired.
     * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
     * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
     * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
     * @property {boolean} [dragPan=true] Whether drag pan is desired.
     * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
     * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
     * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
     * @property {number} [zoomDuration] Duration of the zoom animation in
     * milliseconds.
     */
    /**
     * Set of interactions included in maps by default. Specific interactions can be
     * excluded by setting the appropriate option to false in the constructor
     * options, but the order of the interactions is fixed.  If you want to specify
     * a different order for interactions, you will need to create your own
     * {@link module:ol/interaction/Interaction} instances and insert
     * them into a {@link module:ol/Collection} in the order you want
     * before creating your {@link module:ol/Map~Map} instance. Changing the order can
     * be of interest if the event propagation needs to be stopped at a point.
     * The default set of interactions, in sequence, is:
     * * {@link module:ol/interaction/DragRotate~DragRotate}
     * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
     * * {@link module:ol/interaction/DragPan~DragPan}
     * * {@link module:ol/interaction/PinchRotate~PinchRotate}
     * * {@link module:ol/interaction/PinchZoom~PinchZoom}
     * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
     * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
     * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
     * * {@link module:ol/interaction/DragZoom~DragZoom}
     *
     * @param {DefaultsOptions=} opt_options Defaults options.
     * @return {import("./Collection.js").default<import("./interaction/Interaction.js").default>}
     * A collection of interactions to be used with the {@link module:ol/Map~Map}
     * constructor's `interactions` option.
     * @api
     */
    function defaults$1(opt_options) {
        var options = opt_options ? opt_options : {};
        var interactions = new Collection();
        var kinetic = new Kinetic(-0.005, 0.05, 100);
        var altShiftDragRotate = options.altShiftDragRotate !== undefined
            ? options.altShiftDragRotate
            : true;
        if (altShiftDragRotate) {
            interactions.push(new DragRotate());
        }
        var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
        if (doubleClickZoom) {
            interactions.push(new DoubleClickZoom({
                delta: options.zoomDelta,
                duration: options.zoomDuration,
            }));
        }
        var dragPan = options.dragPan !== undefined ? options.dragPan : true;
        if (dragPan) {
            interactions.push(new DragPan({
                onFocusOnly: options.onFocusOnly,
                kinetic: kinetic,
            }));
        }
        var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;
        if (pinchRotate) {
            interactions.push(new PinchRotate());
        }
        var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
        if (pinchZoom) {
            interactions.push(new PinchZoom({
                duration: options.zoomDuration,
            }));
        }
        var keyboard = options.keyboard !== undefined ? options.keyboard : true;
        if (keyboard) {
            interactions.push(new KeyboardPan());
            interactions.push(new KeyboardZoom({
                delta: options.zoomDelta,
                duration: options.zoomDuration,
            }));
        }
        var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
        if (mouseWheelZoom) {
            interactions.push(new MouseWheelZoom({
                onFocusOnly: options.onFocusOnly,
                duration: options.zoomDuration,
            }));
        }
        var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
        if (shiftDragZoom) {
            interactions.push(new DragZoom({
                duration: options.zoomDuration,
            }));
        }
        return interactions;
    }

    var __extends$a = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * The map is the core component of OpenLayers. For a map to render, a view,
     * one or more layers, and a target container are needed:
     *
     *     import Map from 'ol/Map';
     *     import View from 'ol/View';
     *     import TileLayer from 'ol/layer/Tile';
     *     import OSM from 'ol/source/OSM';
     *
     *     var map = new Map({
     *       view: new View({
     *         center: [0, 0],
     *         zoom: 1
     *       }),
     *       layers: [
     *         new TileLayer({
     *           source: new OSM()
     *         })
     *       ],
     *       target: 'map'
     *     });
     *
     * The above snippet creates a map using a {@link module:ol/layer/Tile} to
     * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
     * element with the id `map`.
     *
     * The constructor places a viewport container (with CSS class name
     * `ol-viewport`) in the target element (see `getViewport()`), and then two
     * further elements within the viewport: one with CSS class name
     * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
     * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
     * option of {@link module:ol/Overlay~Overlay} for the difference). The map
     * itself is placed in a further element within the viewport.
     *
     * Layers are stored as a {@link module:ol/Collection~Collection} in
     * layerGroups. A top-level group is provided by the library. This is what is
     * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
     * options are added to this group, and `addLayer` and `removeLayer` change the
     * layer collection in the group. `getLayers` is a convenience function for
     * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~Group}
     * is a subclass of {@link module:ol/layer/Base}, so layers entered in the
     * options or added with `addLayer` can be groups, which can contain further
     * groups, and so on.
     *
     * @api
     */
    var Map$1 = /** @class */ (function (_super) {
        __extends$a(Map, _super);
        /**
         * @param {import("./PluggableMap.js").MapOptions} options Map options.
         */
        function Map(options) {
            var _this = this;
            options = assign({}, options);
            if (!options.controls) {
                options.controls = defaults$2();
            }
            if (!options.interactions) {
                options.interactions = defaults$1({
                    onFocusOnly: true,
                });
            }
            _this = _super.call(this, options) || this;
            return _this;
        }
        Map.prototype.createRenderer = function () {
            return new CompositeMapRenderer(this);
        };
        return Map;
    }(PluggableMap));

    var __extends$9 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
     * @property {number} [opacity=1] Opacity (0, 1).
     * @property {boolean} [visible=true] Visibility.
     * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
     * visible.
     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
     * be visible.
     * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
     * means no preloading.
     * @property {import("../source/Tile.js").default} [source] Source for this layer.
     * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
     * this layer in its layers collection, and the layer will be rendered on top. This is useful for
     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
     * use {@link module:ol/Map#addLayer}.
     * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
     */
    /**
     * @classdesc
     * For layer sources that provide pre-rendered, tiled images in grids that are
     * organized by zoom levels for specific resolutions.
     * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
     * property on the layer object; for example, setting `title: 'My Title'` in the
     * options means that `title` is observable, and has get/set accessors.
     *
     * @extends {Layer<import("../source/Tile.js").default>}
     * @api
     */
    var BaseTileLayer = /** @class */ (function (_super) {
        __extends$9(BaseTileLayer, _super);
        /**
         * @param {Options=} opt_options Tile layer options.
         */
        function BaseTileLayer(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var baseOptions = assign({}, options);
            delete baseOptions.preload;
            delete baseOptions.useInterimTilesOnError;
            _this = _super.call(this, baseOptions) || this;
            _this.setPreload(options.preload !== undefined ? options.preload : 0);
            _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined
                ? options.useInterimTilesOnError
                : true);
            return _this;
        }
        /**
         * Return the level as number to which we will preload tiles up to.
         * @return {number} The level to preload tiles up to.
         * @observable
         * @api
         */
        BaseTileLayer.prototype.getPreload = function () {
            return /** @type {number} */ (this.get(TileProperty.PRELOAD));
        };
        /**
         * Set the level as number to which we will preload tiles up to.
         * @param {number} preload The level to preload tiles up to.
         * @observable
         * @api
         */
        BaseTileLayer.prototype.setPreload = function (preload) {
            this.set(TileProperty.PRELOAD, preload);
        };
        /**
         * Whether we use interim tiles on error.
         * @return {boolean} Use interim tiles on error.
         * @observable
         * @api
         */
        BaseTileLayer.prototype.getUseInterimTilesOnError = function () {
            return /** @type {boolean} */ (this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR));
        };
        /**
         * Set whether we use interim tiles on error.
         * @param {boolean} useInterimTilesOnError Use interim tiles on error.
         * @observable
         * @api
         */
        BaseTileLayer.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
            this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
        };
        return BaseTileLayer;
    }(Layer));

    var __extends$8 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * For layer sources that provide pre-rendered, tiled images in grids that are
     * organized by zoom levels for specific resolutions.
     * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
     * property on the layer object; for example, setting `title: 'My Title'` in the
     * options means that `title` is observable, and has get/set accessors.
     *
     * @api
     */
    var TileLayer = /** @class */ (function (_super) {
        __extends$8(TileLayer, _super);
        /**
         * @param {import("./BaseTile.js").Options=} opt_options Tile layer options.
         */
        function TileLayer(opt_options) {
            return _super.call(this, opt_options) || this;
        }
        /**
         * Create a renderer for this layer.
         * @return {import("../renderer/Layer.js").default} A layer renderer.
         * @protected
         */
        TileLayer.prototype.createRenderer = function () {
            return new CanvasTileLayerRenderer(this);
        };
        return TileLayer;
    }(BaseTileLayer));

    var __extends$7 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ImageTile = /** @class */ (function (_super) {
        __extends$7(ImageTile, _super);
        /**
         * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @param {import("./TileState.js").default} state State.
         * @param {string} src Image source URI.
         * @param {?string} crossOrigin Cross origin.
         * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
         * @param {import("./Tile.js").Options=} opt_options Tile options.
         */
        function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
            var _this = _super.call(this, tileCoord, state, opt_options) || this;
            /**
             * @private
             * @type {?string}
             */
            _this.crossOrigin_ = crossOrigin;
            /**
             * Image URI
             *
             * @private
             * @type {string}
             */
            _this.src_ = src;
            _this.key = src;
            /**
             * @private
             * @type {HTMLImageElement|HTMLCanvasElement}
             */
            _this.image_ = new Image();
            if (crossOrigin !== null) {
                _this.image_.crossOrigin = crossOrigin;
            }
            /**
             * @private
             * @type {?function():void}
             */
            _this.unlisten_ = null;
            /**
             * @private
             * @type {import("./Tile.js").LoadFunction}
             */
            _this.tileLoadFunction_ = tileLoadFunction;
            return _this;
        }
        /**
         * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
         * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
         * @api
         */
        ImageTile.prototype.getImage = function () {
            return this.image_;
        };
        /**
         * Tracks loading or read errors.
         *
         * @private
         */
        ImageTile.prototype.handleImageError_ = function () {
            this.state = TileState.ERROR;
            this.unlistenImage_();
            this.image_ = getBlankImage();
            this.changed();
        };
        /**
         * Tracks successful image load.
         *
         * @private
         */
        ImageTile.prototype.handleImageLoad_ = function () {
            var image = /** @type {HTMLImageElement} */ (this.image_);
            if (image.naturalWidth && image.naturalHeight) {
                this.state = TileState.LOADED;
            }
            else {
                this.state = TileState.EMPTY;
            }
            this.unlistenImage_();
            this.changed();
        };
        /**
         * Load not yet loaded URI.
         * @api
         */
        ImageTile.prototype.load = function () {
            if (this.state == TileState.ERROR) {
                this.state = TileState.IDLE;
                this.image_ = new Image();
                if (this.crossOrigin_ !== null) {
                    this.image_.crossOrigin = this.crossOrigin_;
                }
            }
            if (this.state == TileState.IDLE) {
                this.state = TileState.LOADING;
                this.changed();
                this.tileLoadFunction_(this, this.src_);
                this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
            }
        };
        /**
         * Discards event handlers which listen for load completion or errors.
         *
         * @private
         */
        ImageTile.prototype.unlistenImage_ = function () {
            if (this.unlisten_) {
                this.unlisten_();
                this.unlisten_ = null;
            }
        };
        return ImageTile;
    }(Tile));
    /**
     * Get a 1-pixel blank image.
     * @return {HTMLCanvasElement} Blank image.
     */
    function getBlankImage() {
        var ctx = createCanvasContext2D(1, 1);
        ctx.fillStyle = 'rgba(0,0,0,0)';
        ctx.fillRect(0, 0, 1, 1);
        return ctx.canvas;
    }

    /**
     * @module ol/reproj/Triangulation
     */
    /**
     * Single triangle; consists of 3 source points and 3 target points.
     * @typedef {Object} Triangle
     * @property {Array<import("../coordinate.js").Coordinate>} source
     * @property {Array<import("../coordinate.js").Coordinate>} target
     */
    /**
     * Maximum number of subdivision steps during raster reprojection triangulation.
     * Prevents high memory usage and large number of proj4 calls (for certain
     * transformations and areas). At most `2*(2^this)` triangles are created for
     * each triangulated extent (tile/image).
     * @type {number}
     */
    var MAX_SUBDIVISION = 10;
    /**
     * Maximum allowed size of triangle relative to world width. When transforming
     * corners of world extent between certain projections, the resulting
     * triangulation seems to have zero error and no subdivision is performed. If
     * the triangle width is more than this (relative to world width; 0-1),
     * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
     * @type {number}
     */
    var MAX_TRIANGLE_WIDTH = 0.25;
    /**
     * @classdesc
     * Class containing triangulation of the given target extent.
     * Used for determining source data and the reprojection itself.
     */
    var Triangulation = /** @class */ (function () {
        /**
         * @param {import("../proj/Projection.js").default} sourceProj Source projection.
         * @param {import("../proj/Projection.js").default} targetProj Target projection.
         * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
         * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
         * @param {number} errorThreshold Acceptable error (in source units).
         * @param {?number} opt_destinationResolution The (optional) resolution of the destination.
         */
        function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {
            /**
             * @type {import("../proj/Projection.js").default}
             * @private
             */
            this.sourceProj_ = sourceProj;
            /**
             * @type {import("../proj/Projection.js").default}
             * @private
             */
            this.targetProj_ = targetProj;
            /** @type {!Object<string, import("../coordinate.js").Coordinate>} */
            var transformInvCache = {};
            var transformInv = getTransform(this.targetProj_, this.sourceProj_);
            /**
             * @param {import("../coordinate.js").Coordinate} c A coordinate.
             * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
             * @private
             */
            this.transformInv_ = function (c) {
                var key = c[0] + '/' + c[1];
                if (!transformInvCache[key]) {
                    transformInvCache[key] = transformInv(c);
                }
                return transformInvCache[key];
            };
            /**
             * @type {import("../extent.js").Extent}
             * @private
             */
            this.maxSourceExtent_ = maxSourceExtent;
            /**
             * @type {number}
             * @private
             */
            this.errorThresholdSquared_ = errorThreshold * errorThreshold;
            /**
             * @type {Array<Triangle>}
             * @private
             */
            this.triangles_ = [];
            /**
             * Indicates that the triangulation crosses edge of the source projection.
             * @type {boolean}
             * @private
             */
            this.wrapsXInSource_ = false;
            /**
             * @type {boolean}
             * @private
             */
            this.canWrapXInSource_ =
                this.sourceProj_.canWrapX() &&
                    !!maxSourceExtent &&
                    !!this.sourceProj_.getExtent() &&
                    getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());
            /**
             * @type {?number}
             * @private
             */
            this.sourceWorldWidth_ = this.sourceProj_.getExtent()
                ? getWidth(this.sourceProj_.getExtent())
                : null;
            /**
             * @type {?number}
             * @private
             */
            this.targetWorldWidth_ = this.targetProj_.getExtent()
                ? getWidth(this.targetProj_.getExtent())
                : null;
            var destinationTopLeft = getTopLeft(targetExtent);
            var destinationTopRight = getTopRight(targetExtent);
            var destinationBottomRight = getBottomRight(targetExtent);
            var destinationBottomLeft = getBottomLeft(targetExtent);
            var sourceTopLeft = this.transformInv_(destinationTopLeft);
            var sourceTopRight = this.transformInv_(destinationTopRight);
            var sourceBottomRight = this.transformInv_(destinationBottomRight);
            var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
            /*
             * The maxSubdivision controls how many splittings of the target area can
             * be done. The idea here is to do a linear mapping of the target areas
             * but the actual overal reprojection (can be) extremely non-linear. The
             * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
             * tile size. However this function is also called to remap canvas rendered
             * layers which can be much larger. This calculation increases the maxSubdivision
             * value by the right factor so that each 256x256 pixel area has
             * MAX_SUBDIVISION divisions.
             */
            var maxSubdivision = MAX_SUBDIVISION +
                (opt_destinationResolution
                    ? Math.max(0, Math.ceil(log2(getArea(targetExtent) /
                        (opt_destinationResolution *
                            opt_destinationResolution *
                            256 *
                            256))))
                    : 0);
            this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);
            if (this.wrapsXInSource_) {
                var leftBound_1 = Infinity;
                this.triangles_.forEach(function (triangle, i, arr) {
                    leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
                });
                // Shift triangles to be as close to `leftBound` as possible
                // (if the distance is more than `worldWidth / 2` it can be closer.
                this.triangles_.forEach(function (triangle) {
                    if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) -
                        leftBound_1 >
                        this.sourceWorldWidth_ / 2) {
                        var newTriangle = [
                            [triangle.source[0][0], triangle.source[0][1]],
                            [triangle.source[1][0], triangle.source[1][1]],
                            [triangle.source[2][0], triangle.source[2][1]],
                        ];
                        if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                            newTriangle[0][0] -= this.sourceWorldWidth_;
                        }
                        if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                            newTriangle[1][0] -= this.sourceWorldWidth_;
                        }
                        if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                            newTriangle[2][0] -= this.sourceWorldWidth_;
                        }
                        // Rarely (if the extent contains both the dateline and prime meridian)
                        // the shift can in turn break some triangles.
                        // Detect this here and don't shift in such cases.
                        var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                        var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                        if (maxX - minX < this.sourceWorldWidth_ / 2) {
                            triangle.source = newTriangle;
                        }
                    }
                }.bind(this));
            }
            transformInvCache = {};
        }
        /**
         * Adds triangle to the triangulation.
         * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
         * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
         * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
         * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
         * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
         * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
         * @private
         */
        Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {
            this.triangles_.push({
                source: [aSrc, bSrc, cSrc],
                target: [a, b, c],
            });
        };
        /**
         * Adds quad (points in clock-wise order) to the triangulation
         * (and reprojects the vertices) if valid.
         * Performs quad subdivision if needed to increase precision.
         *
         * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
         * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
         * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
         * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
         * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
         * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
         * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
         * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
         * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
         * @private
         */
        Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
            var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
            var sourceCoverageX = this.sourceWorldWidth_
                ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_
                : null;
            var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);
            // when the quad is wrapped in the source projection
            // it covers most of the projection extent, but not fully
            var wrapsX = this.sourceProj_.canWrapX() &&
                sourceCoverageX > 0.5 &&
                sourceCoverageX < 1;
            var needsSubdivision = false;
            if (maxSubdivision > 0) {
                if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
                    var targetQuadExtent = boundingExtent([a, b, c, d]);
                    var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
                    needsSubdivision =
                        targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
                }
                if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
                    needsSubdivision =
                        sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
                }
            }
            if (!needsSubdivision && this.maxSourceExtent_) {
                if (isFinite(sourceQuadExtent[0]) &&
                    isFinite(sourceQuadExtent[1]) &&
                    isFinite(sourceQuadExtent[2]) &&
                    isFinite(sourceQuadExtent[3])) {
                    if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {
                        // whole quad outside source projection extent -> ignore
                        return;
                    }
                }
            }
            var isNotFinite = 0;
            if (!needsSubdivision) {
                if (!isFinite(aSrc[0]) ||
                    !isFinite(aSrc[1]) ||
                    !isFinite(bSrc[0]) ||
                    !isFinite(bSrc[1]) ||
                    !isFinite(cSrc[0]) ||
                    !isFinite(cSrc[1]) ||
                    !isFinite(dSrc[0]) ||
                    !isFinite(dSrc[1])) {
                    if (maxSubdivision > 0) {
                        needsSubdivision = true;
                    }
                    else {
                        // It might be the case that only 1 of the points is infinite. In this case
                        // we can draw a single triangle with the other three points
                        isNotFinite =
                            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +
                                (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +
                                (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +
                                (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
                        if (isNotFinite != 1 &&
                            isNotFinite != 2 &&
                            isNotFinite != 4 &&
                            isNotFinite != 8) {
                            return;
                        }
                    }
                }
            }
            if (maxSubdivision > 0) {
                if (!needsSubdivision) {
                    var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
                    var centerSrc = this.transformInv_(center);
                    var dx = void 0;
                    if (wrapsX) {
                        var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) +
                            modulo(cSrc[0], sourceWorldWidth)) /
                            2;
                        dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
                    }
                    else {
                        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
                    }
                    var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
                    var centerSrcErrorSquared = dx * dx + dy * dy;
                    needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
                }
                if (needsSubdivision) {
                    if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
                        // split horizontally (top & bottom)
                        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
                        var bcSrc = this.transformInv_(bc);
                        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
                        var daSrc = this.transformInv_(da);
                        this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
                        this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
                    }
                    else {
                        // split vertically (left & right)
                        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
                        var abSrc = this.transformInv_(ab);
                        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
                        var cdSrc = this.transformInv_(cd);
                        this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
                        this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
                    }
                    return;
                }
            }
            if (wrapsX) {
                if (!this.canWrapXInSource_) {
                    return;
                }
                this.wrapsXInSource_ = true;
            }
            // Exactly zero or one of *Src is not finite
            // The triangles must have the diagonal line as the first side
            // This is to allow easy code in reproj.s to make it straight for broken
            // browsers that can't handle diagonal clipping
            if ((isNotFinite & 0xb) == 0) {
                this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
            }
            if ((isNotFinite & 0xe) == 0) {
                this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
            }
            if (isNotFinite) {
                // Try the other two triangles
                if ((isNotFinite & 0xd) == 0) {
                    this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
                }
                if ((isNotFinite & 0x7) == 0) {
                    this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
                }
            }
        };
        /**
         * Calculates extent of the 'source' coordinates from all the triangles.
         *
         * @return {import("../extent.js").Extent} Calculated extent.
         */
        Triangulation.prototype.calculateSourceExtent = function () {
            var extent = createEmpty();
            this.triangles_.forEach(function (triangle, i, arr) {
                var src = triangle.source;
                extendCoordinate(extent, src[0]);
                extendCoordinate(extent, src[1]);
                extendCoordinate(extent, src[2]);
            });
            return extent;
        };
        /**
         * @return {Array<Triangle>} Array of the calculated triangles.
         */
        Triangulation.prototype.getTriangles = function () {
            return this.triangles_;
        };
        return Triangulation;
    }());

    /**
     * @module ol/source/common
     */
    /**
     * Context options to disable image smoothing.
     * @type {Object}
     */
    var IMAGE_SMOOTHING_DISABLED = {
        imageSmoothingEnabled: false,
        msImageSmoothingEnabled: false,
    };

    /**
     * @module ol/reproj
     */
    var brokenDiagonalRendering_;
    /**
     * This draws a small triangle into a canvas by setting the triangle as the clip region
     * and then drawing a (too large) rectangle
     *
     * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
     * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
     * @param {number} v1 The y-coordinate of the second point.
     * @param {number} u2 The x-coordinate of the third point.
     * @param {number} v2 The y-coordinate of the third point.
     */
    function drawTestTriangle(ctx, u1, v1, u2, v2) {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(u1, v1);
        ctx.lineTo(u2, v2);
        ctx.closePath();
        ctx.save();
        ctx.clip();
        ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
        ctx.restore();
    }
    /**
     * Given the data from getImageData, see if the right values appear at the provided offset.
     * Returns true if either the color or transparency is off
     *
     * @param {Uint8ClampedArray} data The data returned from getImageData
     * @param {number} offset The pixel offset from the start of data.
     * @return {boolean} true if the diagonal rendering is broken
     */
    function verifyBrokenDiagonalRendering(data, offset) {
        // the values ought to be close to the rgba(210, 0, 0, 0.75)
        return (Math.abs(data[offset * 4] - 210) > 2 ||
            Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2);
    }
    /**
     * Determines if the current browser configuration can render triangular clip regions correctly.
     * This value is cached so the function is only expensive the first time called.
     * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
     * IE also doesn't. Chrome works, and everything seems to work on OSX and Android. This function caches the
     * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
     * running, but lets hope not.
     *
     * @return {boolean} true if the Diagonal Rendering is broken.
     */
    function isBrokenDiagonalRendering() {
        if (brokenDiagonalRendering_ === undefined) {
            var ctx = document.createElement('canvas').getContext('2d');
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';
            drawTestTriangle(ctx, 4, 5, 4, 0);
            drawTestTriangle(ctx, 4, 5, 0, 5);
            var data = ctx.getImageData(0, 0, 3, 3).data;
            brokenDiagonalRendering_ =
                verifyBrokenDiagonalRendering(data, 0) ||
                    verifyBrokenDiagonalRendering(data, 4) ||
                    verifyBrokenDiagonalRendering(data, 8);
        }
        return brokenDiagonalRendering_;
    }
    /**
     * Calculates ideal resolution to use from the source in order to achieve
     * pixel mapping as close as possible to 1:1 during reprojection.
     * The resolution is calculated regardless of what resolutions
     * are actually available in the dataset (TileGrid, Image, ...).
     *
     * @param {import("./proj/Projection.js").default} sourceProj Source projection.
     * @param {import("./proj/Projection.js").default} targetProj Target projection.
     * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
     * @param {number} targetResolution Target resolution.
     * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
     */
    function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
        var sourceCenter = transform(targetCenter, targetProj, sourceProj);
        // calculate the ideal resolution of the source data
        var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);
        var targetMetersPerUnit = targetProj.getMetersPerUnit();
        if (targetMetersPerUnit !== undefined) {
            sourceResolution *= targetMetersPerUnit;
        }
        var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
        if (sourceMetersPerUnit !== undefined) {
            sourceResolution /= sourceMetersPerUnit;
        }
        // Based on the projection properties, the point resolution at the specified
        // coordinates may be slightly different. We need to reverse-compensate this
        // in order to achieve optimal results.
        var sourceExtent = sourceProj.getExtent();
        if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
            var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) /
                sourceResolution;
            if (isFinite(compensationFactor) && compensationFactor > 0) {
                sourceResolution /= compensationFactor;
            }
        }
        return sourceResolution;
    }
    /**
     * Calculates ideal resolution to use from the source in order to achieve
     * pixel mapping as close as possible to 1:1 during reprojection.
     * The resolution is calculated regardless of what resolutions
     * are actually available in the dataset (TileGrid, Image, ...).
     *
     * @param {import("./proj/Projection.js").default} sourceProj Source projection.
     * @param {import("./proj/Projection.js").default} targetProj Target projection.
     * @param {import("./extent.js").Extent} targetExtent Target extent
     * @param {number} targetResolution Target resolution.
     * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
     */
    function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
        var targetCenter = getCenter(targetExtent);
        var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
        if (!isFinite(sourceResolution) || sourceResolution <= 0) {
            forEachCorner(targetExtent, function (corner) {
                sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
                return isFinite(sourceResolution) && sourceResolution > 0;
            });
        }
        return sourceResolution;
    }
    /**
     * Renders the source data into new canvas based on the triangulation.
     *
     * @param {number} width Width of the canvas.
     * @param {number} height Height of the canvas.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} sourceResolution Source resolution.
     * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
     * @param {number} targetResolution Target resolution.
     * @param {import("./extent.js").Extent} targetExtent Target extent.
     * @param {import("./reproj/Triangulation.js").default} triangulation
     * Calculated triangulation.
     * @param {Array<{extent: import("./extent.js").Extent,
     *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources
     * Array of sources.
     * @param {number} gutter Gutter of the sources.
     * @param {boolean=} opt_renderEdges Render reprojection edges.
     * @param {object=} opt_contextOptions Properties to set on the canvas context.
     * @return {HTMLCanvasElement} Canvas with reprojected data.
     */
    function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_contextOptions) {
        var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));
        assign(context, opt_contextOptions);
        if (sources.length === 0) {
            return context.canvas;
        }
        context.scale(pixelRatio, pixelRatio);
        function pixelRound(value) {
            return Math.round(value * pixelRatio) / pixelRatio;
        }
        context.globalCompositeOperation = 'lighter';
        var sourceDataExtent = createEmpty();
        sources.forEach(function (src, i, arr) {
            extend$1(sourceDataExtent, src.extent);
        });
        var canvasWidthInUnits = getWidth(sourceDataExtent);
        var canvasHeightInUnits = getHeight(sourceDataExtent);
        var stitchContext = createCanvasContext2D(Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution), Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution));
        assign(stitchContext, opt_contextOptions);
        var stitchScale = pixelRatio / sourceResolution;
        sources.forEach(function (src, i, arr) {
            var xPos = src.extent[0] - sourceDataExtent[0];
            var yPos = -(src.extent[3] - sourceDataExtent[3]);
            var srcWidth = getWidth(src.extent);
            var srcHeight = getHeight(src.extent);
            // This test should never fail -- but it does. Need to find a fix the upstream condition
            if (src.image.width > 0 && src.image.height > 0) {
                stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
            }
        });
        var targetTopLeft = getTopLeft(targetExtent);
        triangulation.getTriangles().forEach(function (triangle, i, arr) {
            /* Calculate affine transform (src -> dst)
             * Resulting matrix can be used to transform coordinate
             * from `sourceProjection` to destination pixels.
             *
             * To optimize number of context calls and increase numerical stability,
             * we also do the following operations:
             * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
             * here before solving the linear system so [ui, vi] are pixel coordinates.
             *
             * Src points: xi, yi
             * Dst points: ui, vi
             * Affine coefficients: aij
             *
             * | x0 y0 1  0  0 0 |   |a00|   |u0|
             * | x1 y1 1  0  0 0 |   |a01|   |u1|
             * | x2 y2 1  0  0 0 | x |a02| = |u2|
             * |  0  0 0 x0 y0 1 |   |a10|   |v0|
             * |  0  0 0 x1 y1 1 |   |a11|   |v1|
             * |  0  0 0 x2 y2 1 |   |a12|   |v2|
             */
            var source = triangle.source;
            var target = triangle.target;
            var x0 = source[0][0], y0 = source[0][1];
            var x1 = source[1][0], y1 = source[1][1];
            var x2 = source[2][0], y2 = source[2][1];
            // Make sure that everything is on pixel boundaries
            var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
            var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
            var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
            var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
            var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
            var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);
            // Shift all the source points to improve numerical stability
            // of all the subsequent calculations. The [x0, y0] is used here.
            // This is also used to simplify the linear system.
            var sourceNumericalShiftX = x0;
            var sourceNumericalShiftY = y0;
            x0 = 0;
            y0 = 0;
            x1 -= sourceNumericalShiftX;
            y1 -= sourceNumericalShiftY;
            x2 -= sourceNumericalShiftX;
            y2 -= sourceNumericalShiftY;
            var augmentedMatrix = [
                [x1, y1, 0, 0, u1 - u0],
                [x2, y2, 0, 0, u2 - u0],
                [0, 0, x1, y1, v1 - v0],
                [0, 0, x2, y2, v2 - v0],
            ];
            var affineCoefs = solveLinearSystem(augmentedMatrix);
            if (!affineCoefs) {
                return;
            }
            context.save();
            context.beginPath();
            if (isBrokenDiagonalRendering() ||
                opt_contextOptions === IMAGE_SMOOTHING_DISABLED) {
                // Make sure that all lines are horizontal or vertical
                context.moveTo(u1, v1);
                // This is the diagonal line. Do it in 4 steps
                var steps = 4;
                var ud = u0 - u1;
                var vd = v0 - v1;
                for (var step = 0; step < steps; step++) {
                    // Go horizontally
                    context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound((step * vd) / (steps - 1)));
                    // Go vertically
                    if (step != steps - 1) {
                        context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound(((step + 1) * vd) / (steps - 1)));
                    }
                }
                // We are almost at u0r, v0r
                context.lineTo(u2, v2);
            }
            else {
                context.moveTo(u1, v1);
                context.lineTo(u0, v0);
                context.lineTo(u2, v2);
            }
            context.clip();
            context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
            context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
            context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
            context.drawImage(stitchContext.canvas, 0, 0);
            context.restore();
        });
        if (opt_renderEdges) {
            context.save();
            context.globalCompositeOperation = 'source-over';
            context.strokeStyle = 'black';
            context.lineWidth = 1;
            triangulation.getTriangles().forEach(function (triangle, i, arr) {
                var target = triangle.target;
                var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
                var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
                var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
                var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
                var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
                var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
                context.beginPath();
                context.moveTo(u1, v1);
                context.lineTo(u0, v0);
                context.lineTo(u2, v2);
                context.closePath();
                context.stroke();
            });
            context.restore();
        }
        return context.canvas;
    }

    var __extends$6 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType
     */
    /**
     * @classdesc
     * Class encapsulating single reprojected tile.
     * See {@link module:ol/source/TileImage~TileImage}.
     *
     */
    var ReprojTile = /** @class */ (function (_super) {
        __extends$6(ReprojTile, _super);
        /**
         * @param {import("../proj/Projection.js").default} sourceProj Source projection.
         * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
         * @param {import("../proj/Projection.js").default} targetProj Target projection.
         * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
         * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
         * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
         * @param {number} pixelRatio Pixel ratio.
         * @param {number} gutter Gutter of the source tiles.
         * @param {FunctionType} getTileFunction
         *     Function returning source tiles (z, x, y, pixelRatio).
         * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).
         * @param {boolean=} opt_renderEdges Render reprojection edges.
         * @param {object=} opt_contextOptions Properties to set on the canvas context.
         */
        function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_contextOptions) {
            var _this = _super.call(this, tileCoord, TileState.IDLE) || this;
            /**
             * @private
             * @type {boolean}
             */
            _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;
            /**
             * @private
             * @type {object}
             */
            _this.contextOptions_ = opt_contextOptions;
            /**
             * @private
             * @type {number}
             */
            _this.pixelRatio_ = pixelRatio;
            /**
             * @private
             * @type {number}
             */
            _this.gutter_ = gutter;
            /**
             * @private
             * @type {HTMLCanvasElement}
             */
            _this.canvas_ = null;
            /**
             * @private
             * @type {import("../tilegrid/TileGrid.js").default}
             */
            _this.sourceTileGrid_ = sourceTileGrid;
            /**
             * @private
             * @type {import("../tilegrid/TileGrid.js").default}
             */
            _this.targetTileGrid_ = targetTileGrid;
            /**
             * @private
             * @type {import("../tilecoord.js").TileCoord}
             */
            _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
            /**
             * @private
             * @type {!Array<import("../Tile.js").default>}
             */
            _this.sourceTiles_ = [];
            /**
             * @private
             * @type {?Array<import("../events.js").EventsKey>}
             */
            _this.sourcesListenerKeys_ = null;
            /**
             * @private
             * @type {number}
             */
            _this.sourceZ_ = 0;
            var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);
            var maxTargetExtent = _this.targetTileGrid_.getExtent();
            var maxSourceExtent = _this.sourceTileGrid_.getExtent();
            var limitedTargetExtent = maxTargetExtent
                ? getIntersection(targetExtent, maxTargetExtent)
                : targetExtent;
            if (getArea(limitedTargetExtent) === 0) {
                // Tile is completely outside range -> EMPTY
                // TODO: is it actually correct that the source even creates the tile ?
                _this.state = TileState.EMPTY;
                return _this;
            }
            var sourceProjExtent = sourceProj.getExtent();
            if (sourceProjExtent) {
                if (!maxSourceExtent) {
                    maxSourceExtent = sourceProjExtent;
                }
                else {
                    maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
                }
            }
            var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
            var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);
            if (!isFinite(sourceResolution) || sourceResolution <= 0) {
                // invalid sourceResolution -> EMPTY
                // probably edges of the projections when no extent is defined
                _this.state = TileState.EMPTY;
                return _this;
            }
            var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;
            /**
             * @private
             * @type {!import("./Triangulation.js").default}
             */
            _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
            if (_this.triangulation_.getTriangles().length === 0) {
                // no valid triangles -> EMPTY
                _this.state = TileState.EMPTY;
                return _this;
            }
            _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
            var sourceExtent = _this.triangulation_.calculateSourceExtent();
            if (maxSourceExtent) {
                if (sourceProj.canWrapX()) {
                    sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
                    sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
                }
                else {
                    sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
                }
            }
            if (!getArea(sourceExtent)) {
                _this.state = TileState.EMPTY;
            }
            else {
                var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);
                for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
                    for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
                        var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);
                        if (tile) {
                            _this.sourceTiles_.push(tile);
                        }
                    }
                }
                if (_this.sourceTiles_.length === 0) {
                    _this.state = TileState.EMPTY;
                }
            }
            return _this;
        }
        /**
         * Get the HTML Canvas element for this tile.
         * @return {HTMLCanvasElement} Canvas.
         */
        ReprojTile.prototype.getImage = function () {
            return this.canvas_;
        };
        /**
         * @private
         */
        ReprojTile.prototype.reproject_ = function () {
            var sources = [];
            this.sourceTiles_.forEach(function (tile, i, arr) {
                if (tile && tile.getState() == TileState.LOADED) {
                    sources.push({
                        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
                        image: tile.getImage(),
                    });
                }
            }.bind(this));
            this.sourceTiles_.length = 0;
            if (sources.length === 0) {
                this.state = TileState.ERROR;
            }
            else {
                var z = this.wrappedTileCoord_[0];
                var size = this.targetTileGrid_.getTileSize(z);
                var width = typeof size === 'number' ? size : size[0];
                var height = typeof size === 'number' ? size : size[1];
                var targetResolution = this.targetTileGrid_.getResolution(z);
                var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
                var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
                this.canvas_ = render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.contextOptions_);
                this.state = TileState.LOADED;
            }
            this.changed();
        };
        /**
         * Load not yet loaded URI.
         */
        ReprojTile.prototype.load = function () {
            if (this.state == TileState.IDLE) {
                this.state = TileState.LOADING;
                this.changed();
                var leftToLoad_1 = 0;
                this.sourcesListenerKeys_ = [];
                this.sourceTiles_.forEach(function (tile, i, arr) {
                    var state = tile.getState();
                    if (state == TileState.IDLE || state == TileState.LOADING) {
                        leftToLoad_1++;
                        var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {
                            var state = tile.getState();
                            if (state == TileState.LOADED ||
                                state == TileState.ERROR ||
                                state == TileState.EMPTY) {
                                unlistenByKey(sourceListenKey_1);
                                leftToLoad_1--;
                                if (leftToLoad_1 === 0) {
                                    this.unlistenSources_();
                                    this.reproject_();
                                }
                            }
                        }, this);
                        this.sourcesListenerKeys_.push(sourceListenKey_1);
                    }
                }.bind(this));
                this.sourceTiles_.forEach(function (tile, i, arr) {
                    var state = tile.getState();
                    if (state == TileState.IDLE) {
                        tile.load();
                    }
                });
                if (leftToLoad_1 === 0) {
                    setTimeout(this.reproject_.bind(this), 0);
                }
            }
        };
        /**
         * @private
         */
        ReprojTile.prototype.unlistenSources_ = function () {
            this.sourcesListenerKeys_.forEach(unlistenByKey);
            this.sourcesListenerKeys_ = null;
        };
        return ReprojTile;
    }(Tile));

    var __extends$5 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
     * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
     * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
     * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     * @property {boolean} [imageSmoothing=true] Enable image smoothing.
     * @property {boolean} [opaque=false] Whether the layer is opaque.
     * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
     * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     * @property {import("./State.js").default} [state] Source state.
     * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
     * Default is {@link module:ol/ImageTile~ImageTile}.
     * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
     * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     *   imageTile.getImage().src = src;
     * };
     * ```
     * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
     * service advertizes 256px by 256px tiles but actually sends 512px
     * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
     * should be set to `2`.
     * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
     * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
     * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
     * used instead of defining each one separately in the `urls` option.
     * @property {Array<string>} [urls] An array of URL templates.
     * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
     * request out-of-bounds tiles from the server. When set to `false`, only one
     * world will be rendered. When set to `true`, tiles will be requested for one
     * world only, but they will be wrapped horizontally to render multiple worlds.
     * @property {number} [transition] Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     * @property {string} [key] Optional tile key for proper cache fetching
     * @property {number} [zDirection=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     */
    /**
     * @classdesc
     * Base class for sources providing images divided into a tile grid.
     *
     * @fires import("./Tile.js").TileSourceEvent
     * @api
     */
    var TileImage = /** @class */ (function (_super) {
        __extends$5(TileImage, _super);
        /**
         * @param {!Options} options Image tile options.
         */
        function TileImage(options) {
            var _this = _super.call(this, {
                attributions: options.attributions,
                cacheSize: options.cacheSize,
                opaque: options.opaque,
                projection: options.projection,
                state: options.state,
                tileGrid: options.tileGrid,
                tileLoadFunction: options.tileLoadFunction
                    ? options.tileLoadFunction
                    : defaultTileLoadFunction,
                tilePixelRatio: options.tilePixelRatio,
                tileUrlFunction: options.tileUrlFunction,
                url: options.url,
                urls: options.urls,
                wrapX: options.wrapX,
                transition: options.transition,
                key: options.key,
                attributionsCollapsible: options.attributionsCollapsible,
                zDirection: options.zDirection,
            }) || this;
            /**
             * @protected
             * @type {?string}
             */
            _this.crossOrigin =
                options.crossOrigin !== undefined ? options.crossOrigin : null;
            /**
             * @protected
             * @type {typeof ImageTile}
             */
            _this.tileClass =
                options.tileClass !== undefined ? options.tileClass : ImageTile;
            /**
             * @protected
             * @type {!Object<string, TileCache>}
             */
            _this.tileCacheForProjection = {};
            /**
             * @protected
             * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
             */
            _this.tileGridForProjection = {};
            /**
             * @private
             * @type {number|undefined}
             */
            _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
            /**
             * @private
             * @type {object|undefined}
             */
            _this.contextOptions_ =
                options.imageSmoothing === false ? IMAGE_SMOOTHING_DISABLED : undefined;
            /**
             * @private
             * @type {boolean}
             */
            _this.renderReprojectionEdges_ = false;
            return _this;
        }
        /**
         * @return {boolean} Can expire cache.
         */
        TileImage.prototype.canExpireCache = function () {
            if (this.tileCache.canExpireCache()) {
                return true;
            }
            else {
                for (var key in this.tileCacheForProjection) {
                    if (this.tileCacheForProjection[key].canExpireCache()) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @param {!Object<string, boolean>} usedTiles Used tiles.
         */
        TileImage.prototype.expireCache = function (projection, usedTiles) {
            var usedTileCache = this.getTileCacheForProjection(projection);
            this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
            for (var id in this.tileCacheForProjection) {
                var tileCache = this.tileCacheForProjection[id];
                tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
            }
        };
        /**
         * @return {Object|undefined} Context options.
         */
        TileImage.prototype.getContextOptions = function () {
            return this.contextOptions_;
        };
        /**
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {number} Gutter.
         */
        TileImage.prototype.getGutterForProjection = function (projection) {
            if (this.getProjection() &&
                projection &&
                !equivalent(this.getProjection(), projection)) {
                return 0;
            }
            else {
                return this.getGutter();
            }
        };
        /**
         * @return {number} Gutter.
         */
        TileImage.prototype.getGutter = function () {
            return 0;
        };
        /**
         * Return the key to be used for all tiles in the source.
         * @return {string} The key for all tiles.
         * @protected
         */
        TileImage.prototype.getKey = function () {
            return (_super.prototype.getKey.call(this) +
                (this.contextOptions_ ? '\n' + JSON.stringify(this.contextOptions_) : ''));
        };
        /**
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {boolean} Opaque.
         */
        TileImage.prototype.getOpaque = function (projection) {
            if (this.getProjection() &&
                projection &&
                !equivalent(this.getProjection(), projection)) {
                return false;
            }
            else {
                return _super.prototype.getOpaque.call(this, projection);
            }
        };
        /**
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
         */
        TileImage.prototype.getTileGridForProjection = function (projection) {
            var thisProj = this.getProjection();
            if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
                return this.tileGrid;
            }
            else {
                var projKey = getUid(projection);
                if (!(projKey in this.tileGridForProjection)) {
                    this.tileGridForProjection[projKey] = getForProjection(projection);
                }
                return this.tileGridForProjection[projKey];
            }
        };
        /**
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {import("../TileCache.js").default} Tile cache.
         */
        TileImage.prototype.getTileCacheForProjection = function (projection) {
            var thisProj = this.getProjection();
            if (!thisProj || equivalent(thisProj, projection)) {
                return this.tileCache;
            }
            else {
                var projKey = getUid(projection);
                if (!(projKey in this.tileCacheForProjection)) {
                    this.tileCacheForProjection[projKey] = new TileCache(this.tileCache.highWaterMark);
                }
                return this.tileCacheForProjection[projKey];
            }
        };
        /**
         * @param {number} z Tile coordinate z.
         * @param {number} x Tile coordinate x.
         * @param {number} y Tile coordinate y.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @param {string} key The key set on the tile.
         * @return {!import("../Tile.js").default} Tile.
         * @private
         */
        TileImage.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {
            var tileCoord = [z, x, y];
            var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
            var tileUrl = urlTileCoord
                ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)
                : undefined;
            var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
            tile.key = key;
            tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));
            return tile;
        };
        /**
         * @param {number} z Tile coordinate z.
         * @param {number} x Tile coordinate x.
         * @param {number} y Tile coordinate y.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {!import("../Tile.js").default} Tile.
         */
        TileImage.prototype.getTile = function (z, x, y, pixelRatio, projection) {
            var sourceProjection = this.getProjection();
            if (!sourceProjection ||
                !projection ||
                equivalent(sourceProjection, projection)) {
                return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
            }
            else {
                var cache = this.getTileCacheForProjection(projection);
                var tileCoord = [z, x, y];
                var tile = void 0;
                var tileCoordKey = getKey(tileCoord);
                if (cache.containsKey(tileCoordKey)) {
                    tile = cache.get(tileCoordKey);
                }
                var key = this.getKey();
                if (tile && tile.key == key) {
                    return tile;
                }
                else {
                    var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
                    var targetTileGrid = this.getTileGridForProjection(projection);
                    var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
                    var newTile = new ReprojTile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {
                        return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
                    }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.contextOptions_);
                    newTile.key = key;
                    if (tile) {
                        newTile.interimTile = tile;
                        newTile.refreshInterimChain();
                        cache.replace(tileCoordKey, newTile);
                    }
                    else {
                        cache.set(tileCoordKey, newTile);
                    }
                    return newTile;
                }
            }
        };
        /**
         * @param {number} z Tile coordinate z.
         * @param {number} x Tile coordinate x.
         * @param {number} y Tile coordinate y.
         * @param {number} pixelRatio Pixel ratio.
         * @param {!import("../proj/Projection.js").default} projection Projection.
         * @return {!import("../Tile.js").default} Tile.
         * @protected
         */
        TileImage.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {
            var tile = null;
            var tileCoordKey = getKeyZXY(z, x, y);
            var key = this.getKey();
            if (!this.tileCache.containsKey(tileCoordKey)) {
                tile = this.createTile_(z, x, y, pixelRatio, projection, key);
                this.tileCache.set(tileCoordKey, tile);
            }
            else {
                tile = this.tileCache.get(tileCoordKey);
                if (tile.key != key) {
                    // The source's params changed. If the tile has an interim tile and if we
                    // can use it then we use it. Otherwise we create a new tile.  In both
                    // cases we attempt to assign an interim tile to the new tile.
                    var interimTile = tile;
                    tile = this.createTile_(z, x, y, pixelRatio, projection, key);
                    //make the new tile the head of the list,
                    if (interimTile.getState() == TileState.IDLE) {
                        //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
                        tile.interimTile = interimTile.interimTile;
                    }
                    else {
                        tile.interimTile = interimTile;
                    }
                    tile.refreshInterimChain();
                    this.tileCache.replace(tileCoordKey, tile);
                }
            }
            return tile;
        };
        /**
         * Sets whether to render reprojection edges or not (usually for debugging).
         * @param {boolean} render Render the edges.
         * @api
         */
        TileImage.prototype.setRenderReprojectionEdges = function (render) {
            if (this.renderReprojectionEdges_ == render) {
                return;
            }
            this.renderReprojectionEdges_ = render;
            for (var id in this.tileCacheForProjection) {
                this.tileCacheForProjection[id].clear();
            }
            this.changed();
        };
        /**
         * Sets the tile grid to use when reprojecting the tiles to the given
         * projection instead of the default tile grid for the projection.
         *
         * This can be useful when the default tile grid cannot be created
         * (e.g. projection has no extent defined) or
         * for optimization reasons (custom tile size, resolutions, ...).
         *
         * @param {import("../proj.js").ProjectionLike} projection Projection.
         * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
         * @api
         */
        TileImage.prototype.setTileGridForProjection = function (projection, tilegrid) {
            {
                var proj = get$1(projection);
                if (proj) {
                    var projKey = getUid(proj);
                    if (!(projKey in this.tileGridForProjection)) {
                        this.tileGridForProjection[projKey] = tilegrid;
                    }
                }
            }
        };
        return TileImage;
    }(UrlTile));
    /**
     * @param {ImageTile} imageTile Image tile.
     * @param {string} src Source.
     */
    function defaultTileLoadFunction(imageTile, src) {
        /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src = src;
    }

    var __extends$4 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A function that is called to trigger asynchronous canvas drawing.  It is
     * called with a "done" callback that should be called when drawing is done.
     * If any error occurs during drawing, the "done" callback should be called with
     * that error.
     *
     * @typedef {function(function(Error=): void): void} Loader
     */
    var ImageCanvas = /** @class */ (function (_super) {
        __extends$4(ImageCanvas, _super);
        /**
         * @param {import("./extent.js").Extent} extent Extent.
         * @param {number} resolution Resolution.
         * @param {number} pixelRatio Pixel ratio.
         * @param {HTMLCanvasElement} canvas Canvas.
         * @param {Loader=} opt_loader Optional loader function to
         *     support asynchronous canvas drawing.
         */
        function ImageCanvas(extent, resolution, pixelRatio, canvas, opt_loader) {
            var _this = this;
            var state = opt_loader !== undefined ? ImageState.IDLE : ImageState.LOADED;
            _this = _super.call(this, extent, resolution, pixelRatio, state) || this;
            /**
             * Optional canvas loader function.
             * @type {?Loader}
             * @private
             */
            _this.loader_ = opt_loader !== undefined ? opt_loader : null;
            /**
             * @private
             * @type {HTMLCanvasElement}
             */
            _this.canvas_ = canvas;
            /**
             * @private
             * @type {?Error}
             */
            _this.error_ = null;
            return _this;
        }
        /**
         * Get any error associated with asynchronous rendering.
         * @return {?Error} Any error that occurred during rendering.
         */
        ImageCanvas.prototype.getError = function () {
            return this.error_;
        };
        /**
         * Handle async drawing complete.
         * @param {Error=} err Any error during drawing.
         * @private
         */
        ImageCanvas.prototype.handleLoad_ = function (err) {
            if (err) {
                this.error_ = err;
                this.state = ImageState.ERROR;
            }
            else {
                this.state = ImageState.LOADED;
            }
            this.changed();
        };
        /**
         * Load not yet loaded URI.
         */
        ImageCanvas.prototype.load = function () {
            if (this.state == ImageState.IDLE) {
                this.state = ImageState.LOADING;
                this.changed();
                this.loader_(this.handleLoad_.bind(this));
            }
        };
        /**
         * @return {HTMLCanvasElement} Canvas element.
         */
        ImageCanvas.prototype.getImage = function () {
            return this.canvas_;
        };
        return ImageCanvas;
    }(ImageBase));

    var __extends$3 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @classdesc
     * Canvas renderer for image layers.
     * @api
     */
    var CanvasVectorImageLayerRenderer = /** @class */ (function (_super) {
        __extends$3(CanvasVectorImageLayerRenderer, _super);
        /**
         * @param {import("../../layer/VectorImage.js").default} layer Vector image layer.
         */
        function CanvasVectorImageLayerRenderer(layer) {
            var _this = _super.call(this, layer) || this;
            /**
             * @private
             * @type {import("./VectorLayer.js").default}
             */
            _this.vectorRenderer_ = new CanvasVectorLayerRenderer(layer);
            /**
             * @private
             * @type {number}
             */
            _this.layerImageRatio_ = layer.getImageRatio();
            /**
             * @private
             * @type {import("../../transform.js").Transform}
             */
            _this.coordinateToVectorPixelTransform_ = create();
            /**
             * @private
             * @type {import("../../transform.js").Transform}
             */
            _this.renderedPixelToCoordinateTransform_ = null;
            return _this;
        }
        /**
         * Clean up.
         */
        CanvasVectorImageLayerRenderer.prototype.disposeInternal = function () {
            this.vectorRenderer_.dispose();
            _super.prototype.disposeInternal.call(this);
        };
        /**
         * Asynchronous layer level hit detection.
         * @param {import("../../pixel.js").Pixel} pixel Pixel.
         * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
         */
        CanvasVectorImageLayerRenderer.prototype.getFeatures = function (pixel) {
            if (this.vectorRenderer_) {
                var vectorPixel = apply(this.coordinateToVectorPixelTransform_, apply(this.renderedPixelToCoordinateTransform_, pixel.slice()));
                return this.vectorRenderer_.getFeatures(vectorPixel);
            }
            else {
                var promise = new Promise(function (resolve, reject) {
                    resolve([]);
                });
                return promise;
            }
        };
        /**
         * Perform action necessary to get the layer rendered after new fonts have loaded
         */
        CanvasVectorImageLayerRenderer.prototype.handleFontsChanged = function () {
            this.vectorRenderer_.handleFontsChanged();
        };
        /**
         * Determine whether render should be called.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @return {boolean} Layer is ready to be rendered.
         */
        CanvasVectorImageLayerRenderer.prototype.prepareFrame = function (frameState) {
            var pixelRatio = frameState.pixelRatio;
            var viewState = frameState.viewState;
            var viewResolution = viewState.resolution;
            var hints = frameState.viewHints;
            var vectorRenderer = this.vectorRenderer_;
            var renderedExtent = frameState.extent;
            if (this.layerImageRatio_ !== 1) {
                renderedExtent = renderedExtent.slice(0);
                scaleFromCenter(renderedExtent, this.layerImageRatio_);
            }
            var width = getWidth(renderedExtent) / viewResolution;
            var height = getHeight(renderedExtent) / viewResolution;
            if (!hints[ViewHint.ANIMATING] &&
                !hints[ViewHint.INTERACTING] &&
                !isEmpty(renderedExtent)) {
                vectorRenderer.useContainer(null, null, 1);
                var context = vectorRenderer.context;
                var imageFrameState_1 = /** @type {import("../../PluggableMap.js").FrameState} */ (assign({}, frameState, {
                    declutterTree: new rbush_min(9),
                    extent: renderedExtent,
                    size: [width, height],
                    viewState: /** @type {import("../../View.js").State} */ (assign({}, frameState.viewState, {
                        rotation: 0,
                    })),
                }));
                var image_1 = new ImageCanvas(renderedExtent, viewResolution, pixelRatio, context.canvas, function (callback) {
                    if (vectorRenderer.prepareFrame(imageFrameState_1) &&
                        vectorRenderer.replayGroupChanged) {
                        vectorRenderer.clipping = false;
                        vectorRenderer.renderFrame(imageFrameState_1, null);
                        vectorRenderer.renderDeclutter(imageFrameState_1);
                        callback();
                    }
                });
                image_1.addEventListener(EventType.CHANGE, function () {
                    if (image_1.getState() === ImageState.LOADED) {
                        this.image_ = image_1;
                        var imageResolution = image_1.getResolution();
                        var imagePixelRatio = image_1.getPixelRatio();
                        var renderedResolution = (imageResolution * pixelRatio) / imagePixelRatio;
                        this.renderedResolution = renderedResolution;
                        this.coordinateToVectorPixelTransform_ = compose(this.coordinateToVectorPixelTransform_, width / 2, height / 2, 1 / renderedResolution, -1 / renderedResolution, 0, -viewState.center[0], -viewState.center[1]);
                    }
                }.bind(this));
                image_1.load();
            }
            if (this.image_) {
                this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();
            }
            return !!this.image_;
        };
        /**
         */
        CanvasVectorImageLayerRenderer.prototype.preRender = function () { };
        /**
         */
        CanvasVectorImageLayerRenderer.prototype.postRender = function () { };
        /**
         */
        CanvasVectorImageLayerRenderer.prototype.renderDeclutter = function () { };
        /**
         * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         * @param {number} hitTolerance Hit tolerance in pixels.
         * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
         * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
         * @return {T|undefined} Callback result.
         * @template T
         */
        CanvasVectorImageLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {
            if (this.vectorRenderer_) {
                return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches);
            }
            else {
                return _super.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback, matches);
            }
        };
        return CanvasVectorImageLayerRenderer;
    }(CanvasImageLayerRenderer));

    var __extends$2 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
     * @property {number} [opacity=1] Opacity (0, 1).
     * @property {boolean} [visible=true] Visibility.
     * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
     * visible.
     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
     * be visible.
     * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
     * features before rendering. By default features are drawn in the order that they are created. Use
     * `null` to avoid the sort, but get an undefined draw order.
     * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
     * renderer when getting features from the vector source for the rendering or hit-detection.
     * Recommended value: the size of the largest symbol, line width or label.
     * @property {import("../source/Vector.js").default} [source] Source.
     * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
     * this layer in its layers collection, and the layer will be rendered on top. This is useful for
     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
     * use {@link module:ol/Map#addLayer}.
     * @property {boolean} [declutter=false] Declutter images and text on this layer. The priority is defined
     * by the `zIndex` of the style and the render order of features. Higher z-index means higher priority.
     * Within the same z-index, a feature rendered before another has higher priority.
     * @property {import("../style/Style.js").StyleLike} [style] Layer style. See
     * {@link module:ol/style} for default style which will be used if this is not defined.
     * @property {number} [imageRatio=1] Ratio by which the rendered extent should be larger than the
     * viewport extent. A larger ratio avoids cut images during panning, but will cause a decrease in performance.
     */
    /**
     * @classdesc
     * Vector data that is rendered client-side.
     * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
     * property on the layer object; for example, setting `title: 'My Title'` in the
     * options means that `title` is observable, and has get/set accessors.
     *
     * @api
     */
    var VectorImageLayer = /** @class */ (function (_super) {
        __extends$2(VectorImageLayer, _super);
        /**
         * @param {Options=} opt_options Options.
         */
        function VectorImageLayer(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var baseOptions = assign({}, options);
            delete baseOptions.imageRatio;
            _this = _super.call(this, baseOptions) || this;
            /**
             * @type {number}
             * @private
             */
            _this.imageRatio_ =
                options.imageRatio !== undefined ? options.imageRatio : 1;
            return _this;
        }
        /**
         * @return {number} Ratio between rendered extent size and viewport extent size.
         */
        VectorImageLayer.prototype.getImageRatio = function () {
            return this.imageRatio_;
        };
        /**
         * Create a renderer for this layer.
         * @return {import("../renderer/Layer.js").default} A layer renderer.
         */
        VectorImageLayer.prototype.createRenderer = function () {
            return new CanvasVectorImageLayerRenderer(this);
        };
        return VectorImageLayer;
    }(BaseVectorLayer));

    /**
     * @module ol/source/XYZ
     */
    var __extends$1 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @typedef {Object} Options
     * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
     * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
     * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
     * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     * @property {boolean} [imageSmoothing=true] Enable image smoothing.
     * @property {boolean} [opaque=false] Whether the layer is opaque.
     * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
     * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
     * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
     * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
     * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
     * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     *   imageTile.getImage().src = src;
     * };
     * ```
     * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
     * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
     * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
     * should be set to `2`.
     * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
     * Not used if `tileGrid` is provided.
     * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
     * tile URL given a tile coordinate and the projection.
     * Required if `url` or `urls` are not provided.
     * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
     * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
     * may be used instead of defining each one separately in the `urls` option.
     * @property {Array<string>} [urls] An array of URL templates.
     * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
     * @property {number} [transition=250] Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     * @property {number} [zDirection=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     */
    /**
     * @classdesc
     * Layer source for tile data with URLs in a set XYZ format that are
     * defined in a URL template. By default, this follows the widely-used
     * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
     * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
     * using the `{-y}` placeholder in the URL template, so long as the
     * source does not have a custom tile grid. In this case
     * a `tileUrlFunction` can be used, such as:
     * ```js
     *  tileUrlFunction: function(coordinate) {
     *    return 'http://mapserver.com/' + coordinate[0] + '/' +
     *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';
     *  }
     * ```
     * @api
     */
    var XYZ = /** @class */ (function (_super) {
        __extends$1(XYZ, _super);
        /**
         * @param {Options=} opt_options XYZ options.
         */
        function XYZ(opt_options) {
            var _this = this;
            var options = opt_options || {};
            var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';
            var tileGrid = options.tileGrid !== undefined
                ? options.tileGrid
                : createXYZ({
                    extent: extentFromProjection(projection),
                    maxResolution: options.maxResolution,
                    maxZoom: options.maxZoom,
                    minZoom: options.minZoom,
                    tileSize: options.tileSize,
                });
            _this = _super.call(this, {
                attributions: options.attributions,
                cacheSize: options.cacheSize,
                crossOrigin: options.crossOrigin,
                imageSmoothing: options.imageSmoothing,
                opaque: options.opaque,
                projection: projection,
                reprojectionErrorThreshold: options.reprojectionErrorThreshold,
                tileGrid: tileGrid,
                tileLoadFunction: options.tileLoadFunction,
                tilePixelRatio: options.tilePixelRatio,
                tileUrlFunction: options.tileUrlFunction,
                url: options.url,
                urls: options.urls,
                wrapX: options.wrapX !== undefined ? options.wrapX : true,
                transition: options.transition,
                attributionsCollapsible: options.attributionsCollapsible,
                zDirection: options.zDirection,
            }) || this;
            return _this;
        }
        return XYZ;
    }(TileImage));

    /**
     * @module ol/source/OSM
     */
    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * The attribution containing a link to the OpenStreetMap Copyright and License
     * page.
     * @const
     * @type {string}
     * @api
     */
    var ATTRIBUTION = '&#169; ' +
        '<a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> ' +
        'contributors.';
    /**
     * @typedef {Object} Options
     * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
     * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
     * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     * @property {boolean} [imageSmoothing=true] Enable image smoothing.
     * @property {number} [maxZoom=19] Max zoom.
     * @property {boolean} [opaque=true] Whether the layer is opaque.
     * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     *   imageTile.getImage().src = src;
     * };
     * ```
     * @property {number} [transition=250] Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
     * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
     * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
     */
    /**
     * @classdesc
     * Layer source for the OpenStreetMap tile server.
     * @api
     */
    var OSM = /** @class */ (function (_super) {
        __extends(OSM, _super);
        /**
         * @param {Options=} [opt_options] Open Street Map options.
         */
        function OSM(opt_options) {
            var _this = this;
            var options = opt_options || {};
            var attributions;
            if (options.attributions !== undefined) {
                attributions = options.attributions;
            }
            else {
                attributions = [ATTRIBUTION];
            }
            var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';
            var url = options.url !== undefined
                ? options.url
                : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';
            _this = _super.call(this, {
                attributions: attributions,
                attributionsCollapsible: false,
                cacheSize: options.cacheSize,
                crossOrigin: crossOrigin,
                imageSmoothing: options.imageSmoothing,
                maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
                opaque: options.opaque !== undefined ? options.opaque : true,
                reprojectionErrorThreshold: options.reprojectionErrorThreshold,
                tileLoadFunction: options.tileLoadFunction,
                transition: options.transition,
                url: url,
                wrapX: options.wrapX,
            }) || this;
            return _this;
        }
        return OSM;
    }(XYZ));

    let dragAndDropInteraction;
    const dragAndDrop = (map) => {
    	if (dragAndDropInteraction) {
    		map.removeInteraction(dragAndDropInteraction);
    	}
    	dragAndDropInteraction = new DragAndDrop({
    		formatConstructors: [GeoJSON],
    	});
    	dragAndDropInteraction.on("addfeatures", function (event) {
    		var vectorSource = new VectorSource({
    			features: event.features,
    		});
    		map.addLayer(
    			new VectorLayer({
    				source: vectorSource,
    			})
    		);
    		map.getView().fit(vectorSource.getExtent());
    	});
    	map.addInteraction(dragAndDropInteraction);
    };

    const openGeometry = (event) => {
    	const featuresAtPixel = event.map
    		.getFeaturesAtPixel(event.pixel, {
    			hitTolerance: 0,
    		})
    		.filter((feat) => Object.keys(feat.getProperties()).length > 1);

    	const object = featuresAtPixel[0].getProperties();

    	window.open(
    		`/${object["@type"]}s/${object.gid}`,
    		object.uuid,
    		`width="750",height="630",menubar=no,location=no,toolbar=no,resizable=no,status=no,scrollbars=no`
    	);
    };

    var bind = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };

    /*global toString:true*/

    // utils is a library of generic helper functions non-specific to axios

    var toString = Object.prototype.toString;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray(val) {
      return toString.call(val) === '[object Array]';
    }

    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }

    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString.call(val) === '[object ArrayBuffer]';
    }

    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }

    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }

    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }

    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject(val) {
      return val !== null && typeof val === 'object';
    }

    /**
     * Determine if a value is a plain Object
     *
     * @param {Object} val The value to test
     * @return {boolean} True if value is a plain Object, otherwise false
     */
    function isPlainObject(val) {
      if (toString.call(val) !== '[object Object]') {
        return false;
      }

      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }

    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString.call(val) === '[object Date]';
    }

    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString.call(val) === '[object File]';
    }

    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString.call(val) === '[object Blob]';
    }

    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction(val) {
      return toString.call(val) === '[object Function]';
    }

    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.replace(/^\s*/, '').replace(/\s*$/, '');
    }

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }

    /**
     * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
     *
     * @param {string} content with BOM
     * @return {string} content value without BOM
     */
    function stripBOM(content) {
      if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
      }
      return content;
    }

    var utils = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject,
      isPlainObject: isPlainObject,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      extend: extend,
      trim: trim,
      stripBOM: stripBOM
    };

    function encode(val) {
      return encodeURIComponent(val).
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    var buildURL = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];

        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }

          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });

        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }

        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    function InterceptorManager() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected
      });
      return this.handlers.length - 1;
    };

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager;

    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    var transformData = function transformData(data, headers, fns) {
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });

      return data;
    };

    var isCancel = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    var enhanceError = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }

      error.request = request;
      error.response = response;
      error.isAxiosError = true;

      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    var createError = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    var settle = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };

    var cookies = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));

              if (utils.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }

              if (utils.isString(path)) {
                cookie.push('path=' + path);
              }

              if (utils.isString(domain)) {
                cookie.push('domain=' + domain);
              }

              if (secure === true) {
                cookie.push('secure');
              }

              document.cookie = cookie.join('; ');
            },

            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },

            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :

      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    var isAbsoluteURL = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    var combineURLs = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };

    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */
    var buildFullPath = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };

    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) { return parsed; }

      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));

        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });

      return parsed;
    };

    var isURLSameOrigin = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;

          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;

            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }

            urlParsingNode.setAttribute('href', href);

            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }

          originURL = resolveURL(window.location.href);

          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );

    var xhr = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;

        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();

        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }

        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config.timeout;

        // Listen for ready state
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }

          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }

          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };

          settle(resolve, reject, response);

          // Clean up request
          request = null;
        };

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(createError('Request aborted', config, 'ECONNABORTED', request));

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
            cookies.read(config.xsrfCookieName) :
            undefined;

          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }

        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }

        // Add responseType to request if needed
        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
            // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
            if (config.responseType !== 'json') {
              throw e;
            }
          }
        }

        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }

        if (config.cancelToken) {
          // Handle cancellation
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }

            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }

        if (!requestData) {
          requestData = null;
        }

        // Send the request
        request.send(requestData);
      });
    };

    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = xhr;
      }
      return adapter;
    }

    var defaults = {
      adapter: getDefaultAdapter(),

      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');
        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data)) {
          setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
          return JSON.stringify(data);
        }
        return data;
      }],

      transformResponse: [function transformResponse(data) {
        /*eslint no-param-reassign:0*/
        if (typeof data === 'string') {
          try {
            data = JSON.parse(data);
          } catch (e) { /* Ignore */ }
        }
        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,
      maxBodyLength: -1,

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };

    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };

    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults_1 = defaults;

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    var dispatchRequest = function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      // Ensure headers exist
      config.headers = config.headers || {};

      // Transform request data
      config.data = transformData(
        config.data,
        config.headers,
        config.transformRequest
      );

      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );

      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );

      var adapter = config.adapter || defaults_1.adapter;

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData(
          response.data,
          response.headers,
          config.transformResponse
        );

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData(
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }

        return Promise.reject(reason);
      });
    };

    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    var mergeConfig = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};

      var valueFromConfig2Keys = ['url', 'method', 'data'];
      var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
      var defaultToConfig2Keys = [
        'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
        'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
        'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
        'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
        'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
      ];
      var directMergeKeys = ['validateStatus'];

      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }

      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      }

      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        }
      });

      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });

      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });

      var axiosKeys = valueFromConfig2Keys
        .concat(mergeDeepPropertiesKeys)
        .concat(defaultToConfig2Keys)
        .concat(directMergeKeys);

      var otherKeys = Object
        .keys(config1)
        .concat(Object.keys(config2))
        .filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });

      utils.forEach(otherKeys, mergeDeepProperties);

      return config;
    };

    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }

      config = mergeConfig(this.defaults, config);

      // Set config.method
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      }

      // Hook up interceptors middleware
      var chain = [dispatchRequest, undefined];
      var promise = Promise.resolve(config);

      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });

      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }

      return promise;
    };

    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };

    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: (config || {}).data
        }));
      };
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });

    var Axios_1 = Axios;

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }

    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel.prototype.__CANCEL__ = true;

    var Cancel_1 = Cancel;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    var spread = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    /**
     * Determines whether the payload is an error thrown by Axios
     *
     * @param {*} payload The value to test
     * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
     */
    var isAxiosError = function isAxiosError(payload) {
      return (typeof payload === 'object') && (payload.isAxiosError === true);
    };

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios_1(defaultConfig);
      var instance = bind(Axios_1.prototype.request, context);

      // Copy axios.prototype to instance
      utils.extend(instance, Axios_1.prototype, context);

      // Copy context to instance
      utils.extend(instance, context);

      return instance;
    }

    // Create the default instance to be exported
    var axios$1 = createInstance(defaults_1);

    // Expose Axios class to allow class inheritance
    axios$1.Axios = Axios_1;

    // Factory for creating new instances
    axios$1.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
    };

    // Expose Cancel & CancelToken
    axios$1.Cancel = Cancel_1;
    axios$1.CancelToken = CancelToken_1;
    axios$1.isCancel = isCancel;

    // Expose all/spread
    axios$1.all = function all(promises) {
      return Promise.all(promises);
    };
    axios$1.spread = spread;

    // Expose isAxiosError
    axios$1.isAxiosError = isAxiosError;

    var axios_1 = axios$1;

    // Allow use of default import syntax in TypeScript
    var _default = axios$1;
    axios_1.default = _default;

    var axios = axios_1;

    // ...................MAP...................
    function lon2tile(lon, zoom) {
    	return Math.floor(((lon + 180) / 360) * Math.pow(2, zoom));
    }

    function lat2tile(lat, zoom) {
    	return Math.floor(
    		((1 - Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) / Math.PI) / 2) *
    			Math.pow(2, zoom)
    	);
    }

    const dispatchFeature = (map, response, layerName) => {
    	const filterLayers = map
    		.getLayers()
    		.getArray()
    		.filter((layer) => layer.getProperties().name === layerName);

    	[...response.features];
    	filterLayers.map((layer) => {
    		const readedFeatures = new GeoJSON().readFeatures(response);
    		layer.getSource().addFeatures(readedFeatures);
    	});
    };

    // Get and tranform extent to 4326 (deg)

    const moveStart = (event) => {
    	console.log("moveStart");
    	const currentZoom = event.map.getView().getZoom();
    	if (currentZoom < 13) {
    		return;
    	}
    	let cacheKeys = [];
    	let featuresUuid = [];
    	let extent = event.map.getView().calculateExtent(event.map.getSize());
    	extent = transformExtent(
    		extent,
    		"EPSG:3857", // EPSG:3857
    		"EPSG:4326" // EPSG:4326
    	);

    	// Calculates tiles by zoom
    	const leftTile = lon2tile(extent[0], 15);
    	const bottomTile = lat2tile(extent[1], 15);
    	const rightTile = lon2tile(extent[2], 15);
    	const topTile = lat2tile(extent[3], 15);
    	for (let x = leftTile; x <= rightTile; x++) {
    		for (let y = topTile; y <= bottomTile; y++) {
    			["cables", "supports", "pt_techs", "sites"].forEach((layerName) => {
    				axios
    					.get(`http://api.odyssee.staging.vlq16.iliad.fr/v1/${layerName}/?x=${x}&y=${y}&z=15`, {
    						cache: cacheKeys[`${layerName}-${x}-${y}`], // custom cache key
    					})
    					.then((response) => {
    						const x = response.data.x;
    						const y = response.data.y;
    						const type = response.data["@type"];

    						const key = `${type}-${x}-${y}`;

    						cacheKeys[key] = response.data.cache;
    						// console.log({ key });
    						// console.log({ x });
    						// console.log({ y });
    						// console.log(response.data);

    						let finalFeatures = [];

    						response.data.features.map((feature) => {
    							const featureUuid = feature.properties.uuid;

    							// If current feature isn't already added to current layer source
    							// > meaning: if current feat uuid isn't already associated in featuresUuid (local prop)
    							if (!featuresUuid[featureUuid]) {
    								featuresUuid[featureUuid] = true;
    								finalFeatures.push(feature);
    							}
    						});
    						// console.log({ response });
    						// console.log({ finalFeatures });
    						response.features = finalFeatures;

    						// mainLayer.getSource().addFeatures(readedFeatures);
    						// this.dispatchFeatures(response, layerName);
    						// dispatch feature in layer
    						dispatchFeature(event.map, response.data, type);
    					})
    					.catch((error) => console.log(error));
    			});
    		}
    	}
    };

    const mainLayerBuild = (map) => {
    	console.log("moveStart");
    	["site", "cable", "pt_tech"].map((topParentName) => {
    		let style;

    		if (topParentName === "site") {
    			style = new Style({
    				image: new RegularShape({
    					fill: new Fill({ color: "rgba(84, 254, 14, 1)" }),
    					stroke: new Stroke({
    						color: "rgba(255, 255, 255, 1)",
    						width: 3,
    					}),
    					points: 4,
    					radius: 8,
    					angle: Math.PI / 4,
    				}),
    			});
    		} else if (topParentName === "support" || topParentName === "cable") {
    			style = new Style({
    				stroke: new Stroke({
    					color: "rgba(254, 14, 15, 1)",
    					width: 3,
    				}),
    			});
    		} else {
    			style = new Style({
    				image: new CircleStyle({
    					radius: 7,
    					fill: new Fill({ color: "rgba(216, 16, 2, 1)" }),
    					stroke: new Stroke({
    						color: "rgba(0, 0, 1, 1)",
    						width: 0.7,
    					}),
    				}),
    			});
    		}

    		let newLayer = new VectorImageLayer({
    			source: new VectorSource(),
    			style: style,
    			name: topParentName,
    			zIndex: 20,
    		});
    		map.addLayer(newLayer);
    	});
    };

    /* src/components/Ilion/Ilion.svelte generated by Svelte v3.38.3 */
    const file$1 = "src/components/Ilion/Ilion.svelte";

    function create_fragment$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "id", "map");
    			attr_dev(div, "class", "map svelte-co7k9w");
    			add_location(div, file$1, 70, 0, 1842);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Ilion", slots, []);
    	let map;

    	onMount(() => {
    		//..............MAP INIT..............
    		map = new Map$1({
    				layers: [
    					// Tile layers
    					new TileLayer({
    							preload: Infinity,
    							source: new XYZ({
    									// Google Satellite (change lyrs=s to "y" for Hybrid)
    									url: "https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}",
    									crossOrigin: "Anonymous"
    								}),
    							visible: true,
    							name: "satellite"
    						}),
    					// Free OSM
    					new TileLayer({
    							preload: Infinity,
    							source: new XYZ({
    									// OSM Free
    									url: "https://osm.proxad.net/osm/{z}/{x}/{y}.png",
    									crossOrigin: "Anonymous"
    								}),
    							visible: false,
    							name: "osm"
    						})
    				],
    				target: "map",
    				view: new View({
    						center: [430859.8627255495, 5405358.999465257],
    						zoom: 18,
    						constrainResolution: true,
    						projection: get$1("3857"),
    						extent: [
    							-4486061.8142350465,
    							3809906.867586845,
    							3898774.4405356483,
    							8403466.519412797
    						]
    					})
    			});

    		//..............DRAG AND DROP GEOJSON FILE..............
    		dragAndDrop(map);

    		//..............BUILD MAIN LAYERS..............
    		mainLayerBuild(map);

    		//..............EVENT MAP..............
    		map.on("movestart", moveStart);

    		map.on("click", openGeometry);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Ilion> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		dragAndDrop,
    		openGeometry,
    		Map: Map$1,
    		View,
    		Tile: TileLayer,
    		Vector: VectorLayer,
    		OSM,
    		VectorSource,
    		XYZ,
    		onMount,
    		moveStart,
    		mainLayerBuild,
    		getProjection: get$1,
    		map
    	});

    	$$self.$inject_state = $$props => {
    		if ("map" in $$props) map = $$props.map;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class Ilion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ilion",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/components/NotFound.svelte generated by Svelte v3.38.3 */

    const file = "src/components/NotFound.svelte";

    function create_fragment$1(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Error";
    			add_location(h1, file, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NotFound", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NotFound> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class NotFound extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NotFound",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.38.3 */

    function create_fragment(ctx) {
    	let ilion;
    	let current;
    	ilion = new Ilion({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(ilion.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(ilion, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ilion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ilion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ilion, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);

    	const routes = {
    		// Exact path
    		"/": Ilion,
    		// "/cables/:gid": Cable,
    		// Using named parameters, with last being optional
    		// This is dynamically imported, so the code is loaded on-demand from the server
    		// "/cables/:gid": wrap({
    		// 	// Note that this is a function that returns the import
    		// 	asyncComponent: () => import("./components/Features/Cable.svelte"),
    		// 	// Show the loading component while the component is being downloaded
    		// }),
    		// Catch-all, must be last
    		"*": NotFound
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Router, Ilion, NotFound, routes });
    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
    	target: document.body,
    	props: {},
    });

    return app;

}());
//# sourceMappingURL=main.js.map
